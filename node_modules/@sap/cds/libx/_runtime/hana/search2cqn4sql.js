const { computeColumnsToBeSearched } = require('../cds-services/services/utils/columns')
const searchToLike = require('../common/utils/searchToLike')
const { isContainsPredicateSupported, search2Contains } = require('./search2Contains')
const { addAliasToExpression } = require('../db/utils/generateAliases')

/**
 * Computes a CQN expression for a search query.
 *
 * For performance reasons, search queries over localized elements use the `CONTAINS` predicate in the `WHERE` clause
 * of a `SELECT` statement instead of the `LIKE` predicate when possible. The `LIKE` predicate might cause a high CPU
 * load on SAP HANA servers because the SAP HANA optimizer cannot push down `LIKE` expressions to the column storage
 * layer. As a result, search queries over large data sets are slow.
 *
 * The `CONTAINS` predicates with exact search option (default behavior) is rendered as `LIKE` by the HANA optimizer.
 * But in contrast to the explicitly written `LIKE ?`, the parameter is already resolved to its concrete value, making
 * it better optimizable by the HANA optimizer.
 *
 * @param {object} query The CQN object
 * @param {import('@sap/cds-compiler/lib/api/main').CSN} entity The target entity for the search query
 * @param {import('../types/api').search2cqnOptions} [options]
 * @returns {object} The modified CQN object
 */
const search2cqn4sql = (query, entity, options) => {
  const cqnSearchPhrase = query.SELECT.search
  if (!cqnSearchPhrase) return query

  let { columns: columns2Search = computeColumnsToBeSearched(query, entity), locale } = options
  const localizedAssociation = entity.associations?.localized

  // Resolve localized data at runtime if the localized association is defined for the target entity.
  // Notice that if the localized association is defined, there should be at least one localized element.
  if (localizedAssociation) {
    const onCondition = entity._relations[localizedAssociation.name].join(localizedAssociation.target, entity.name)

    // REVISIT this is dirty but works for now
    // replace $user_locale placeholder with the user locale or the HANA session context
    onCondition[0].xpr[onCondition[0].xpr.length - 1] = { val: locale || "SESSION_CONTEXT('LOCALE')" }

    // inner join the target table with the _texts table (the _texts table contains the translated texts)
    const localizedEntityName = localizedAssociation.target
    query.join(localizedEntityName).on(onCondition)

    // prevent SQL ambiguity error for columns with the same name
    columns2Search = _addAliasToQuery(query, entity, columns2Search)

    // suppress the localize handler from redirecting the query's target to the localized view
    Object.defineProperty(query, '_suppressLocalization', { value: true })
  } // else --> resolve localized texts via localized view (default)

  const useContains = !!localizedAssociation && isContainsPredicateSupported(query, entity, columns2Search)
  let expression

  if (useContains) {
    expression = search2Contains(cqnSearchPhrase, columns2Search)
    Object.defineProperty(query.SELECT, '_$searchUsingContains', { value: true, enumerable: true })
  } else {
    // No CONTAINS optimization possible. The search implementation for localized
    // texts falls back to the LIKE predicate.
    expression = searchToLike(cqnSearchPhrase, columns2Search)
  }

  // REVISIT: find out here if where or having must be used
  query._aggregated || /* if new parser */ query.SELECT.groupBy ? query.having(expression) : query.where(expression)
  return query
}

// The inner join modifies the original SELECT ... FROM query and adds ambiguity,
// therefore add the table/entity name (as a preceding element) to the columns ref
// to prevent a SQL ambiguity error.
const _addAliasToQuery = (query, entity, columnsToBeSearched) => {
  const SELECT = query.SELECT
  const localizedEntityName = entity.associations?.localized.target
  const elements = entity.elements
  const entityName = entity.name
  const getEntityName = columnRef => {
    const columnName = columnRef[0]
    const localizedElement = !!elements[columnName].localized
    const targetEntityName = localizedElement ? localizedEntityName : entityName
    return targetEntityName
  }

  SELECT.columns = addAliasToExpression(SELECT.columns, getEntityName)
  columnsToBeSearched = addAliasToExpression(columnsToBeSearched, getEntityName)
  SELECT.groupBy = addAliasToExpression(SELECT.groupBy, getEntityName)
  SELECT.orderBy = addAliasToExpression(SELECT.orderBy, getEntityName)
  SELECT.where = addAliasToExpression(SELECT.where, getEntityName)
  return columnsToBeSearched
}

module.exports = search2cqn4sql
