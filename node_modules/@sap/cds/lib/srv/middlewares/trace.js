const cds = require ('../../index'), { decodeURIComponent } = cds.utils
const LOG = cds.log('trace')
if (!LOG._debug) module.exports = ()=>[]; else {

  module.exports = (o={}) => {

    // normalize options
    let { truncate:t = 111, skip = { BEGIN:1, COMMIT:2, ROLLBACK:3 } } = o || {}
    if (typeof t !== 'function') o.truncate = !t ? s=>s : s => s.length <= t ? s : s.slice(0,t)+' ...'
    if (typeof skip !== 'function') o.skip = !skip ? ()=>false : x => (x.event||x) in skip
    const _perf = e => !o.skip(e) && cds.context?.http?.req._perf

    // instrument framework services
    _instrument_cds_services (_perf)
    _instrument_better_sqlite (_perf)
    _instrument_sqlite (_perf)

    // the express middleware function
    return function cap_perf_logger (req, res, next) {
      let perf = req._perf || (req._perf = new PerfTrace)
      perf.log (req.method, decodeURIComponent(req.originalUrl))
      res.on('finish', ()=> LOG.debug ('elapsed times:', perf.toString(o)))
      next()
    }
  }

  const { performance:{now} } = require ('perf_hooks')
  const { format } = require ('util')

  class PerfTrace extends Array {
    log (...details) {
      const e = { details, start:now() }
      return this.push(e), e
    }
    done (e) {
      return e.stop = now()
    }
    toString ({truncate}) {
      const t0 = this[0].start; if (!this[0].stop) this[0].stop = now()
      return '\n'+ this.map (e => truncate (format (
        (e.start - t0).toFixed(2).padStart(6), 'â†’',
        (e.stop  - t0).toFixed(2).padEnd(6), '= ',
        (e.stop  - e.start).toFixed(2).padStart(6), 'ms',
        '-', ...e.details))
      ).join('\n')
    }
  }
}


function _instrument_cds_services (_get_perf) {
  const me = _instrument_cds_services; if (me.done) return; else me.done = true
  const { handle } = cds.Service.prototype
  cds.Service.prototype.handle = function (req) {
    const perf = _get_perf(req)
    if (perf) {
      const pe = perf.log (this.name, '-', req.event, req.path||'')
      var _done = r => { perf.done(pe); return r }
    }
    return handle.apply (this, arguments) .then (_done)
  }
}

function _instrument_sqlite (_get_perf) {
  const me = _instrument_sqlite; if (me.done) return; else me.done = true
  try { require.resolve('sqlite3') } catch { return }
  // eslint-disable-next-line cds/no-missing-dependencies
  const sqlite = require('sqlite3').Database.prototype
  for (let each of ['all', 'get', 'run', 'prepare']) {
    const _super = sqlite[each]
    sqlite[each] = function (q, ..._) {
      const perf = _get_perf(q)
      if (perf) {
        const pe = perf.log ('sqlite -', q)
        const callback = _[_.length-1]; _[_.length-1] = function(){
          perf.done(pe)
          callback.apply (this, arguments)
        }
      }
      return _super.call (this, q, ..._)
    }
  }
}

function _instrument_better_sqlite (_get_perf) {
  const me = _instrument_better_sqlite; if (me.done) return; else me.done = true
  try { require.resolve('better-sqlite3') } catch { return }
  // eslint-disable-next-line cds/no-missing-dependencies
  const sqlite = require('better-sqlite3').prototype
  for (let each of ['exec', 'prepare']) {
    const _super = sqlite[each]
    sqlite[each] = function (q, ..._) {
      const perf = _get_perf(q)
      if (perf) {
        const pe = perf.log ('sqlite -', q)
        try { return _super.call (this, q, ..._) }
        finally { perf.done(pe) }
      }
      else return _super.call (this, q, ..._)
    }
  }
}
