const fs = require('fs')
const path = require('path')
const { hasJavaNature, getProperty, isStreamlinedMtx, BuildError } = require('../util')
const BuildTaskProvider = require('../buildTaskProvider')

const { FILE_EXT_CDS, BUILD_TASK_HANA, BUILD_TASK_FIORI, BUILD_TASK_JAVA, BUILD_TASK_JAVA_CF, BUILD_TASK_NODEJS, BUILD_TASK_NODE_CF, BUILD_TASK_MTX,
    BUILD_TASK_PREFIX, BUILD_TASKS, BUILD_TASK_MTX_SIDECAR, MTX_SIDECAR_FOLDER, BUILD_TASK_MTX_EXTENSION } = require("../constants")

class BuildTaskProviderInternal extends BuildTaskProvider {
    constructor(cds, logger) {
        super()
        this._cds = cds
        this._logger = logger
    }

    get cds() {
        return this._cds
    }
    get env() {
        return this.cds.env
    }
    get logger() {
        return this._logger
    }

    canHandleTask(task) {
        return BUILD_TASKS.includes(task.for)
            || task.use && task.use.startsWith(BUILD_TASK_PREFIX)
        // support different build task implementations of the same build task ID defined by 'for'
        //return (BUILD_TASKS.includes(task.for) && !task.use) || (task.use && task.use.startsWith(BUILD_TASK_PREFIX))
    }

    loadHandler(task) {
        return require(`./${BuildTaskProviderInternal._getForValueFromTask(task)}`)
    }

    async lookupTasks(tasks, buildOptions) {
        return this._createTasks(tasks, buildOptions, tasks.length > 0)
    }

    async applyTaskDefaults(task) {
        const taskFor = BuildTaskProviderInternal._getForValueFromTask(task)
        task.for = task.for || taskFor
        task.use = task.use || `${BUILD_TASK_PREFIX}/${taskFor}`

        if (!task.src) {
            switch (taskFor) {
                case BUILD_TASK_HANA:
                    task.src = BuildTaskProviderInternal._normalizePath(this.env.folders.db)
                    break
                case BUILD_TASK_JAVA:
                case BUILD_TASK_JAVA_CF:
                case BUILD_TASK_NODEJS:
                case BUILD_TASK_NODE_CF:
                    task.src = BuildTaskProviderInternal._normalizePath(this.env.folders.srv)
                    break
                case BUILD_TASK_FIORI:
                    task.src = BuildTaskProviderInternal._normalizePath(this.env.folders.app)
                    break
                case BUILD_TASK_MTX_EXTENSION:
                case BUILD_TASK_MTX:
                    task.src = "."
                    break
                case BUILD_TASK_MTX_SIDECAR:
                    task.src = MTX_SIDECAR_FOLDER
                    break
                default:
                    throw new Error(`Unknown build task '${task.use || task.for}'`)
            }
        }
    }

    async _createTasks(tasks, buildOptions, addRequiredTasks) {
        const { root: projectPath } = buildOptions
        let db = typeof this.env.folders.db === "string" ? [BuildTaskProviderInternal._normalizePath(this.env.folders.db)] : this.env.folders.db
        let srv = typeof this.env.folders.srv === "string" ? [BuildTaskProviderInternal._normalizePath(this.env.folders.srv)] : this.env.folders.srv

        const dbOptions = {
            model: []
        }
        const srvOptions = {
            model: []
        }
        if (Array.isArray(db) && db.length > 0) {
            db = BuildTaskProviderInternal._getModuleFolder(projectPath, db) || null
            if (!db && !addRequiredTasks) { // log once
                this.logger.log("No database module found")
            }
        }
        if (Array.isArray(srv) && srv.length > 0) {
            srv = BuildTaskProviderInternal._getModuleFolder(projectPath, srv) || null
            if (!srv && !addRequiredTasks) { // log once
                this.logger.log("No service module found")
            }
        }
        // create required build tasks
        if (addRequiredTasks) {
            const mtxTask = tasks.find(task => task.for === BUILD_TASK_MTX || task.for === BUILD_TASK_MTX_SIDECAR)
            if (mtxTask) {
                //restore used tasks as they might have been filtered by 'cds build --for mtx'
                if (mtxTask._uses) {
                    mtxTask._uses.map(use => use.task).forEach(task => {
                        if (!tasks.includes(task)) {
                            tasks.push(task)
                        }
                    })
                }
                let dbTask = tasks.find(task => task.for === BUILD_TASK_HANA)
                if (!dbTask) {
                    //  db task might be missing if mtx task is enforced by 'cds build --for mtx'
                    dbTask = this._createDbTask(projectPath, db, dbOptions)
                    if (dbTask) {
                        tasks.push(dbTask)
                    }
                }
                if (dbTask && (!mtxTask._uses || !mtxTask._uses.map(use => use.task).includes(dbTask))) {
                    const use = { task: dbTask }
                    mtxTask._uses ? mtxTask._uses.push(use) : mtxTask._uses = [use]
                }
            }
        } else {
            !db && this.logger._debug && this.logger.debug(`project doesn't have a database module '${this.env.folders.db}'`)
            !srv && this.logger._debug && this.logger.debug(`project doesn't have a service module '${this.env.folders.srv}'`)

            // create hana build task
            const dbTask = this._createDbTask(projectPath, db, dbOptions, buildOptions)
            if (dbTask) {
                tasks.push(dbTask)
            }
            // create java or node build task
            const srvTask = this._createSrvTask(projectPath, srv, srvOptions)
            if (srvTask) {
                tasks.push(srvTask)
            }
            // create mtx build task
            const mtxTask = this._createMtxTask(projectPath, srv, srv, tasks)
            if (mtxTask) {
                tasks.push(mtxTask)
            }
        }
    }

    _createDbTask(projectPath, src, taskOptions, buildOptions) {
        this.logger.debug("determining database kind.")
        if (!src || BuildTaskProviderInternal._isExtension(this.env)) {
            return null
        }
        let task = null
        if (this._useHana(projectPath, buildOptions)) {
            this.logger.debug("found HANA database.")
            // legacy build supports dest property
            const compileDest = this.env.data?.dest
            if (compileDest) {
                //../db/src/gen
                // compileDest is relative to src folder in modular build - resolve correctly
                taskOptions.compileDest = path.relative(path.resolve(projectPath, src), path.resolve(projectPath, compileDest))
            }
            task = {
                src: src,
                for: BUILD_TASK_HANA,
                options: taskOptions
            }
        } else {
            this.logger.debug("found sqlite database - skipping HANA build task")
        }
        return task
    }

    _useHana(projectPath, buildOptions) {
        if (getProperty(buildOptions, "for.hana.skipManifestGeneration") // deprecated fallback for webide fullstack and mtx
            || getProperty(buildOptions, "for.hana.contentManifest") === false // fallback for webide fullstack and mtx
            || this.env.requires.db?.kind === "hana"
            || this.env.requires.db?.dialect === "hana") {

            return true
        }
        // false if other db has been defined
        if (this.env.requires.db?.kind) {
            return false
        }
        // check whether cds config represents a legacy build system config for which requires.db was not configured
        // Note: compat layer sets requires.db: {}
        const userEnv = this.cds.env.for("cds", projectPath, false)
        return userEnv && (userEnv.data?.model || userEnv.service?.model)
    }

    _createMtxTask(projectPath, src, dest, tasks) {
        // MTX build task creation is NOT supported for Java projects
        if (tasks.find(task => task.for === BUILD_TASK_JAVA || task.for === BUILD_TASK_JAVA_CF)) {
            return null
        }
        this.logger.debug("determining mtx type for nodejs")

        if (isStreamlinedMtx(this.cds)) {
            if (this.env.requires["cds.xt.ModelProviderService"]?.kind === "rest") { // "cds.xt.ModelProviderService": "from-sidecar"
                this.logger.debug("Nodejs Streamlined MTX app with sidecar")

                const sidecarPath = path.join(projectPath, MTX_SIDECAR_FOLDER)
                if (!fs.existsSync(sidecarPath)) {
                    throw new BuildError("CDS build failed", `MTX sidecar directory '${sidecarPath}' not existing. Custom build task configuration necessary if the folder is named differently.`)
                }
                const sidecarEnv = this.env.for("cds", sidecarPath)
                if (sidecarEnv.requires["cds.xt.ModelProviderService"]?.kind === "in-sidecar") {
                    return {
                        for: BUILD_TASK_MTX_SIDECAR
                    }
                }
                throw new BuildError("CDS build failed", 'Invalid MTX sidecar configuration. Make sure to add required service "cds.xt.ModelProviderService": "in-sidecar".')
            }

            if (this.env.requires["cds.xt.ModelProviderService"]?.kind === "in-sidecar") {
                // cds build is executed in sidecar folder
                throw new BuildError("CDS build failed", "Invalid working directory. Make sure to execute 'cds build' in CAP project root directory.")
            }

            this.logger.debug("Nodejs Streamlined MTX app without sidecar")
            return {
                for: BUILD_TASK_MTX,
                src
            }
        }

        if (BuildTaskProviderInternal._isExtension(this.env)) {
            this.logger.debug("Streamlined MTX extension app")
            return {
                for: BUILD_TASK_MTX_EXTENSION
            }
        }

        if (this.env.requires.multitenancy) {
            this.logger.debug("Nodejs Classic MTX app without sidecar")
            return {
                src: ".",
                for: BUILD_TASK_MTX,
                dest
            }
        }
    }

    _createSrvTask(projectPath, src, taskOptions) {
        this.logger.debug("determining implementation technology")
        if (!src || BuildTaskProviderInternal._isExtension(this.env)) {
            return null
        }
        let task = null
        if (BuildTaskProviderInternal._hasJavaNature(projectPath, src)) {
            task = this._createJavaTask(projectPath, src, taskOptions)
        } else {
            task = this._createNodeTask(src, taskOptions)
        }
        return task
    }

    _createJavaTask(projectPath, src, taskOptions) {
        this.logger.debug("found implementation technology java")
        // legacy build supports dest property
        const compileDest = this.env.service?.dest
        if (compileDest) {
            // compileDest is relative to src folder in modular build - resolve correctly
            taskOptions.compileDest = path.relative(path.resolve(projectPath, src), path.resolve(projectPath, compileDest))
        }
        return {
            src: src,
            for: BUILD_TASK_JAVA,
            options: taskOptions
        }
    }

    _createNodeTask(src, taskOptions) {
        this.logger.debug("found implementation technology node")
        return {
            src: src,
            for: BUILD_TASK_NODEJS,
            options: taskOptions
        }
    }

    static _isExtension(env) {
        return !!env.extends
    }

    /**
     * Returns whether this project is a java project or not.
     * @param {string} projectPath - the absolute project path
     * @param {string} src - the folder name of the service module
     */
    static _hasJavaNature(projectPath, src) {
        return hasJavaNature([path.join(projectPath, src), projectPath])
    }

    static _getForValueFromTask(task) {
        return task.for ? task.for : task.use && task.use.substring(BUILD_TASK_PREFIX.length + 1)
    }

    /**
     * For valid paths remove trailing '/'. Otherwise return as is - important!!
     * @param {*} dir
     */
    static _normalizePath(dir) {
        return typeof dir === "string" ? dir.replace(/\/$/, '') : dir
    }

    /**
     * Determines the module folder from the past list that may represent files or folders w or w/o .cds file extension.
     * @param {string} projectPath
     * @param {Array} filesOrFolders
     */
    static _getModuleFolder(projectPath, filesOrFolders) {
        const resources = [...filesOrFolders]
        filesOrFolders.forEach(fileOrFolder => {
            if (path.extname(fileOrFolder) !== FILE_EXT_CDS) {
                resources.push(fileOrFolder + FILE_EXT_CDS)
            }
        })
        return resources.reduce((acc, resource) => {
            if (!acc) {
                let resourcePath = path.resolve(projectPath, resource)
                if (fs.existsSync(resourcePath)) {
                    if (fs.lstatSync(resourcePath).isDirectory()) {
                        acc = resource
                    } else {
                        // represents file
                        acc = path.dirname(resource)
                    }
                }
            }
            return acc
        }, null)
    }
}
module.exports = BuildTaskProviderInternal
