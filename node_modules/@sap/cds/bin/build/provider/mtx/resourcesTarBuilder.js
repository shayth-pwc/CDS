const path = require('path')
const BuildTaskHandlerInternal = require('../buildTaskHandlerInternal')

const { BUILD_TASK_HANA } = require('../../constants')
const { WARNING } = BuildTaskHandlerInternal
const DEFAULT_TAR_NAME = "resources.tgz"

class ResourcesTarBuilder {
    constructor(handler) {
        this._handler = handler
    }

    get handler() { return this._handler }

    async createTar(dest, model) {
        const { root, files } = await this._getResources(model)
        if (files.length === 0) {
            // packTarArchive fails otherwise
            this.handler.pushMessage("No deployment resources found - skip resources.tgz", WARNING)
            return
        }
        await this.writeTarFile(files, root, path.join(dest, DEFAULT_TAR_NAME))
    }

    async writeTarFile(files, root, tarFile) {
        const { tar } = require('../../../../lib').utils
        await tar.czfd (tarFile, root, files) // REVISIT: tar.czfd was created for this case only -> it ensures the target's dir exists
        this.handler.pushFile(tarFile)
    }

    async _getResources(model) {
        // distinguish HANA and SQLITE deployment
        let root = await this._getHanaTenantDbDest()
        let files
        if (root) {
            files = this._getHanaResources(root)
        } else {
            root = path.join(this.handler.buildOptions.root, this.handler.env.folders.db)
            files = await this._getSqliteResources(model)
        }
        return { root, files }
    }

    /**
     * Reads all resources for HANA deployment - 'db/src/**' and 'db/undeploy.json'.
     * - CSV files, native HANA artifacts, generated HANA artifacts, undeploy.json
     * See '../../../../lib.deploy'
     * Note: the hana build task has already been executed
     * @param {string} root
     * @returns an array containing all resources
     */
    _getHanaResources(root) {
        const hanaNativeFolders = [path.join(root, 'src'), path.join(root, 'cfg')]
        const hanaNativeFiles = [path.join(root, 'undeploy.json'), path.join(root, '.hdiignore')]

        return BuildTaskHandlerInternal._find(root, (res) => {
            if (hanaNativeFolders.some(folder => res.startsWith(folder)) || hanaNativeFiles.some(file => res === file)) {
                return true
            }
            return false
        })
    }

    /**
     * Reads all resources for Sqlite deployment - see '../../../../lib.deploy'
     *
     * @param {object} model
     * @returns
     */
    async _getSqliteResources(model) {
        const { resources } = this.handler.cds.deploy
        return Object.keys(await resources(model))
    }

    /**
     * Returns the build tasks of this project - either user defined or calculated by BuildTaskFactory.
     * A build task of type 'hana' is enforced in order to copy existing native hana artifacts later on.
     *
     * @returns {string} the src folder of the tenant db module
     */
    async _getHanaTenantDbDest() {
        const buildOptions = this.handler.buildOptions
        let hanaTask = buildOptions.tasks ? buildOptions.tasks.find(task => task.for === BUILD_TASK_HANA) : undefined
        if (!hanaTask) {
            this.handler.pushMessage(`Found SQLite database configuration. Ensure that productive cloud deployments requiring SAP HANA database are built with 'production' profile.`, WARNING)
            return null
        }
        return hanaTask.dest
    }
}
module.exports = ResourcesTarBuilder
