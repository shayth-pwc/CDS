// Populate views with elements, elements with association targets, ...

// The functionality in this file is the heart of the Core Compiler and the
// most complex part.  It essentially implements the function `environment`
// used when resolving element references: when starting a references at a
// certain definition or element, which names are allowed next?
//
// To calculate that info, the compiler might need the same info for other
// definitions.  In other words: it calls itself recursively (using an iterative
// algorithm where appropriate).  To be able to calculate that info on demand,
// the definitions need to have enough information, which must have been set in
// an earlier compiler phase.  It is essential to do things in the right order.

// TODO: It might be that we need to call propagateKeyProps() and
// addImplicitForeignKeys() in populate.js, as we might need to know the
// foreign keys in populate.js (foreign key access w/o JOINs).

'use strict';

const {
  isDeprecatedEnabled,
  forEachDefinition,
  forEachMember,
  forEachGeneric,
} = require('../base/model');
const {
  dictAdd, dictAddArray,
} = require('../base/dictionaries');
const { dictLocation } = require('../base/location');
const { weakLocation } = require('../base/messages');
const { CompilerAssertion } = require('../base/error');

const { kindProperties } = require('./base');
const {
  pushLink,
  setLink,
  setArtifactLink,
  annotationVal,
  annotationIsFalse,
  annotationLocation,
  augmentPath,
  splitIntoPath,
  linkToOrigin,
  setMemberParent,
  dependsOn,
  traverseQueryPost,
  setExpandStatus,
  setExpandStatusAnnotate,
} = require('./utils');

const $inferred = Symbol.for('cds.$inferred');


// Export function of this file.
function populate( model ) {
  const { options } = model;
  // Get shared functionality and the message function:
  const {
    info, warning, error, message,
  } = model.$messageFunctions;
  const {
    resolvePath,
    attachAndEmitValidNames,
    initArtifact,
  } = model.$functions;
  model.$volatileFunctions.environment = environment;
  Object.assign( model.$functions, {
    effectiveType,
    directType,
    resolveType,
    populateQuery,
  } );


  /** @type {any} may also be a boolean */
  let newAutoExposed = [];

  const scopedRedirections
        = !isDeprecatedEnabled( options, '_shortAutoexposed' ) &&
          !isDeprecatedEnabled( options, '_longAutoexposed' ) &&
          !isDeprecatedEnabled( options, '_noInheritedAutoexposeViaComposition' ) &&
          !isDeprecatedEnabled( options, '_noScopedRedirections' );
  const autoexposeViaComposition
        = (isDeprecatedEnabled( options, '_noInheritedAutoexposeViaComposition' ))
          ? 'Composition'
          : true;
  const redirectInSubQueries = isDeprecatedEnabled( options, '_redirectInSubQueries' );

  forEachDefinition( model, traverseElementEnvironments );
  while (newAutoExposed.length) {
    // console.log( newAutoExposed.map( a => a.name.absolute ) )
    const all = newAutoExposed;
    newAutoExposed = [];
    all.forEach( traverseElementEnvironments );
  }
  newAutoExposed = true;      // internal error if auto-expose after here
  return;


  //--------------------------------------------------------------------------
  // The central functions for path resolution - must work on-demand
  //--------------------------------------------------------------------------
  // Phase 2: call populateView(), which also works on-demand

  function traverseElementEnvironments( art ) {
    populateView( art );
    environment( art );
    if (art.elements$ || art.enum$)
      mergeSpecifiedElementsOrEnum(art);
    forEachMember( art, traverseElementEnvironments );
  }

  // Return effective search environment provided by artifact `art`, i.e. the
  // `artifacts` or `elements` dictionary.  For the latter, follow the `type`
  // chain and resolve the association `target`.  View elements are calculated
  // on demand.
  function environment( art, location, user, assocSpec ) {
    if (!art)
      return Object.create(null);
    const env = navigationEnv( art, location, user, assocSpec );
    return env && env.elements || Object.create(null);
  }

  function navigationEnv( art, location, user, assocSpec ) {
    let type = effectiveType(art) || art;
    // console.log( info(null, [ art.location, art ], { art, type }, 'ENV')
    //              .toString(), art.elements && Object.keys(art.elements))
    if (type.target) {
      type = resolvePath( type.target, 'target', type );
      if (!type) {
        if (type === 0 && location)
          dependsOn( art, art, (art.target || art.type).location );
        return type;
      }
      // TODO: combine this with setTargetReferenceKey&Co in getPathItem?
      else if (assocSpec === false) { // TODO: else warning for assoc usage
        error( null, [ location, user ], {},
               'Following an association is not allowed in an association key definition' );
      }
      else if (assocSpec && user) {
        dependsOn( user, type, location );
      }
    }
    populateView( type );
    return type;
  }

  // Follow the `type` chain, i.e. derived types and TYPE OF, stop just before
  // built-in types (otherwise, we would loose type parameters).  Return that
  // type and set it as property `_effectiveType` on all artifacts on the chain.
  // TODO: clarify for (query) elements without type: self, not undefined - also for entities!
  // TODO: directly "propagate" (with implicit redirection the targets), also
  // "proxy-copy" elements

  // In v2, the name-resolution relevant properties (elements,items,target) are
  // proxy-copied, i.e. the effectiveType of an artifact is always the artifact
  // itself.  Except for the situation with recursive element expansions; then
  // we have element: 0, and use original final type.
  function effectiveType( art ) {
    if ('_effectiveType' in art)
      return art._effectiveType;

    // console.log(message( null, art.location, art, {}, 'Info','FT').toString())
    const chain = [];
    while (art && !('_effectiveType' in art) &&
           (art.type || art._origin || art.value?.path || art.value?.type) &&
           !art.target && !art.enum && !art.elements && !art.items) {
      chain.push( art );
      setLink( art, '_effectiveType', 0 ); // initial setting in case of cycles
      art = directType( art );
    }
    if (art) {
      if ('_effectiveType' in art) { // is the case for builtins
        art = art._effectiveType;
      }
      else {
        setLink( art, '_effectiveType', art );
        if (art.expand && !art.value && !art.elements)
          initFromColumns( art, art.expand );
        // When not blocked (by future origin = false) and not REDIRECTED TO and not MIXIN
        // try to implicitly redirect explicitly provided target:
        else if (art.target && art._origin == null && !art.value && art.kind !== 'mixin')
          redirectImplicitly( art, art );
      }
    }
    chain.reverse();
    if (!art) {
      for (const a of chain)
        setLink( a, '_effectiveType', art );
    }
    else {
      // collect the "latest" cardinality (calculate lazily if necessary)
      let cardinality = art.cardinality ||
          art._effectiveType && (() => getCardinality( art._effectiveType ));
      for (const a of chain) {
        if (a.cardinality)
          cardinality = a.cardinality;
        if (a.expand && expandFromColumns( a, art, cardinality ) ||
            art.target && redirectImplicitly( a, art ) ||
            art.elements && expandElements( a, art ) ||
            art.items && expandItems( a, art ))
          art = a;

        else if (art.enum && expandEnum( a, art ))
          art = a;

        setLink( a, '_effectiveType', art );
      }
    }
    return art;
  }

  // TODO: test it in combination with top-level CAST function
  function directType( art ) {
    // Be careful when using it with art.target or art.enum or art.elements
    if (art._origin || art.builtin)
      return art._origin;
    if (art.type)
      return resolveType( art.type, art );
    if (art.value?.type)
      return resolveType( art.value.type, art );
    // console.log( 'EXPR-IN', art.kind, refString(art.name) )
    if (!art._main || !art.value || !art.value.path)
      return undefined;
    if (art._pathHead && art.value.path) {
      setLink( art, '_origin', resolvePath( art.value, 'expr', art, null ) );
      return art._origin;
    }
    const query = userQuery( art ) || art._parent;
    if (query.kind !== 'select')
      return undefined;
    // Reached an element in a query which is a simple ref -> return referred artifact
    // TODO: remember that we still have to resolve path arguments and filters
    return setLink( art, '_origin',
                    resolvePath( art.value, 'expr', art, query._combined ) );
    // console.log( 'EXPR-OUT', art.value._artifact.kind, refString(art.val ue._artifact.name) );
  }

  function resolveType( ref, user ) {
    if ('_artifact' in ref)
      return ref._artifact;
    if (ref.scope === 'typeOf') {
      let struct = user;
      while (struct.kind === 'element')
        struct = struct._parent;
      if (struct.kind === 'select' || struct.kind === 'annotation') {
        // `type of` in annotation definitions can't work, because csn type refs
        // always refer to definitions.
        message( 'type-unexpected-typeof', [ ref.location, user ],
                 { keyword: 'type of', '#': struct.kind } );
        // we actually refer to an element in _combined; TODO: return null if
        // not configurable; would produce illegal CSN with sub queries in FROM
      }
      else if (struct !== user._main) {
        message( 'type-unexpected-typeof', [ ref.location, user ],
                 { keyword: 'type of', '#': struct.kind } );
        return setArtifactLink( ref, null );
      }
      return resolvePath( ref, 'typeOf', user );
    }
    while (user._outer)         // in items
      user = user._outer;
    if (user.kind === 'event')
      return resolvePath( ref, 'eventType', user );
    if (user.kind === 'param' && user._parent &&
      (user._parent.kind === 'action' || user._parent.kind === 'function'))
      return resolvePath( ref, 'actionParamType', user );
    return resolvePath( ref, 'type', user );
  }

  function getCardinality( type ) {
    // only to be called without cycles
    while (type) {
      if (type.cardinality)
        return type.cardinality;
      type = directType( type );
    }
    return {};
  }

  function userQuery( user ) {
    // TODO: we need _query links set by the definer
    while (user._main) {
      if (user.kind === 'select' || user.kind === '$join')
        return user;
      user = user._parent;
    }
    return null;
  }

  // Expansiosn --------------------------------------------------------------


  function expandItems( art, origin ) {
    if (art.items)
      return false;
    if (origin.items === 0 || art.$inferred === 'expanded' && isInRecursiveExpansion( art )) {
      art.items = 0;            // circular
      return true;
    }
    const ref = art.type || art.value || art.name;
    const location = ref && ref.location || art.location;
    art.items = { $inferred: 'expanded', location };
    setLink( art.items, '_outer', art );
    setLink( art.items, '_parent', art._parent );
    setLink( art.items, '_origin', origin.items );
    if (!art.$expand)
      art.$expand = 'origin';   // if value stays, elements won't appear in CSN
    return true;
  }

  function expandElements( art, struct ) {
    if (art.elements || art.kind === '$tableAlias' || art.kind === '$inline' ||
        // no element expansions for "non-proper" types like
        // entities (as parameter types) etc:
        struct.kind !== 'type' && struct.kind !== 'element' && struct.kind !== 'param' &&
        !struct._outer)
      return false;
    if (struct.elements === 0 || art.$inferred === 'expanded' && isInRecursiveExpansion( art )) {
      art.elements = 0;         // circular
      return true;
    }
    const ref = art.type || art.value || art.name;
    const location = ref && ref.location || art.location;
    // console.log( message( null, location, art, {target:struct,art}, 'Info','EXPAND-ELEM')
    //              .toString(), Object.keys(struct.elements))
    for (const name in struct.elements) {
      const orig = struct.elements[name];
      // const orig = elem.kind === '$navElement'
      if (Array.isArray( orig )) // redefinitions
        continue;
      linkToOrigin( orig, name, art, 'elements', weakLocation( location ), true )
        // or should we use orig.location? - TODO: try to find test to see message
        .$inferred = 'expanded';
    }
    // Set elements expansion status (the if condition is always true, as no
    // elements expansion will take place on artifact with existing other
    // member property):
    if (!art.$expand)
      art.$expand = 'origin';   // if value stays, elements won't appear in CSN
    // TODO: have some art.elements[SYM.$inferred] = 'expanded';
    return true;
  }

  function expandEnum( art, origin ) {
    if (art.enum)
      return false;
    const ref = art.type || art.value || art.name;
    const location = weakLocation( ref && ref.location || art.location );
    art.enum = Object.create(null);
    for (const name in origin.enum) {
      const orig = origin.enum[name];
      linkToOrigin( orig, name, art, 'enum', location, true )
        // or should we use orig.location? - TODO: try to find test to see message
        .$inferred = 'expanded';
    }
    // Set elements expansion status (the if condition is always true, as no
    // elements expansion will take place on artifact with existing other
    // member property):
    if (!art.$expand)
      art.$expand = 'origin';   // if value stays, elements won't appear in CSN
    art.enum[$inferred] = 'expanded';
    return true;
  }

  /**
   * Return true iff `art` is from a recursive expansion, i.e.  if any of its
   * expanded parents (including _outer) has the same non-expansion-origin.
   */
  function isInRecursiveExpansion( art ) {
    const current = nonExpandedArtifact( art );
    if (current.$inCycle)
      return true;
    const cycle = [ current ];
    while (art.$inferred === 'expanded') {
      art = outerOrParent( art );
      const origin = nonExpandedArtifact( art );
      cycle.push( origin );
      if (origin.$inCycle || origin === current) {
        for (const a of cycle)
          a.$inCycle = true;
        return true;
      }
    }
    return false;
  }

  function outerOrParent( art ) {
    if (art._outer)
      return art._outer;
    art = art._parent;
    // TODO: think about setting _parent of elements in `items` object holding
    // `elements`, not the most outer `items` -> return art._outer || art._parent
    while (art.items)
      art = art.items;
    return art;
  }

  function nonExpandedArtifact( art ) {
    while (art.$inferred === 'expanded')
      art = art._origin;
    return art;
  }

  //--------------------------------------------------------------------------
  // Views
  //--------------------------------------------------------------------------

  // Make a view to have elements (remember: wildcard), and prepare that their
  // final type can be resolved, i.e. we know how to resolve select item refs.
  // We do so by first populate views in the FROM clause, then the view query.
  function populateView( art ) {
    if (!art._from || art._status === '_query')
      return;
    const resolveChain = [];
    const fromChain = [ art ];
    while (fromChain.length) {
      const view = fromChain.pop();
      if (view._status === '_query') // already fully resolved (status at def)
        continue;
      resolveChain.push( view );
      for (const from of view._from) {
        if (from._status)       // status at the ref -> illegal recursion -> stop
          continue;
        setLink( from, '_status', '_query' );
        // setLink before resolvePath - Cycle: view V as select from V.toV
        let source = resolvePath( from, 'from', view ); // filter and args in resolveQuery
        // console.log('ST:',msgName(source),from._status)
        if (source && source._main) { // element -> should be assoc
          const type = effectiveType( source );
          source = type && type.target;
        }
        if (source && source._from && source._status !== '_query')
          fromChain.push( source );
      }
    }
    // console.log( resolveChain.map( v => msgName(v)+v._status ) );
    for (const view of resolveChain.reverse()) {
      if (view._status !== '_query' ) { // not already resolved
        setLink( view, '_status', '_query' );
        // must be run in order “sub query in FROM first”:
        traverseQueryPost( view.query, null, populateQuery );
        if (!view.$entity) {
          model._entities.push( view );
          view.$entity = ++model.$entity;
        }
      }
    }
  }

  /**
   * Merge _specified_ elements with _inferred_ elements in the given view/element,
   * where specified elements can appear through CSN.
   *
   * We only copy annotations, since they are not part of `columns`,
   * but only appear in `elements` in CSN.
   *
   * This is important to ensure re-compilability.
   *
   * @param art
   */
  function mergeSpecifiedElementsOrEnum( art ) {
    // Later we use specified elements as proxies to inferred of leading query
    // (No, we probably do not.)
    for (const id in (art.elements || art.enum)) {
      const ielem = art.elements ? art.elements[id] : art.enum[id];  // inferred element
      const selem = art.elements$ ? art.elements$[id] : art.enum$[id]; // specified element
      if (!selem) {
        info( 'query-missing-element', [ ielem.name.location, art ], { id },
              'Element $(ID) is missing in specified elements' );
      }
      else {
        let wasAnnotated = false;
        for (const prop in selem) {
          // just annotation assignments and doc comments for the moment
          if (prop.charAt(0) === '@' || prop === 'doc') {
            ielem[prop] = selem[prop];
            // required for gensrc mode of to-csn.js, otherwise the annotation
            // may be lost during recompilation.
            ielem[prop].$priority = 'annotate';
            wasAnnotated = true;
          }
        }

        if (wasAnnotated)
          setExpandStatusAnnotate(art, 'annotate');

        selem.$replacement = true;
        if (selem.elements) {
          setLink(ielem, 'elements$', selem.elements);
          delete selem.elements;
        }
        if (selem.enum) {
          setLink(ielem, 'enum$', selem.enum);
          delete selem.enum;
        }
      }
    }
    // TODO: We don't check enum$, yet! We first need to fix expansion for
    //       `cast(elem as EnumType)` (see #9421)
    for (const id in art.elements$) {
      const selem = art.elements$[id]; // specified element
      if (!selem.$replacement) {
        error( 'query-unspecified-element', [ selem.name.location, selem ], { id },
               'Element $(ID) does not result from the query' );
      }
    }
  }

  function populateQuery( query ) {
    if (query._combined || !query.from || !query.$tableAliases)
      // already done or $join query or parse error
      return;
    setLink( query, '_combined', Object.create(null) );
    query.$inlines = [];
    forEachGeneric( query, '$tableAliases', resolveTabRef );

    initFromColumns( query, query.columns );
    if (query.excludingDict) {
      for (const name in query.excludingDict)
        resolveExcluding( name, query._combined, query.excludingDict, query );
    }
    return;

    function resolveTabRef( alias ) {
      if (alias.kind === 'mixin' || alias.kind === '$self')
        return;
      if (!alias.elements) { // could be false in hierarchical JOIN
        // if (main._block.$frontend!=='json') console.log('TABREF:',alias.name,main,main._block)
        // const tab = alias.path && resolvePath( alias, 'from', query );
        // // if (tab) setLink( alias, '_effectiveType', alias );
        // const elements = alias.query ? alias.query.elements : environment( tab );
        if (!('_origin' in alias) && alias.path) {
          const tab = resolvePath( alias, 'from', query );
          setLink( alias, '_origin', tab && navigationEnv( tab ) );
        }
        alias.elements = Object.create(null); // Set explicitly, as...
        // ...with circular dep to source, no elements can be found.
        const location = alias.path && alias.path.location;
        const qtab = alias._origin;
        if (!qtab || !qtab.elements)
          return;
        forEachGeneric( qtab, 'elements', ( origin, name ) => {
          const elem = linkToOrigin( origin, name, alias, 'elements',
                                     location || origin.name.location );
          elem.kind = '$navElement';
          // elem.name.select = query.name.select;
          if (origin.masked)
            elem.masked = Object.assign( { $inferred: 'nav' }, origin.masked );
        });
      }
      forEachGeneric( { elements: alias.elements }, 'elements', ( elem, name ) => {
        if (elem.$duplicates !== true)
          dictAddArray( query._combined, name, elem, null ); // not dictAdd()
      });
    }
  }

  function resolveExcluding( name, env, excludingDict, user ) {
    if (env[name])
      return;
    /** @type {object} */
    // console.log(name,Object.keys(env),Object.keys(excludingDict))
    const compileMessageRef = info(
      'ref-undefined-excluding', [ excludingDict[name].location, user ], { name },
      'Element $(NAME) has not been found'
    );
    attachAndEmitValidNames( compileMessageRef, env );
  }

  // query columns -----------------------------------------------------------

  function expandFromColumns( elem, assoc, cardinality ) {
    const path = elem.value && elem.value.path;
    if (!path || path.broken)
      return null;
    if (!assoc.target)
      return initFromColumns( elem, elem.expand );
    const { targetMax } = path[path.length - 1].cardinality ||
          (cardinality instanceof Function ? cardinality() : cardinality);
    if (targetMax && (targetMax.val === '*' || targetMax.val > 1))
      elem.items = { location: dictLocation( elem.expand ) }; // TODO: array location
    return initFromColumns( elem, elem.expand );
  }

  // TODO: make this function shorter - make part of this (e.g. setting
  // parent/name) also be part of definer.js
  // TODO: query is actually the elemParent, where the new elements are added to
  // top-level: just query, columns
  // inline: + elements (TODO: remove), colParent
  // expand: just query (which is a column/element), columns=array of expand
  function initFromColumns( query, columns, inlineHead = undefined ) {
    const elemsParent = query.items || query;
    if (!inlineHead) {
      elemsParent.elements = Object.create(null);
      if (query._main._leadingQuery === query) // never the case for 'expand'
        query._main.elements = elemsParent.elements;
    }

    for (const col of columns || [ { val: '*' } ]) {
      if (col.val === '*') {
        const siblings = wildcardSiblings( columns, query );
        expandWildcard( col, siblings, inlineHead, query );
      }
      // If neither expression (value), expand nor new association.
      if (!col.value && !col.expand && !(col.target && col.type))
        continue;             // error should have been reported by parser
      if (col.inline) {
        col.kind = '$inline';
        col.name = {};
        // a name for this internal symtab entry (e.g. '.2' to avoid clashes
        // with real elements) is only relevant for for `cdsc -R`/debugging
        const q = userQuery( query );
        q.$inlines.push( col );
        // or use userQuery( query ) in the following, too?
        setMemberParent( col, `.${ q.$inlines.length }`, query );
        initFromColumns( query, col.inline, col );
      }
      else if (!col.$replacement) {
        const id = ensureColumnName( col, query );
        col.kind = 'element';
        dictAdd( elemsParent.elements, id, col, ( name, location ) => {
          error( 'duplicate-definition', [ location, query ], { name, '#': 'element' } );
        });
        setMemberParent( col, id, query );
      }
    }
    forEachGeneric( query, 'elements', e => initElem( e, query ) );
    return true;
  }

  // TODO: probably do this already in definer.js
  function ensureColumnName( col, query ) {
    if (col.name)
      return col.name.id;
    if (col.inline || col.val === '*')
      return '';
    const path = col.value &&
        (col.value.path || !col.value.args && col.value.func && col.value.func.path);
    if (path && path.length) {
      const last = !path.broken && path.length && path[path.length - 1];
      if (last) {
        col.name = { id: last.id || '', location: last.location, $inferred: 'as' };
        return col.name.id;
      }
    }
    else if (col.value || col.expand) {
      error( 'query-req-name', [ col.value && col.value.location || col.location, query ], {},
             'Alias name is required for this select item' );
    }
    // invent a name for code completion in expression
    col.name = {
      id: '',
      location: col.value && col.value.location || col.location,
      $inferred: 'none',
    };
    return '';
  }

  function initElem( elem, query ) {
    if (elem.type && !elem.type.$inferred)
      return;                 // explicit type -> enough or directType()
    if (elem.$inferred) {
      // redirectImplicitly( elem, elem._origin );
      return;
    }
    if (!elem.value || !elem.value.path) // TODO: test $inferred
      return;                 // no value ref or $inferred
    // TODO: what about SELECT from E { $projection.a as a1, a } !!!!!!

    const env = columnEnv( elem._pathHead, query );
    const origin = setLink( elem, '_origin',
                            resolvePath( elem.value, 'expr', elem, env ) );
    // console.log( message( null, elem.location, elem, {art:query}, 'Info','RED').toString(),
    //              elem.value)
    // TODO: make this resolvePath() also part of directType() ?!
    if (!origin || elem.expand)
      return;
    // TODO: or should we push elems with `expand` sibling to extra list for better messages?
    if (elem.foreignKeys) {   // REDIRECTED with explicit foreign keys
      forEachGeneric( elem, 'foreignKeys', (key, name) => initKey( key, name, elem ) );
    }

    // now set things which are necessary for later sub phases:
    const nav = pathNavigation( elem.value );
    const item = elem.value.path[elem.value.path.length - 1];
    if (nav.navigation && nav.item === item) {
      // sourceElem, alias.sourceElem, mixin:
      // redirectImplicitly( elem, origin );
      pushLink( nav.navigation, '_projections', elem );
    }
    else if (elem._pathHead?.kind === '$inline' && elem.value.path.length === 1) {
      const hpath = elem._pathHead.value?.path;
      const head = hpath?.length === 1 && hpath[0]._navigation;
      // Alias .{ elem } - but not with Alias.{ $magic }: consider for ON-rewrite
      if (head?.kind === '$tableAlias' && item.id.charAt(0) !== '$')
        pushLink( head.elements[item.id], '_projections', elem );
    }
  }

  function initKey( key, name, elem ) {
    setLink( key, '_block', elem._block );
    setMemberParent( key, name, elem ); // TODO: set _block here if not present?
  }

  // col ($replacement set before *)
  // false if two cols have same name
  function wildcardSiblings( columns, query ) {
    const siblings = Object.create(null);
    if (!columns)
      return siblings;

    let seenWildcard = null;
    for (const col of columns) {
      const id = ensureColumnName( col, query );
      if (id) {
        col.$replacement = !seenWildcard;
        siblings[id] = !(id in siblings) && col;
      }
      else if (col.val === '*') {
        seenWildcard = true;
      }
    }
    return siblings;
  }

  // TODO: disallow $self.elem.* and $self.*, toSelf.* (circular dependency)
  function expandWildcard( wildcard, siblingElements, colParent, query ) {
    const { elements } = query.items || query;
    let location = wildcard.location || query.from && query.from.location || query.location;
    const inferred = query._main.$inferred;
    const excludingDict = (colParent || query).excludingDict || Object.create(null);

    const envParent = wildcard._pathHead; // TODO: rename _pathHead to _pathEnv
    // console.log('S1:',location.line,location.col,
    //             envParent&&!!envParent._origin&&envParent._origin.name)
    const env = columnEnv( envParent, query );
    // console.log('S2:',location.line,location.col,
    //             envParent&&!!envParent._origin&&envParent._origin.name,
    //             Object.keys(env),Object.keys(elements))
    for (const name in env) {
      const navElem = env[name];
      // TODO: remove all access to masked (use 'grep')
      if (excludingDict[name] || navElem.masked && navElem.masked.val)
        continue;
      const sibling = siblingElements[name];
      if (sibling) {          // is explicitly provided (without duplicate)
        if (!inferred && !envParent) // not yet for expand/inline
          reportReplacement( sibling, navElem, query );
        if (!sibling.$replacement) {
          sibling.$replacement = true;
          sibling.kind = 'element';
          dictAdd( elements, name, sibling, ( _name, loc ) => {
            // there can be a definition from a previous inline with the same name:
            error( 'duplicate-definition', [ loc, query ], { name, '#': 'element' } );
          });
          setMemberParent( sibling, name, query );
        }
        // else {
        //   sibling.$inferred = 'query';
        // }
      }
      else if (Array.isArray(navElem)) {
        const names = navElem.filter( e => !e.$duplicates)
          .map( e => `${ e.name.alias }.${ e.name.element }` );
        if (names.length) {
          error( 'wildcard-ambiguous', [ location, query ], { id: name, names },
                 'Ambiguous wildcard, select $(ID) explicitly with $(NAMES)' );
        }
      }
      else {
        location = weakLocation( location );
        const origin = envParent ? navElem : navElem._origin;
        const elem = linkToOrigin( origin, name, query, null, location );
        // TODO: check assocToMany { * }
        dictAdd( elements, name, elem, ( _name, loc ) => {
          // there can be a definition from a previous inline with the same name:
          error( 'duplicate-definition', [ loc, query ], { name, '#': 'element' } );
        });
        elem.$inferred = '*';
        elem.name.$inferred = '*';
        if (envParent)
          setWildcardExpandInline( elem, envParent, origin, name, location );
        else
          setElementOrigin( elem, navElem, name, location );
      }
    }
    if (envParent || query.kind !== 'select') {
      // already done in populateQuery (TODO: change that and check whether
      // `*` is allowed at all in definer)
      const user = colParent || query;
      for (const name in user.excludingDict)
        resolveExcluding( name, env, excludingDict, query );
    }
  }

  function columnEnv( envParent, query ) { // etc.  wildcard._pathHead;
    return (envParent)
      ? environment( directType( envParent ) || envParent )
      : userQuery( query )._combined;
  }

  function reportReplacement( sibling, navElem, query ) {
    // TODO: bring this much less often = only if shadowed elem does not appear
    // in expr and if not projected as other name.
    // Probably needs to be reported at a later phase
    const path = sibling.value && sibling.value.path;
    if (!sibling.target || sibling.target.$inferred || // not explicit REDIRECTED TO
        path && path[path.length - 1].id !== sibling.name.id) { // or renamed
      const { id } = sibling.name;
      if (Array.isArray(navElem)) {
        // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
        info( 'wildcard-excluding-many', [ sibling.name.location, query ], { id },
          // eslint-disable-next-line max-len
              'This select item replaces $(ID) from two or more sources. Add $(ID) to $(KEYWORD) to silence this message' );
      }
      else {
        // ID published! Used in stakeholder project; if renamed, add to oldMessageIds
        info( 'wildcard-excluding-one', [ sibling.name.location, query ],
              { id, alias: navElem._parent.name.id, keyword: 'excluding' },
          // eslint-disable-next-line max-len
              'This select item replaces $(ID) from table alias $(ALIAS). Add $(ID) to $(KEYWORD) to silence this message' );
      }
    }
  }

  function setWildcardExpandInline( queryElem, pathHead, origin, name, location ) {
    setLink( queryElem, '_pathHead', pathHead );
    const path = [ { id: name, location } ];
    queryElem.value = { path, location }; // TODO: can we omit that?  We have _origin
    setArtifactLink( path[0], origin );
    setLink( queryElem, '_origin', origin );
    // set _projections when inline with table alias:
    const alias = pathHead?.value?.path?.[0]?._navigation;
    if (alias?.kind === '$tableAlias')
      pushLink( alias.elements[name], '_projections', queryElem );
  }

  // called by expandWildcard():
  function setElementOrigin( queryElem, navElem, name, location ) {
    const sourceElem = navElem._origin;
    const alias = navElem._parent;
    // always expand * to path with table alias (reason: columns current_date etc)
    const path = [ { id: alias.name.id, location }, { id: name, location } ];
    queryElem.value = { path, location };
    setLink( path[0], '_navigation', alias );
    setArtifactLink( path[0], alias._origin );
    setArtifactLink( path[1], sourceElem );
    // TODO: or should we set the _artifact/_effectiveType directly to the target?
    setArtifactLink( queryElem.value, sourceElem );
    pushLink( navElem, '_projections', queryElem );
    // TODO: _effectiveType?
  }

  //--------------------------------------------------------------------------
  // Auto-Redirections
  //--------------------------------------------------------------------------

  // Conditions for redirecting target of assoc in elem
  // - we (the elem) are in a service
  // - target provided in assoc is not defined in current service
  // - elem is to be auto-redirected (included elem, elem from main query, ...)
  // - assoc is not defined in current service (or was not to be auto-redirected)
  function redirectImplicitly( elem, assoc ) {
    // PRE: elem has no target, assoc has target prop
    if (elem.kind === '$tableAlias')
      return false;
    const assocTarget = resolvePath( assoc.target, 'target', assoc );
    let target = assocTarget;
    // console.log( info( null, [ elem.location, elem ], {target,art:assoc,name:''+assoc.target},
    //              'RED').toString())
    if (!target)
      return false;             // error in target ref
    const { location } = elem.value || elem.type || elem.name;
    const service = (elem._main || elem)._service;
    if (service && service !== target._service && assocIsToBeRedirected( elem )) {
      if (service !== (assoc._main || assoc)._service ||
          !assocIsToBeRedirected( assoc ) ||
          elem === assoc)
        target = redirectImplicitlyDo( elem, assoc, target, service );
    }
    if (elem === assoc) {    // redirection of user-provided target
      if (assocTarget === target) // no change (due to no implicit redirection)
        return true;
      const type = resolvePath( elem.type, 'type', elem ); // cds.Association or cds.Composition
      const origin = {
        kind: elem.kind, // necessary for rewrite, '$user-provided' would be best
        name: elem.name,
        type: {                 // TODO: necessary?
          path: [ { id: type.name.absolute, location: elem.type.location } ],
          scope: 'global',
          location: elem.type.location,
          $inferred: 'REDIRECTED',
        },
        target: elem.target,
        $inferred: 'REDIRECTED',
        location: elem.target.location,
      };
      setLink( elem, '_origin', origin );
      setArtifactLink( elem.type, type );
      setLink( origin, '_outer', elem );
      setLink( origin, '_parent', elem._parent );
      if (elem._main)           // remark: the param `elem` can also be a type
        setLink( origin, '_main', elem._main );
      setLink( origin, '_effectiveType', origin );
      setLink( origin, '_block', elem._block );
      if (elem.foreignKeys) {
        origin.foreignKeys = elem.foreignKeys;
        delete elem.foreignKeys; // will be rewritten
      }
      if (elem.on) {
        origin.on = elem.on;
        delete elem.on;         // will be rewritten
      }
    }
    if (target !== assocTarget)
      setExpandStatus( elem, 'target' ); // (might) also set in rewriteCondition
    elem.target = {
      path: [ { id: target.name.absolute, location } ],
      scope: 'global',
      location,
      $inferred: (target !== assocTarget ? 'IMPLICIT' : 'rewrite' ),
    };
    setArtifactLink( elem.target, target );
    setArtifactLink( elem.target.path[0], target );
    return true;
  }

  function assocIsToBeRedirected( assoc ) {
    if (assoc.kind === 'mixin')
      return false;
    const query = userQuery( assoc );
    return redirectInSubQueries || !query || query._main._leadingQuery === query;
  }

  function redirectImplicitlyDo( elem, assoc, target, service ) {
    // console.log('ES:',elem.name.absolute,elem.name.element);
    const elemScope = scopedRedirections && // null if no scoped redirections
          preferredElemScope( target, service, elem, assoc._main || assoc );
    const exposed = minimalExposure( target, service, elemScope );

    if (!exposed.length) {
      const origTarget = target;
      if (isAutoExposed( target ))
        target = createAutoExposed( origTarget, service, elemScope );
      const desc = origTarget._descendants ||
            setLink( origTarget, '_descendants', Object.create(null) );
      if (!desc[service.name.absolute]) // could be the target itself (no repeated msgs)!
        desc[service.name.absolute] = [ target ];
      else
        desc[service.name.absolute].push( target );
    }
    else if (exposed.length === 1) {
      return exposed[0];
    }
    else if (elem === assoc) {
      // `assoc: Association to ModelEntity`: user-provided target is to be auto-redirected
      warning( 'type-ambiguous-target',
               [ elem.target.location, elem ],
               {
                 target,
                 // art: definitionScope( target ), - TODO extra debug info in message
                 sorted_arts: exposed,
               }, {
                 // eslint-disable-next-line max-len
                 std: 'Replace target $(TARGET) by one of $(SORTED_ARTS); can\'t auto-redirect this association if multiple projections exist in this service',
                 // eslint-disable-next-line max-len
                 two: 'Replace target $(TARGET) by $(SORTED_ARTS) or $(SECOND); can\'t auto-redirect this association if multiple projections exist in this service',
               });
      // continuation semantics: no auto-redirection
    }
    else {
      // referred (and probably inferred) assoc (without a user-provided target at that place)
      // HINT: consider bin/cdsv2m.js when changing the following message text
      // No grouped and sub messages yet (TODO v3): mention at all target places with all assocs
      const withAnno = annotationVal( exposed[0]['@cds.redirection.target'] );
      for (const proj of exposed) {
        // TODO: def-ambiguous-target (just v3, as the current is infamous and used in options),
        message( 'redirected-implicitly-ambiguous',
                 [ weakLocation( proj.name.location ), proj ],
                 {
                   '#': withAnno && 'justOne',
                   target,
                   art: elem,
                   // art: definitionScope( target ), - TODO extra debug info in message
                   anno: 'cds.redirection.target',
                   sorted_arts: exposed,
                 }, {
                   // eslint-disable-next-line max-len
                   std: 'Add $(ANNO) to one of $(SORTED_ARTS) to select the entity as redirection target for $(TARGET) in this service; can\'t auto-redirect $(ART) otherwise',
                   // eslint-disable-next-line max-len
                   two: 'Add $(ANNO) to either $(SORTED_ARTS) or $(SECOND) to select the entity as redirection target for $(TARGET) in this service; can\'t auto-redirect $(ART) otherwise',
                   // eslint-disable-next-line max-len
                   justOne: 'Remove $(ANNO) from all but one of $(SORTED_ARTS) to have a unique redirection target for $(TARGET) in this service; can\'t auto-redirect $(ART) otherwise',
                 } );
      }
      // continuation semantics: no implicit redirections
    }
    return target;
  }

  // Return projections of `target` in `service`.  Shorted by
  // - first, only consider projections with @cds.redirection.target=true
  // - exclude all indirect projections, i.e. those which are projection on others in list
  //
  // To avoid repeated messages: if already tried to do autoexposure, return
  // autoexposed entity when successful, or `target` otherwise (no/failed autoexposure)
  function minimalExposure( target, service, elemScope ) {
    const descendants = scopedExposure( target._descendants &&
                                        target._descendants[service.name.absolute] ||
                                        [],
                                        elemScope, target );
    const preferred = descendants.filter( d => annotationVal( d['@cds.redirection.target'] ) );
    const exposed = preferred.length ? preferred : descendants;
    if (exposed.length < 2)
      return exposed || [];
    let min = null;
    for (const e of exposed) {
      if (!min || min._ancestors && min._ancestors.includes(e)) {
        min = e;
      }
      else if (!e._ancestors || !e._ancestors.includes( min )) {
        if (elemScope === '')
          return [];
        return exposed;
      }
    }
    return [ min ];
  }

  // Scoped redirections -----------------------------------------------------


  function preferredElemScope( target, service, elem, assocMain ) {
    const assocScope = definitionScope( assocMain );
    const targetScope = definitionScope( target );
    if (targetScope === assocScope) { // intra-scope in model
      const elemScope = definitionScope( elem._main || elem );
      // without the if, compile.recompile.json versus expected csn.json in
      // test3/Redirections/AutoExposeDeepScoped would fail
      if (targetScope === target ||  // model target is scope root
          assocScope === assocMain || // unscoped assoc source in model
          elemScope !== (elem._main || elem)) // scoped assoc source in service
        return elemScope;         // own scope, then global
    }
    if (targetScope === target)  // unscoped target in model / other service
      return false;              // all (there could be no scoped autoexposed)
    // scoped target in model:
    const exposed = minimalExposure( targetScope, service, false );
    // console.log('PES:',elem.name.absolute,elem.name.element,exposed.map(e=>e.name.absolute))
    if (exposed.length === 1)   // unique redirection for target scope: use that
      return exposed[0];
    // TODO: warning if exposed.length >= 2?  Probably not
    // TODO: use excessive testing for the following
    // Now re-scope according to naming of auto-exposed entity:
    const autoScopeName = autoExposedName( targetScope, service, false );
    const autoScope = model.definitions[autoScopeName];
    // console.log('AEN:',autoScopeName,autoScope&&(autoScope.$inferred || autoScope.kind))
    if (autoScope)
      return autoScope;
    const { location } = service.name;
    const nullScope = {
      kind: 'namespace', name: { absolute: autoScopeName, location }, location,
    };
    model.definitions[autoScopeName] = nullScope;
    initArtifact( nullScope );
    return nullScope;
  }

  function scopedExposure( descendants, elemScope, target ) {
    if (!elemScope)             // no scoped redirections
      return descendants;
    // try scope as target first, even if it has @cds.redirection.target: false
    if (isDirectProjection( elemScope, target ))
      return [ elemScope ];
    const scoped = descendants.filter( d => elemScope === definitionScope( d ) );
    if (scoped.length)          // use scoped new targets if present
      return scoped;
    // otherwise return new targets outside any scope
    return descendants.filter( d => d === definitionScope( d ) );
  }

  // Return the scope of a definition.  It is the last parent of the definition
  // which is not a context/service/namespace, or the definition itself.
  // If inside service, it is the direct child of the (most inner) service.
  function definitionScope( art ) {
    let base = art;
    while (art._parent) {
      if (art._parent.kind === 'service')
        return art;
      art = art._parent;
      if (!kindProperties[art.kind].artifacts)
        base = art;
    }
    return base;
  }

  function isDirectProjection( proj, base ) {
    return proj.kind === 'entity' && // not event
      // direct proj (TODO: or should we add them to another list?)
      proj.query && proj.query.op && proj.query.op.val === 'SELECT' &&
      proj._from && proj._from.length === 1 &&
      base === resolvePath( proj._from[0], 'from', proj );
  }

  // Auto-exposure -----------------------------------------------------------

  // TODO: do something in kick-start.js ?
  function isAutoExposed( target ) {
    if (target.$autoexpose !== undefined)
      return target.$autoexpose;
    const origTarget = target;
    const chain = [];
    let source = target._from && resolvePath( target._from[0], 'from', target );
    // query source ref might not have been resolved yet, cycle avoided as
    // setAutoExposed() sets $autoexpose and a second call on same art would
    // return false
    while (target.$autoexpose === undefined && setAutoExposed( target ) && source) {
      // stop at first ancestor with annotation or at non-query entity
      chain.push( target );
      target = source;
      source = target._from && resolvePath( target._from[0], 'from', target );
    }
    const autoexpose = target.$autoexpose;
    if (typeof autoexpose === 'boolean') {
      for (const a of chain)
        a.$autoexpose = autoexpose;
    }
    return origTarget.$autoexpose;
  }

  // TODO: less auto-exposed for compositions (see lengthy discussions)
  function setAutoExposed( art ) {
    const anno = art['@cds.autoexpose'];
    if (anno && anno.val !== null) { // XSN TODO: set val, but no location for anno short form
      // @cds.autoexpose:true or @cds.autoexpose:false
      art.$autoexpose = anno.val === undefined || !!anno.val;
      return false;
    }
    // no @cds.autoexpose or @cds.autoexpose:null
    // TODO: introduce deprecated._noInheritedAutoexposeViaComposition
    art.$autoexpose = model.$compositionTargets[art.name.absolute]
      ? autoexposeViaComposition
      : null;
    return true;                // still check for inherited @cds.autoexpose
  }

  function autoExposedName( target, service, elemScope ) {
    const { absolute } = target.name;
    if (isDeprecatedEnabled( options, '_shortAutoexposed' )) {
      const parent = definitionScope( target )._parent;
      const name = (parent) ? absolute.substring( parent.name.absolute.length + 1 ) : absolute;
      // no need for dedot here (as opposed to deprecated._longAutoexposed), as
      // the name for dependent entities have already been created using `_` then
      return `${ service.name.absolute }.${ name }`;
    }
    if (isDeprecatedEnabled( options, '_longAutoexposed' ))
      return `${ service.name.absolute }.${ absolute }`;
    const base = definitionScope( target );
    if (base === target)
      return `${ service.name.absolute }.${ absolute.substring( absolute.lastIndexOf('.') + 1 ) }`;
    // for scoped (e.g. calculated) entities, use exposed name of base:
    const exposed = minimalExposure( base, service, elemScope );
    // console.log(exposed.map( a => a.name.absolute ));
    const sbasename = (exposed.length === 1 && exposed[0] !== base) // same with no/failed expose
      ? exposed[0].name.absolute
      : autoExposedName( base, service, elemScope );
    return sbasename + absolute.slice( base.name.absolute.length );
  }


  function createAutoExposed( target, service, elemScope ) {
    const absolute = autoExposedName( target, service, elemScope );
    const autoexposed = model.definitions[absolute];
    if (autoexposed && (autoexposed.kind !== 'namespace' || !scopedRedirections)) {
      if (isDirectProjection( autoexposed, target )) {
        const anno = autoexposed['@cds.redirection.target'];
        if (annotationIsFalse( anno )) {
          // It would probably be cleaner to ignore a dubious
          // `@cds.redirection.target: false` earlier, but that is not easy to detect
          // due to the name of the autoexposed entity with scoped redirections
          if (!anno.$errorReported) {
            info( 'anno-redirecting-anyway',
                  [ annotationLocation( anno ), autoexposed ],
                  { target, art: absolute, code: '@cds.redirection.target: false' },
                  '$(TARGET) is auto-redirected to $(ART) even with $(CODE)' );
            anno.$errorReported = 'anno-redirecting-anyway';
          }
        }
        else if (autoexposed._parent === service ||
                 !annotationVal( autoexposed['@cds.autoexposed'] )) {
          // existing def not auto-exposed, or un-scoped auto-exposed: should not happen
          if (options.testMode)
            throw new CompilerAssertion( `Tried to auto-expose ${ target.name.absolute } twice`);
        }
        return autoexposed;
      }
      error( 'duplicate-autoexposed', [ service.name.location, service ],
             { target, art: absolute },
             'Name $(ART) of autoexposed entity for $(TARGET) collides with other definition' );
      info( null, [ target.name.location, target ],
            { art: service },
            'Expose this (or the competing) entity explicitly in service $(ART)' );
      if (autoexposed.$inferred !== 'autoexposed')
        return target;
      const firstTarget = autoexposed.query.from._artifact;
      error( 'duplicate-autoexposed', [ service.name.location, service ],
             { target: firstTarget, art: absolute },
             'Name $(ART) of autoexposed entity for $(TARGET) collides with other definition' );
      info( null, [ firstTarget.name.location, firstTarget ],
            { art: service },
            'Expose this (or the competing) entity explicitly in service $(ART)' );
      autoexposed.$inferred = 'duplicate-autoexposed';
      return target;
    }
    // console.log(absolute)
    const { location } = target.name;
    const from = augmentPath( location, target.name.absolute );
    let art = {
      kind: 'entity',
      name: { location, path: splitIntoPath( location, absolute ), absolute },
      location: target.location,
      query: { location, op: { val: 'SELECT', location }, from },
      $syntax: 'projection',
      $inferred: 'autoexposed',
      '@cds.autoexposed': {
        name: { path: [ { id: 'cds.autoexposed', location } ], location },
        $inferred: '$generated',
      },
    };
    // TODO: do we need to tag the generated entity with elemScope = 'auto'?
    if (autoexposed) {
      Object.assign( autoexposed, art );
      art = autoexposed;
    }
    else {
      model.definitions[absolute] = art;
    }
    setLink( art, '_service', service );
    setLink( art, '_block', model.$internal );
    initArtifact( art, !!autoexposed );
    // populate view (phase 2 of resolver has to be repeated as the view was created afterwards)
    populateView( art );
    // TODO: try to set locations of elements locations of orig target elements
    newAutoExposed.push( art );
    return art;
  }
}

// Return condensed info about reference in select item
// - tableAlias.elem       -> { navigation: navElem, item: path[1], tableAlias }
// - sourceElem (in query) -> { navigation: navElem, item: path[0], tableAlias }
// - mixinElem             -> { navigation: mixinElement, item: path[0] }
// - $projection.elem      -> also $self.item -> { item: path[1], tableAlias: $self }
// - $self                 -> { item: undefined, tableAlias: $self }
// - $parameters.P, :P     -> {}
// - $now, current_date    -> {}
// - undef, redef          -> {}
// With 'navigation': store that navigation._artifact is projected
// With 'navigation': rewrite its ON condition
// With navigation: Do KEY propagation
//
// TODO: copy of fn in resolve.js; used just once here - do it differently here
// and then delete the function here
function pathNavigation( ref ) {
  // currently, indirectly projectable elements are not included - we might
  // keep it this way!  If we want them to be included - be aware: cycles
  if (!ref._artifact)
    return {};
  let item = ref.path && ref.path[0];
  const root = item && item._navigation;
  if (!root)
    return {};
  if (root.kind === '$navElement')
    return { navigation: root, item, tableAlias: root._parent };
  if (root.kind === 'mixin')
    return { navigation: root, item };
  item = ref.path[1];
  if (root.kind === '$self')
    return { item, tableAlias: root };
  if (root.kind !== '$tableAlias' || ref.path.length < 2)
    return {};                // should not happen
  return { navigation: root.elements[item.id], item, tableAlias: root };
}

module.exports = populate;
