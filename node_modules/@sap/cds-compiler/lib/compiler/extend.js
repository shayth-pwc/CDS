// Extend, include, localized data and managed compositions

// Is handled together in this file because people want to extend the generated
// definitions in the future.

'use strict';

const { searchName, weakLocation } = require('../base/messages');
const {
  isDeprecatedEnabled,
  forEachGeneric, forEachInOrder, forEachDefinition,
} = require('../base/model');
const { dictAdd } = require('../base/dictionaries');
const { kindProperties, dictKinds } = require('./base');
const {
  setLink,
  setArtifactLink,
  annotateWith,
  linkToOrigin,
  setMemberParent,
  dependsOnSilent,
  augmentPath,
  splitIntoPath,
} = require('./utils');
const layers = require('./moduleLayers');
const { typeParameters } = require('./builtins');

function extend( model ) {
  const { options } = model;
  // Get simplified "resolve" functionality and the message function:
  const {
    message, error, warning, info,
  } = model.$messageFunctions;
  const {
    resolvePath,
    resolveUncheckedPath,
    checkAnnotate,
    initAnnotations,
    copyAnnotationsForExtensions,
    attachAndEmitValidNames,
    checkDefinitions,
    initArtifact,
    initMembers,
    extensionsDict,             // not a function - TODO
  } = model.$functions;

  Object.assign( model.$functions, {
    lateExtensions,
    layeredAssignments,
    assignmentsOfHighestLayers,
    applyTypeExtensions,
  } );

  applyExtensions();

  const addTextsLanguageAssoc = checkTextsLanguageAssocOption(model, options);

  Object.keys( model.definitions ).forEach( processArtifact );

  lateExtensions( false );

  compositionChildPersistence();

  /**
   * Process "composition of" artifacts.
   *
   * @param {string} name
   */
  function processArtifact( name ) {
    const art = model.definitions[name];
    if (!(art.$duplicates)) {
      processAspectComposition( art );
      if (art.kind === 'entity' && !art.query && art.elements)
        // check potential entity parse error
        processLocalizedData( art );
    }
  }

  /**
   * Propagate the given `prop` (e.g. annotation) early, i.e. copy it from all `.includes`
   * if they have the property.
   *
   * @param {XSN.Definition} art
   * @param {string} prop
   */
  function propagateEarly( art, prop ) {
    if (art[prop])
      return;
    for (const ref of art.includes) {
      const aspect = ref._artifact;
      if (aspect) {
        const anno = aspect[prop];
        if (anno && (anno.val !== null || !art[prop]))
          art[prop] = Object.assign( { $inferred: 'include' }, anno );
      }
    }
  }

  /**
   * Copy `@cds.persistence.skip` and `@cds.persistence.skip` from parent to child
   * for managed compositions.  This needs to be done after extensions, i.e. annotations,
   * have been applied or `annotate E.comp` would not have an effect on `E.comp.subComp`.
   */
  function compositionChildPersistence() {
    const processed = new WeakSet();
    forEachDefinition(model, processCompositionPersistence);

    function processCompositionPersistence( def ) {
      if (def.$inferred === 'composition-entity' && !processed.has(def)) {
        if (def._parent)
          processCompositionPersistence(def._parent);
        copyPersistenceAnnotations(def, def._parent, options);
        processed.add(def);
      }
    }
  }

  // extend ------------------------------------------------------------------

  /**
   * Apply the extensions inside the extensionsDict on the model.
   *
   * Phase 1: context extends, 2: extends with structure includes, 3: extends
   * without structure includes (in the case of cyclic includes)
   *
   * Before phase 1: all artifact extensions have been collected (even those
   * inside extend context), only "empty" ones from structure includes are still unknown.
   * After phase 1, all main artifacts are known, also "empty" extensions are known.
   */
  function applyExtensions() {
    let phase = 1;              // TODO: basically remove phase 1
    let extNames = Object.keys( extensionsDict ).sort();
    // Remark: The sort() makes sure that an extend for artifact C.E is applied
    // after the extend for C has been applied (which could have defined C.E).
    // Looping over model.definitions in Phase 1 would miss the `extend
    // context` for a context C.C defined in an `extend context C`.
    //
    // TODO: no need to sort anymore
    while (extNames.length) {
      const { length } = extNames;
      for (const name of extNames) {
        const art = model.definitions[name];
        if (!art || art.kind === 'namespace') {
          model.$lateExtensions[name] = extensionsDict[name];
          delete extensionsDict[name];
        }
        else if (art.$duplicates) { // cannot extend redefinitions
          delete extensionsDict[name];
        }
        else if (phase === 1
                 ? extendContext( name, art )
                 : extendArtifact( extensionsDict[name], art, phase > 2 )) { // >2: no self-include
          delete extensionsDict[name];
        }
      }
      extNames = Object.keys( extensionsDict ); // no sort() required anymore
      if (phase === 1)
        phase = 2;
      else if (extNames.length >= length)
        phase = 3;
    }
  }

  function extendContext( name, art ) {
    // TODO: remove this function - add remains to define.js
    // (ext.expectedKind == art.kind) already checked by parser except for context/service
    if (!kindProperties[art.kind].artifacts) {
      // no context or service => warn about context extensions
      for (const ext of extensionsDict[name]) {
        if (ext.expectedKind === 'context' || ext.expectedKind === 'service') {
          const loc = ext.name.location;
          // TODO: warning is enough
          error( 'extend-with-artifacts', [ loc, ext ], { name, '#': ext.expectedKind, keyword: `EXTEND ${ ext.expectedKind }` }, {
            std: 'Can\'t extend non-context / non-service $(NAME) with $(KEYWORD)',
            service: 'Can\'t extend non-service $(NAME) with $(KEYWORD)',
            context: 'Can\'t extend non-context $(NAME) with $(KEYWORD)',
          });
        }
      }
      return false;
    }

    for (const ext of extensionsDict[name]) {
      setArtifactLink( ext.name, art );
      checkDefinitions( ext, art, 'elements'); // error for elements etc
      checkDefinitions( ext, art, 'enum');
      checkDefinitions( ext, art, 'actions');
      checkDefinitions( ext, art, 'params');
      checkDefinitions( ext, art, 'columns');
      if (ext.includes)
        applyIncludes( ext, art ); // emits error if `includes` is set
      checkAnnotate( ext, art );
      copyAnnotationsForExtensions( ext, art );
    }
    return true;
  }

  /**
   * Extend artifact `art` by `extensions`.  `noIncludes` can have values:
   * - false: includes are applied, extend and annotate is performed
   * - true:  includes are not applied, extend and annotate is performed
   * - 'gen': no includes and no extensions allowed, annotate is performed
   *
   * @param {XSN.Extension[]} extensions
   * @param {XSN.Definition} art
   * @param {boolean|'gen'} [noIncludes=false]
   */
  function extendArtifact( extensions, art, noIncludes = false ) {
    if (!noIncludes && !(canApplyIncludes( art, art ) &&
        extensions.every( ext => canApplyIncludes(ext, art) )))
      return false;
    if (!art.query) {
      model._entities.push( art ); // add structure with includes in dep order
      art.$entity = ++model.$entity;
    }
    if (!noIncludes && art.includes)
      applyIncludes( art, art );
    extendMembers( extensions, art, noIncludes === 'gen' );
    if (!noIncludes && art.includes) {
      // early propagation of specific annotation assignments
      propagateEarly( art, '@cds.autoexpose' );
      propagateEarly( art, '@fiori.draft.enabled' );
    }
    // TODO: complain about element extensions inside projection
    return true;
  }

  function extendMembers( extensions, art, noExtend ) {
    // TODO: do the whole extension stuff lazily if the elements are requested
    const elemExtensions = [];
    extensions.sort( layers.compareLayer );
    // TODO: use same sequence as in chooseAssignment() - better: use common code with that fn
    for (const ext of extensions) {
      // console.log(message( 'id', [ext.location, ext], { art: ext.name._artifact },
      //                      'Info', 'EXT').toString())
      if (!('_artifact' in ext.name)) { // not already applied
        setArtifactLink( ext.name, art );
        if (noExtend && ext.kind === 'extend') {
          error( 'extend-for-generated', [ ext.name.location, ext ], { art },
                 'You can\'t use EXTEND on the generated $(ART)' );
          continue;
        }
        if (ext.includes) {
          // TODO: currently, re-compiling from gensrc does not give the exact
          // element sequence - we need something like
          //    includes = ['Base1',3,'Base2']
          // where 3 means adding the next 3 elements before applying include 'Base2'
          if (art.includes)
            art.includes.push(...ext.includes);
          else
            art.includes = [ ...ext.includes ];
          applyIncludes( ext, art );
        }
        checkAnnotate( ext, art );
        initAnnotations( ext, ext._block, ext.kind ); // TODO: do in define.js
        copyAnnotationsForExtensions( ext, art );
        // TODO: do we allow to add elements with array of {...}?  If yes, adapt
        initMembers( ext, art, ext._block ); // might set _extend, _annotate
        storeTypeExtension( ext, art );
        dependsOnSilent(art, ext); // art depends silently on ext (inverse to normal dep!)
      }
      for (const name in ext.elements) {
        const elem = ext.elements[name];
        if (elem.kind === 'element') { // i.e. not extend or annotate
          elemExtensions.push( elem );
          break;                // more than one elem in same EXTEND is fine
        }
      }

      if (ext.columns)          // extend projection
        extendColumns( ext, art );
    }
    if (elemExtensions.length > 1)
      reportUnstableExtensions( elemExtensions );
    if (art._extendType && art._extendType.length > 0)
      reportTypeExtensionsInSameLayer( art._extendType );

    [ 'elements', 'actions' ].forEach( (prop) => {
      const dict = art._extend && art._extend[prop];
      for (const name in dict) {
        let obj = art;
        if (obj.targetAspect)
          obj = obj.targetAspect;
        while (obj.items)
          obj = obj.items;
        const validDict = obj[prop] || prop === 'elements' && obj.enum;
        const member = validDict && validDict[name];
        if (!member)
          extendNothing( dict[name], prop, name, art, validDict );
        else if (!(member.$duplicates))
          extendMembers( dict[name], member );
      }
    });
  }

  /**
   * Copy columns for EXTEND PROJECTION
   *
   * @param {XSN.Extension} ext
   * @param {XSN.Artifact} art
   */
  function extendColumns( ext, art ) {
    // TODO: consider reportUnstableExtensions

    const { location } = ext.name;
    const { query } = art;
    if (!query) {
      if (art.kind !== 'annotate')
        error( 'extend-columns', [ location, ext ], { art } );
      return;
    }
    if (!query.from || !query.from.path) {
      error( 'extend-columns', [ location, ext ], { art } );
    }
    else {
      if (!query.columns)
        query.columns = [ { location, val: '*' } ];

      for (const column of ext.columns) {
        setLink( column, '_block', ext._block );
        query.columns.push(column);
      }
    }
  }

  /**
   * Similar to chooseAssignment for annotations, this function applies type extensions in order,
   * such that hierarchies are respected.
   * Order already set in `extendMembers()` using `compareLayers()`.
   *
   * @param art
   */
  function applyTypeExtensions( art ) {
    /**
     * Contains the previous extension for each property that was applied
     * successfully.
     */
    const previousSuccess = Object.create(null);
    const allowedBuiltinCategories = [ 'string', 'decimal', 'integer', 'binary' ];
    const artType = art.type?._artifact;

    for (const ext of art._extendType) {
      if (art.$inferred) {
        // Only report first extension for $inferred artifact. Reduces noise.
        error('ref-expected-scalar-type', [ ext.name.location, ext ], { '#': 'inferred' } );
        break;
      }

      const baseType = art._effectiveType; // may be an ENUM
      if (!artType || (art.kind !== 'type' && art.kind !== 'element') || !baseType?.builtin) {
        // Only report first extension for non-scalar base type. Reduces noise.
        error('ref-expected-scalar-type', [ ext.name.location, ext ], { } );
        break;
      }
      else if (!allowedBuiltinCategories.includes(baseType.category)) {
        // Only report first extension for non-scalar type. Reduces noise.
        error('ref-expected-scalar-type', [ ext.name.location, ext ],
              { '#': 'unsupported', prop: baseType.category });
        continue;
      }

      for (const prop of typeParameters.list) {
        if (!ext[prop])
          continue;

        if (!baseType.parameters?.includes(prop)) {
          // For `extend T with type (length:10)` where T does not expect a length.
          error( 'type-unexpected-argument', [ ext[prop].location, ext ], {
            '#': 'type', prop, art, type: baseType,
          });
          break; // one error for first property is enough
        }
        else if (!art[prop]) {
          // Can only extend properties that exist directly on the artifact.
          error('ext-invalid-type-property', [ ext[prop].location, ext ],
                { prop, '#': 'new-prop' });
          break; // one error for first property is enough
        }
        else if (art[prop].val === ext[prop].val) {
          // Ignore extensions with same value
        }
        else if (art[prop].literal === 'string' || ext[prop].literal === 'string' ) {
          // Users can't change from/to string value for property,
          // e.g. `variable`/`floating` for Decimal
          error( 'ext-invalid-type-property', [ ext[prop].location, ext ],
                 { '#': 'string', prop } );
        }
        else if (art[prop].val > ext[prop].val) {
          // TODO: Future: Sub-message that points to previous extension?
          error( 'ext-invalid-type-property', [ ext[prop].location, ext ], {
            prop,
            value: ext[prop].val,
            number: art[prop].val,
            '#': previousSuccess[prop] ? 'ext-smaller' : 'smaller',
          } );
          break; // one error for first property is enough
        }
        else if (art[prop].val < ext[prop].val) {
          art[prop] = ext[prop];
          previousSuccess[prop] = ext;
        }
      }

      // If `scale` is increased, but `precision` is not, data may be lost in a migration.
      // e.g. `Decimal(4,2)` allows `12.34`. Increasing scale to 3 would make this value
      // invalid and only allow `1.234`.
      // TODO: Should we actually check that the increase is correct?
      if (ext.scale && !ext.precision) {
        error('ext-invalid-type-property', [ ext.scale.location, ext ], {
          prop: 'scale',
          otherprop: 'precision',
          '#': 'scale',
        });
      }
    }
  }

  /**
   * Report 'Warning: Unstable element order due to repeated extensions'
   * except if all extensions are in the same file.
   *
   * @param {XSN.Extension[]} extensions
   */
  function reportUnstableExtensions( extensions ) {
    // No message if all extensions are in the same file:
    const file = layers.realname( extensions[0] );
    if (extensions.every( ( ext, i ) => !i || file === layers.realname( ext ) ))
      return;
    // Similar to chooseAssignment(), TODO there: also extra intralayer message
    // as this is a modeling error
    let lastExt = null;
    let open = [];              // the "highest" layers
    for (const ext of extensions) {
      const extLayer = layers.layer( ext ) || { realname: '', _layerExtends: Object.create(null) };
      if (!open.length) {
        lastExt = ext;
        open = [ extLayer.realname ];
      }
      else if (extLayer.realname === open[open.length - 1]) { // in same layer
        if (lastExt) {
          message( 'extend-repeated-intralayer', [ lastExt.location, lastExt ] );
          lastExt = null;
        }
        message( 'extend-repeated-intralayer', [ ext.location, ext ] );
      }
      else {
        if (lastExt && (open.length > 1 || !extLayer._layerExtends[open[0]])) {
          // report for lastExt if that is unrelated to other open exts or current ext
          message( 'extend-unrelated-layer', [ lastExt.location, lastExt ], {},
                   'Unstable element order due to other extension in unrelated layer' );
        }
        lastExt = ext;
        open = open.filter( name => !extLayer._layerExtends[name] );
        open.push( extLayer.realname );
      }
    }
  }

  /**
   * Report type extensions in same layer, similar mechanism to chooseAssignment()
   * for annotations.
   *
   * @param {XSN.Extension[]} extensions
   */
  function reportTypeExtensionsInSameLayer( extensions ) {
    // Group assignments by layer
    const extLayers = layeredAssignments( extensions );
    // We only care about the highest layer
    const { assignments, issue } = assignmentsOfHighestLayers( extLayers );

    if (issue) {
      const id = (issue === 'unrelated')
        ? 'ext-duplicate-extend-type-unrelated-layer'
        : 'ext-duplicate-extend-type';
      for (const ext of assignments)
        message( id, [ ext.name.location, ext ], { type: ext.name._artifact } );
    }
  }

  /**
   * @param {XSN.Extension[]} extensions
   * @param {string} prop
   * @param {string} name
   * @param {XSN.Artifact} art
   * @param {object} validDict
   */
  function extendNothing( extensions, prop, name, art, validDict ) {
    const artName = searchName( art, name, dictKinds[prop] );
    for (const ext of extensions) {
      // TODO: use shared functionality with notFound in resolver.js
      const { location } = ext.name;
      const extName = { ...artName, kind: ext.kind };
      const msg
        = error( 'extend-undefined', [ location, extName ],
                 { art: artName },
                 {
                   std: 'Unknown $(ART) - nothing to extend',
                   // eslint-disable-next-line max-len
                   element: 'Artifact $(ART) has no element or enum $(MEMBER) - nothing to extend',
                   action: 'Artifact $(ART) has no action $(MEMBER) - nothing to extend',
                 } );
      attachAndEmitValidNames(msg, validDict);
    }
  }

  /**
   * @param {Function|false} [veryLate]
   */
  function lateExtensions( veryLate ) {
    for (const name in model.$lateExtensions) {
      const art = model.definitions[name];
      const exts = model.$lateExtensions[name];
      if (art && art.kind !== 'namespace') {
        if (art.builtin) {
          for (const ext of exts)
            info( 'anno-builtin', [ ext.name.location, ext ] );
        }
        // created texts entity, autoexposed entity
        if (exts) {
          extendArtifact( exts, art, 'gen' );
          if (veryLate)
            veryLate( art );
          model.$lateExtensions[name] = null; // done
        }
      }
      else if (veryLate) {
        // Complain about unused extensions, i.e. those
        // which do not point to a valid artifact
        for (const ext of exts) {
          delete ext.name.path[0]._artifact;      // get message for root
          // TODO: make resolvePath('extend'/'annotate') ignore namespaces
          // Don't try to apply annotations in the `localized.` namespace.
          // That's done in `localized.js`.
          if (!name.startsWith('localized.') &&
            resolvePath( ext.name, ext.kind, ext )) { // should issue error/info
            // should issue error for cds extensions (annotate ok)
            if (art.kind === 'namespace') {
              // TODO: Emit error if namespace is extended by non-definitions.
              info( 'anno-namespace', [ ext.name.location, ext ], {},
                    'Namespaces can\'t be annotated' );
            }
            // Builtin annotations would be represented as annotations in to-csn.js
            else if (art.builtin) {
              info( 'anno-builtin', [ ext.name.location, ext ] );
            }
          }
          // TODO: warning for context/service extension on non-correct
          if (ext.kind === 'annotate')
            delete ext.name._artifact; // make it be considered by extendArtifact()
        }
        // create "super" ANNOTATE containing all non-applied ones
        const first = exts[0];
        const { location } = first.name;

        /** @type {XSN.Definition} */
        const annotationArtifact = {
          kind: 'annotate',
          name: { path: [ { id: name, location } ], absolute: name, location },
          location: first.location,
        };

        if (!model.extensions)
          model.extensions = [];

        model.extensions.push(annotationArtifact);
        extendArtifact( exts, annotationArtifact ); // also sets _artifact link in extensions
        // if one of the annotate statement mentions 'returns', assume it
        // TODO: with warning/info?
        for (const ext of exts) {
          if (ext.$syntax === 'returns')
            annotationArtifact.$syntax = 'returns';
        }
      }
    }
  }

  // includes ----------------------------------------------------------------

  /**
   * Returns true, if `art.includes` can be applied on `target`.
   * They can't be applied if any of the artifacts referenced in
   * `art.includes` are yet to be extended.
   * `art !== target` if `art` is an extension.
   *
   * @param {XSN.Definition} art
   * @param {XSN.Artifact} target
   * @returns {boolean}
   */
  function canApplyIncludes( art, target ) {
    if (art.includes) {
      const isView = !!target.query;
      for (const ref of art.includes) {
        const template = resolvePath( ref, isView ? 'viewInclude' : 'include', art );
        if (template && template.name.absolute in extensionsDict)
          return false;
      }
    }
    return true;
  }

  /**
   * Apply all includes of `ext` on `ext`.  Checks that `art` allows includes.
   * If `ext === art`, then includes of the artifact itself are applied.
   * If `ext !== art`, applies includes on the extensions, not artifact.
   * Sets `_ancestor` links on `art`.
   *
   * Examples:
   *   ext === art:  `entity E : F {}`  => add elements of F to E
   *   ext !== art:  `extend E with F`  => add elements of F to extension on E
   *
   * @param {XSN.Extension} ext
   * @param {XSN.Artifact} art
   */
  function applyIncludes( ext, art ) {
    if (kindProperties[art.kind].include !== true) {
      error('extend-unexpected-include', [ ext.includes[0]?.location, ext ],
            { kind: art.kind });
      return;
    }

    if (!art.query) {
      if (!art._ancestors)
        setLink( art, '_ancestors', [] ); // recursive array of includes
      for (const ref of ext.includes) {
        const template = ref._artifact;
        // !template -> non-includable, e.g. scalar type, or cyclic
        if (template) {
          if (template._ancestors)
            art._ancestors.push( ...template._ancestors );
          art._ancestors.push( template );
        }
      }
    }
    includeMembers( ext, art, 'elements' );
    includeMembers( ext, art, 'actions' );
  }

  /**
   * Add all members (e.g. elements or actions) of `ext.includes` to `ext[prop]`
   * if `parent` is `false` or to `parent` with appropriate _origin links otherwise.
   * Included members are prepended to existing ones.
   *
   * @param {XSN.Extension} ext
   * @param {XSN.Artifact} art
   * @param {string} prop
   */
  function includeMembers( ext, art, prop ) {
    // TODO two kind of messages:
    // Error 'More than one include defines element "A"' (at include ref)
    // Warning 'Overwrites definition from include "I" (at elem def)
    const parent = ext === art && art;
    const members = ext[prop];
    ext[prop] = Object.create(null); // TODO: do not set actions property if there are none
    for (const ref of ext.includes) {
      const template = ref._artifact; // already resolved
      if (template) {           // be robust
        forEachInOrder( template, prop, ( origin, name ) => {
          if (members && name in members)
            return;               // TODO: warning for overwritten element
          const elem = linkToOrigin( origin, name, parent, prop, weakLocation( ref.location ) );
          if (!parent) // not yet set for EXTEND foo WITH bar => linkToOrigin() did not add it
            dictAdd( ext[prop], name, elem );
          elem.$inferred = 'include';
          if (origin.masked)
            elem.masked = Object.assign( { $inferred: 'include' }, origin.masked );
          if (origin.key)
            elem.key = Object.assign( { $inferred: 'include' }, origin.key );
          // TODO: also complain if elem is just defined in art
        });
      }
    }
    // TODO: expand elements having direct elements (if needed)
    if (members) {
      forEachInOrder( { [prop]: members }, prop, ( elem, name ) => {
        dictAdd( ext[prop], name, elem );
      });
    }
  }

  // localized texts entities

  /**
   * Process localized data for `art`.  This includes creating `.texts` entities
   * and `locale` associations.
   *
   * @param {XSN.Artifact} art
   */
  function processLocalizedData( art ) {
    const fioriAnno = art['@fiori.draft.enabled'];
    const fioriEnabled = fioriAnno && (fioriAnno.val === undefined || fioriAnno.val);

    const textsName = `${ art.name.absolute }.texts`;
    const textsEntity = model.definitions[textsName];
    const localized = localizedData( art, textsEntity, fioriEnabled );
    if (!localized)
      return;
    if (textsEntity)            // expanded localized data in source
      return;                   // -> make it idempotent
    const newTextsEntity = createTextsEntity( art, textsName, localized, fioriEnabled );
    addTextsAssociations( art, textsName, localized );
    copyPersistenceAnnotations(newTextsEntity, art, options);
  }

  /**
   * Returns `false`, if there is no localized data or an array of elements
   * that are required for `.texts` entities such as keys and localized elements.
   *
   * @param {XSN.Artifact} art
   * @param {XSN.Artifact|undefined} textsEntity
   * @param {boolean} fioriEnabled
   * @returns {false|XSN.Element[]}
   */
  function localizedData( art, textsEntity, fioriEnabled ) {
    let keys = 0;
    const textElems = [];
    const conflictingElements = [];
    const protectedElements = [ 'locale', 'texts', 'localized' ];
    if (fioriEnabled)
      protectedElements.push('ID_texts');
    if (addTextsLanguageAssoc)
      protectedElements.push('language');

    for (const name in art.elements) {
      const elem = art.elements[name];
      if (elem.$duplicates)
        return false;           // no localized-data unfold with redefined elems
      if (protectedElements.includes( name ))
        conflictingElements.push( elem );

      const isKey = elem.key && elem.key.val;
      const isLocalized = hasTruthyProp( elem, 'localized' );

      if (isKey) {
        keys += 1;
        textElems.push( elem );
      }
      else if (isLocalized) {
        textElems.push( elem );
      }

      if (isKey && isLocalized) { // key with localized is wrong - ignore localized
        const errpos = elem.localized || elem.type || elem.name;
        warning( 'def-ignoring-localized-key', [ errpos.location, elem ], { keyword: 'localized' },
                 'Keyword $(KEYWORD) is ignored for primary keys' );
      }
    }
    if (textElems.length <= keys)
      return false;

    if (!keys) {
      warning( 'def-expecting-key', [ art.name.location, art ], {},
               'No texts entity can be created when no key element exists' );
      return false;
    }

    if (textsEntity) {
      if (textsEntity.$duplicates)
        return false;
      if (textsEntity.kind !== 'entity' || textsEntity.query ||
          // already have elements "texts" and "localized" (and optionally ID_texts)
          conflictingElements.length !== 2 || art.elements.locale ||
          (fioriEnabled && art.elements.ID_texts)) {
        // TODO if we have too much time: check all elements of texts entity for safety
        warning( null, [ art.name.location, art ], { art: textsEntity },
                 // eslint-disable-next-line max-len
                 'Texts entity $(ART) can\'t be created as there is another definition with that name' );
        info( null, [ textsEntity.name.location, textsEntity ], { art },
              'Texts entity for $(ART) can\'t be created with this definition' );
      }
      else if (!art._block || art._block.$frontend !== 'json') {
        info( null, [ art.name.location, art ], {},
              'Localized data expansions has already been done' );
        return textElems;       // make double-compilation even with after toHana
      }
      else if (!art._block.$withLocalized && !options.$recompile) {
        art._block.$withLocalized = true;
        info( 'recalculated-text-entities', [ art.name.location, null ], {},
              'Input CSN contains expansions for localized data' );
        return textElems;       // make compilation idempotent
      }
      else {
        return textElems;
      }
    }
    for (const elem of conflictingElements) {
      warning( null, [ elem.name.location, art ], { name: elem.name.id },
               'No texts entity can be created when element $(NAME) exists' );
    }
    return !textsEntity && !conflictingElements.length && textElems;
  }

  /**
   * Create the `.texts` entity for the given base artifact.
   *
   * @param {XSN.Artifact} base
   * @param {string} absolute
   * @param {XSN.Element[]} textElems
   * @param {boolean} fioriEnabled
   */
  function createTextsEntity( base, absolute, textElems, fioriEnabled ) {
    const art = createTextsEntityWithDefaultElements( base, absolute, textElems, fioriEnabled );

    const { location } = base.name;
    const { locale } = art.elements;

    // assertUnique array value, first entry is 'locale'
    const assertUniqueValue = [ {
      path: [ { id: locale.name.id, location: locale.location } ],
      location: locale.location,
    } ];

    for (const orig of textElems) {
      const elem = linkToOrigin( orig, orig.name.id, art, 'elements' );
      if (orig.key && orig.key.val) {
        // elem.key = { val: fioriEnabled ? null : true, $inferred: 'localized', location };
        // TODO: the previous would be better, but currently not supported in toCDL
        if (!fioriEnabled) {
          elem.key = { val: true, $inferred: 'localized', location };
          // If the propagated elements remain key (that is not fiori.draft.enabled)
          // they should be omitted from OData containment EDM
          annotateWith( elem, '@odata.containment.ignore', location );
        }
        else {
          // add the former key paths to the unique constraint
          assertUniqueValue.push({
            path: [ { id: orig.name.id, location: orig.location } ],
            location: orig.location,
          });
        }
      }
      if (hasTruthyProp( orig, 'localized' )) { // use location of LOCALIZED keyword
        const localized = orig.localized || orig.type || orig.name;
        elem.localized = { val: null, $inferred: 'localized', location: localized.location };
      }
    }
    if (fioriEnabled)
      annotateWith( art, '@assert.unique.locale', art.location, assertUniqueValue, 'array' );

    return art;
  }

  function createTextsEntityWithDefaultElements( base, absolute, textElems, fioriEnabled ) {
    const elements = Object.create(null);
    const { location } = base.name;
    const art = {
      kind: 'entity',
      name: { path: splitIntoPath( location, absolute ), absolute, location },
      location: base.location,
      elements,
      $inferred: 'localized-entity',
    };
    // If there is a type `sap.common.Locale`, then use it as the type for the element `locale`.
    // If not, use the default `cds.String` with a length of 14.
    const hasLocaleType = model.definitions['sap.common.Locale']?.kind === 'type';
    const locale = {
      name: { location, id: 'locale' },
      kind: 'element',
      type: augmentPath( location, hasLocaleType ? 'sap.common.Locale' : 'cds.String' ),
      location,
    };
    if (!hasLocaleType)
      locale.length = { literal: 'number', val: 14, location };

    if (!fioriEnabled) {
      locale.key = { val: true, location };
      // To be compatible, we switch off draft without @fiori.draft.enabled
      // TODO (next major version): remove?
      annotateWith( art, '@odata.draft.enabled', art.location, false );
    }
    else {
      const textId = {
        name: { location, id: 'ID_texts' },
        kind: 'element',
        key: { val: true, location },
        type: augmentPath( location, 'cds.UUID' ),
        location,
      };
      dictAdd( art.elements, 'ID_texts', textId );
    }

    dictAdd( art.elements, 'locale', locale );
    if (addTextsLanguageAssoc) {
      const language = {
        name: { location, id: 'language' },
        kind: 'element',
        location,
        type: augmentPath( location, 'cds.Association' ),
        target: augmentPath( location, 'sap.common.Languages' ),
        on: {
          op: { val: '=', location },
          args: [
            { path: [ { id: 'language', location }, { id: 'code', location } ], location },
            { path: [ { id: 'locale', location } ], location },
          ],
          location,
        },
      };
      setLink( language, '_block', model.$internal );
      dictAdd( art.elements, 'language', language );
    }
    setLink( art, '_block', model.$internal );
    model.definitions[absolute] = art;
    initArtifact( art );

    return art;
  }

  /**
   * @param {XSN.Artifact} art
   * @param {string} textsName
   * @param {XSN.Element[]} textElems
   */
  function addTextsAssociations( art, textsName, textElems ) {
    // texts : Composition of many Books.texts on texts.ID=ID;
    /** @type {array} */
    const keys = textElems.filter( e => e.key && e.key.val );
    const { location } = art.name;
    const texts = {
      name: { location, id: 'texts' },
      kind: 'element',
      location,
      $inferred: 'localized',
      type: augmentPath( location, 'cds.Composition' ),
      cardinality: { targetMax: { literal: 'string', val: '*', location }, location },
      target: augmentPath( location, textsName ),
      on: augmentEqual( location, 'texts', keys ),
    };
    setMemberParent( texts, 'texts', art, 'elements' );
    setLink( texts, '_block', model.$internal );
    // localized : Association to Books.texts on
    //             localized.ID=ID and localized.locale = $user.locale;
    keys.push( [ 'localized.locale', '$user.locale' ] );
    const localized = {
      name: { location, id: 'localized' },
      kind: 'element',
      location,
      $inferred: 'localized',
      type: augmentPath( location, 'cds.Association' ),
      target: augmentPath( location, textsName ),
      on: augmentEqual( location, 'localized', keys ),
    };
    setMemberParent( localized, 'localized', art, 'elements' );
    setLink( localized, '_block', model.$internal );
  }

  /**
   * Returns whether `art` directly or indirectly has the property 'prop',
   * following the 'origin' and the 'type' (not involving elements).
   *
   * DON'T USE FOR ANNOTATIONS (see TODO below)
   *
   * TODO: we should issue a warning if we get localized via TYPE OF
   * TODO: XSN: for anno short form, use { val: true, location, <no literal prop> }
   *       ...then this function also works with annotations
   *
   * @param {XSN.Artifact} art
   * @param {string} prop
   * @returns {boolean}
   */
  function hasTruthyProp( art, prop ) {
    const processed = Object.create(null); // avoid infloops with circular refs
    let name = art.name.absolute;        // is ok, since no recursive type possible
    while (art && !processed[name]) {
      if (art[prop])
        return art[prop].val;
      processed[name] = art;
      if (art._origin) {
        art = art._origin;
        if (!art.name)          // anonymous aspect
          return false;
        name = art && art.name.absolute;
      }
      else if (art.type && art._block && art.type.scope !== 'typeOf') {
        // TODO: also do something special for TYPE OF inside `art`s own elements
        name = resolveUncheckedPath( art.type, 'type', art );
        art = name && model.definitions[name];
      }
      else {
        return false;
      }
    }
    return false;
  }

  // managed composition of aspects ------------------------------------------

  function processAspectComposition( base ) {
    // TODO: we need to forbid COMPOSITION of entity w/o keys and ON anyway
    // TODO: consider entity includes
    // TODO: nested containment
    // TODO: better do circular checks in the aspect!
    if (base.kind !== 'entity' || base.query)
      return;
    const keys = baseKeys();
    if (keys)
      forEachGeneric( base, 'elements', expand ); // TODO: recursively here?
    return;

    function baseKeys() {
      const k = Object.create(null);
      for (const name in base.elements) {
        const elem = base.elements[name];
        if (elem.$duplicates)
          return false;           // no composition-of-type unfold with redefined elems
        if (elem.key && elem.key.val)
          k[name] = elem;
      }
      return k;
    }

    function expand( elem ) {
      if (elem.target)
        return;
      let origin = elem;
      // included element do not have target aspect directly
      while (origin && !origin.targetAspect && origin._origin)
        origin = origin._origin;
      let target = origin.targetAspect;
      if (target && target.path)
        target = resolvePath( origin.targetAspect, 'compositionTarget', origin );
      if (!target || !target.elements)
        return;
      const entityName = `${ base.name.absolute }.${ elem.name.id }`;
      const entity = allowAspectComposition( target, elem, keys, entityName ) &&
            createTargetEntity( target, elem, keys, entityName, base );
      elem.target = {
        location: (elem.targetAspect || elem).location,
        $inferred: 'aspect-composition',
      };
      setArtifactLink( elem.target, entity );
      if (entity) {
        // Support using the up_ element in the generated entity to be used
        // inside the anonymous aspect:
        const { up_ } = target.$tableAliases;
        // TODO: invalidate "up_" alias (at least further navigation) if it
        // already has an _origin (when the managed composition is included)
        if (up_)
          setLink( up_, '_origin', entity.elements.up_ );
        model.$compositionTargets[entity.name.absolute] = true;
        processAspectComposition( entity );
        processLocalizedData( entity );
      }
    }
  }

  /**
   * @returns {boolean|0} `true`, if allowed, `false` if forbidden, `0` if circular containment.
   */
  function allowAspectComposition( target, elem, keys, entityName ) {
    if (!target.elements || Object.values( target.elements ).some( e => e.$duplicates ))
      return false;             // no elements or with redefinitions
    const location = elem.target && elem.target.location || elem.location;
    if ((elem._main._upperAspects || []).includes( target ))
      return 0;               // circular containment of the same aspect

    const keyNames = Object.keys( keys );
    if (!keyNames.length) {
      // TODO: for "inner aspect-compositions", signal already in type
      error( null, [ location, elem ], { target },
             'An aspect $(TARGET) can\'t be used as target in an entity without keys' );
      return false;
    }
    // if (keys.up_) {  // only to be tested if we allow to provide a prefix, which could be ''
    //   // Cannot be in an "inner aspect-compositions" as it would already be wrong before
    //   // TODO: if anonymous type, use location of "up_" element
    //   // FUTURE: add sub info with location of "up_" element
    //   message( 'id', [location, elem], { target, name: 'up_' }, 'Error',
    //      'An aspect $(TARGET) can't be used as target in an entity with a key named $(NAME)' );
    //   return false;
    // }
    if (target.elements.up_) {
      // TODO: for "inner aspect-compositions", signal already in type
      // TODO: if anonymous type, use location of "up_" element
      // FUTURE: if named type, add sub info with location of "up_" element
      error( null, [ location, elem ], { target, name: 'up_' },
             'An aspect $(TARGET) with an element named $(NAME) can\'t be used as target' );
      return false;
    }
    if (model.definitions[entityName]) {
      error( null, [ location, elem ], { art: entityName },
             // eslint-disable-next-line max-len
             'Target entity $(ART) can\'t be created as there is another definition with this name' );
      return false;
    }
    const names = Object.keys( target.elements )
      .filter( n => n.startsWith('up__') && keyNames.includes( n.substring(4) ) );
    if (names.length) {
      // FUTURE: if named type, add sub info with location of "up_" element
      error( null, [ location, elem ], { target: entityName, names }, {
        std: 'Key elements $(NAMES) can\'t be added to $(TARGET) as these already exist',
        one: 'Key element $(NAMES) can\'t be added to $(TARGET) as it already exist',
      });
      return false;
    }
    return true;
  }

  function createTargetEntity( target, elem, keys, entityName, base ) {
    const { location } = elem.targetAspect || elem.target || elem;
    elem.on = {
      location,
      op: { val: '=', location },
      args: [
        augmentPath( location, elem.name.id, 'up_' ),
        augmentPath( location, '$self' ),
      ],
      $inferred: 'aspect-composition',
    };

    const elements = Object.create(null);
    const art = {
      kind: 'entity',
      name: { path: splitIntoPath( location, entityName ), absolute: entityName, location },
      location,
      elements,
      $inferred: 'composition-entity',
    };
    if (target.name) {          // named target aspect
      setLink( art, '_origin', target );
      setLink( art, '_upperAspects', [ target, ...(elem._main._upperAspects || []) ] );
    }
    else {
      setLink( art, '_origin', target );
      // TODO: do we need to give the anonymous target aspect a kind and name?
      setLink( art, '_upperAspects', elem._main._upperAspects || [] );
    }

    const up = { // elements.up_ = ...
      name: { location, id: 'up_' },
      kind: 'element',
      location,
      $inferred: 'aspect-composition',
      type: augmentPath( location, 'cds.Association' ),
      target: augmentPath( location, base.name.absolute ),
      cardinality: {
        targetMin: { val: 1, literal: 'number', location },
        targetMax: { val: 1, literal: 'number', location },
        location,
      },
    };
    // By default, 'up_' is a managed primary key association.
    // If 'up_' shall be rendered unmanaged, infer the parent
    // primary keys and add the ON condition
    if (isDeprecatedEnabled( options, '_unmanagedUpInComponent' )) {
      addProxyElements( art, keys, 'aspect-composition', target.name && location,
                        'up__', '@odata.containment.ignore' );
      up.on = augmentEqual( location, 'up_', Object.values( keys ), 'up__' );
    }
    else {
      up.key = { location, val: true };
      // managed associations must be explicitly set to not null
      // even if target cardinality is 1..1
      up.notNull = { location, val: true };
    }

    dictAdd( art.elements, 'up_', up);
    addProxyElements( art, target.elements, 'aspect-composition', target.name && location );

    setLink( art, '_block', model.$internal );
    model.definitions[entityName] = art;
    initArtifact( art );

    // Copy persistence annotations from aspect.
    copyPersistenceAnnotations(art, target, options);

    return art;
  }

  function addProxyElements( proxyDict, elements, inferred, location, prefix = '', anno = '' ) {
    // TODO: also use for includeMembers()?
    for (const name in elements) {
      const pname = `${ prefix }${ name }`;
      const origin = elements[name];
      const proxy = linkToOrigin( origin, pname, null, null, location || origin.location );
      proxy.$inferred = inferred;
      if (origin.masked)
        proxy.masked = Object.assign( { $inferred: 'include' }, origin.masked );
      if (origin.key)
        proxy.key = Object.assign( { $inferred: 'include' }, origin.key );
      if (anno)
        annotateWith( proxy, anno );
      dictAdd( proxyDict.elements, pname, proxy );
    }
  }
}

/**
 * Group assignments by their layers.  An assignment provided with a definition
 * is considered to be provided in a layer named '', the lowest layer.
 *
 * TODO: make this usable for extend (elements), too =
 *       do not use $priority, make assignments on define do not have own _block
 *
 * @param {object[]} assignments Array of assignments, e.g. extensions.
 * @returns {Record<string, object>} key: layer name, value: {name, layer, assignments[]}`
 */
function layeredAssignments( assignments ) {
  const layered = Object.create(null);
  for (const a of assignments) {
    const layer = a.$priority !== false && layers.layer( a );
    // just consider layer if Extend/Annotate, not Define
    const name = (layer) ? layer.realname : '';
    const done = layered[name];
    if (done)
      done.assignments.push( a );
    else
      layered[name] = { name, layer, assignments: [ a ] };
    // TODO: file - if set: unique in layer
  }
  return layered;
}

/**
 * Return assignments of the highest layers.
 * Also returns whether there could be an issue:
 * - false: there is just one assignment
 * - 'unrelated': there is just one assignment per layer
 * - true: there is at least one layer with two or more assignments
 * TODO: make this usable for extend (elements), too.
 *
 * @param {Record<string, object>} layeredAnnos Structure as returned by layeredAssignments()
 * @returns {{assignments, issue: boolean|string}}
 */
function assignmentsOfHighestLayers( layeredAnnos ) {
  const layerNames = Object.keys( layeredAnnos );
  // console.log('HIB:',layerNames)
  if (layerNames.length <= 1) {
    const name = layerNames[0];
    const { assignments } = layeredAnnos[name] || { assignments: [] };
    delete layeredAnnos[name];
    return { assignments, issue: assignments.length > 1 };
  }

  // collect all layers which are lower than another layer
  const allExtends = Object.create(null);
  allExtends[''] = {};        // the "Define" layer
  for (const name of layerNames) {
    if (name)                 // not the "Define" layer
      Object.assign( allExtends, layeredAnnos[name].layer._layerExtends );
  }
  // console.log('HIE:',Object.keys(allExtends))
  const assignments = [];
  const highest = [];
  for (const name of layerNames) {
    if (!(name in allExtends)) {
      const layer = layeredAnnos[name];
      delete layeredAnnos[name];
      highest.push( layer );
      assignments.push( ...layer.assignments );
    }
  }
  assignments.sort( compareAssignments );
  const good = highest.every( layer => layer.assignments.length === 1 );
  // TODO: use layer.file instead
  const issue = !good || highest.length > 1 && 'unrelated';
  // console.log('HI:',highest.map(l=>l.name),issue,issue&&assignments)
  return { assignments, issue };
}

function compareAssignments( a, b ) {
  const fileA = layers.realname( a._block );
  const fileB = layers.realname( b._block );
  if (fileA !== fileB)
    return (fileA > fileB) ? 1 : -1;
  return (a?.location?.line || 0) - (b?.location?.line || 0) ||
    (a?.location?.col || 0) - (b?.location?.col || 0);
}

/**
 * Copy the annotations `@cds.persistence.skip`/`@cds.persistence.exists` from
 * source to target if present on source but not target.
 *
 * @param {object} target
 * @param {object} source
 * @param {CSN.Options} options
 */
function copyPersistenceAnnotations( target, source, options ) {
  if (!source)
    return;

  const copyExists = !isDeprecatedEnabled( options, 'eagerPersistenceForGeneratedEntities' );
  if (copyExists)
    copy( '@cds.persistence.exists' );
  copy( '@cds.persistence.skip' );

  function copy( anno ) {
    if ( source[anno] && !target[anno] )
      target[anno] = { ...source[anno], $inferred: 'parent-origin' };
  }
}

function augmentEqual( location, assocname, relations, prefix = '' ) {
  const args = relations.map( eq );
  return (args.length === 1)
    ? args[0]
    : { op: { val: 'and', location }, args, location };

  function eq( refs ) {
    if (Array.isArray(refs))
      return { op: { val: '=', location }, args: refs.map( ref ), location };

    const { id } = refs.name;
    return {
      op: { val: '=', location },
      args: [
        { path: [ { id: assocname, location }, { id, location } ], location },
        { path: [ { id: `${ prefix }${ id }`, location } ], location },
      ],
      location,
    };
  }
  function ref( path ) {
    return { path: path.split('.').map( id => ({ id, location }) ), location };
  }
}

/**
 * If the given extension is a `EXTEND <def> WITH TYPE` extension, store
 * it in the given artifact.  resolve.js will resolve types and call
 * `typeExtensions()` later.
 *
 * @param {XSN.Extension} ext
 * @param {object} art
 */
function storeTypeExtension( ext, art ) {
  // If there are no parameters to apply, don't store the extension.
  if (!typeParameters.list.some( prop => ext[prop] !== undefined ))
    return;
  else if (!art._extendType)
    setLink( art, '_extendType', [] );
  art._extendType.push( ext );
}


function checkTextsLanguageAssocOption( model, options ) {
  const languages = model.definitions['sap.common.Languages'];
  const commonLanguagesEntity = options.addTextsLanguageAssoc && languages?.elements?.code;

  if (options.addTextsLanguageAssoc && !commonLanguagesEntity) {
    const variant = !languages ? 'std' : 'code';
    const loc = model.definitions['sap.common.Languages']?.name?.location || null;
    model.$messageFunctions.info('api-ignoring-language-assoc', loc, {
      '#': variant, option: 'addTextsLanguageAssoc', art: 'sap.common.Languages', name: 'code',
    }, {
      std: 'Ignoring option $(OPTION) because entity $(ART) is missing',
      code: 'Ignoring option $(OPTION) because entity $(ART) is missing element $(NAME)',
    });
  }

  return !!commonLanguagesEntity;
}


module.exports = extend;
