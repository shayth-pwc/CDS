'use strict';

const keywords = require('../base/keywords');
const { isBuiltinType, generatedByCompilerVersion, getNormalizedQuery } = require('../model/csnUtils');
const { findElement, createExpressionRenderer, withoutCast } = require('./utils/common');
const { escapeString, hasUnpairedUnicodeSurrogate } = require('./utils/stringEscapes');
const { checkCSNVersion } = require('../json/csnVersion');
const { timetrace } = require('../utils/timetrace');
const { forEachDefinition } = require('../model/csnUtils');
const enrichUniversalCsn = require('../transform/universalCsn/universalCsnEnricher');
const { isBetaEnabled } = require('../base/model');
const { ModelError } = require('../base/error');
const { typeParameters, specialFunctions } = require('../compiler/builtins');
const { forEach } = require('../utils/objectUtils');

const identifierRegex = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/;

/**
 * Render the CSN model 'model' to CDS source text.
 * Returned object has the following properties:
 *  - `model`: CSN model rendered as CDL (string).
 *  - `namespace`: Namespace statement + `using from './model.cds'.
 *
 * @param {CSN.Model} csn
 * @param {CSN.Options} [options]
 */
function csnToCdl(csn, options) {
  timetrace.start('CDL rendering');
  const exprRenderer = createCdlExpressionRenderer();

  if (options.csnFlavor === 'universal' && isBetaEnabled(options, 'enableUniversalCsn'))
    enrichUniversalCsn(csn, options);

  checkCSNVersion(csn, options);

  const cdlResult = Object.create(null);
  cdlResult.model = options.testMode ? '' : `// ${generatedByCompilerVersion()} \n`;

  const subelementAnnotates = [];

  cdlResult.model += renderDefinitions();
  // sub-element annotations that can't be written directly.
  cdlResult.model += renderExtensions(subelementAnnotates, createEnv());

  if (csn.vocabularies)
    cdlResult.model += renderVocabularies(csn.vocabularies);
  if (csn.extensions)
    cdlResult.model += renderExtensions(csn.extensions, createEnv());

  if (csn.namespace) {
    cdlResult.namespace = `namespace ${renderArtifactName(csn.namespace)};\n`;
    cdlResult.namespace += 'using from \'./model.cds\';';
  }

  timetrace.stop();
  return cdlResult;

  /**
   * Render entries from the `csn.definitions` dictionary.
   * Returns an empty string if nothing is rendered.
   *
   * @return {string}
   */
  function renderDefinitions() {
    let result = '';
    const env = createEnv();
    forEachDefinition(csn, (artifact, artifactName) => {
      const sourceStr = renderArtifact(artifactName, artifact, env);
      if (sourceStr !== '')
        result += `${sourceStr}\n`;
    });
    return result;
  }

  /**
   * Render annotation definitions, i.e. entries from csn.vocabularies.
   * Returns an empty string if there isn't anything to render.
   *
   * @param {object} vocabularies
   * @return {string}
   */
  function renderVocabularies(vocabularies) {
    let result = '';
    forEach(vocabularies, renderVocabulariesEntry);
    return result;

    function renderVocabulariesEntry(name, anno) {
      if (!anno._ignore) {
        // This environment is passed down the call hierarchy, for dealing with
        // indentation and name resolution issues
        const env = envNewPath(createEnv(), [ 'vocabularies', name ]);
        const sourceStr = renderTypeOrAnnotation(name, anno, env, 'annotation');
        result += `${sourceStr}\n`;
      }
    }
  }

  /**
   * Render 'extend' and 'annotate' statements from the `extensions` array.
   * Could be annotate-statements for sub-elements annotations or from parseCdl's
   * extensions array or just unapplied extensions.
   *
   * @param {CSN.Extension[]} extensions
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtensions(extensions, env) {
    if (!env.path)
      env = envNewPath(env, [ 'extensions' ]);
    return extensions.map((ext, index) => renderExtension(ext, envAddPath(env, [ index ]))).join('\n');
  }

  /**
   * Render an 'extend' and 'annotate' statement.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtension(ext, env) {
    if (ext.extend)
      return renderExtendStatement(ext.extend, ext, env);
    return renderAnnotateStatement(ext, env);
  }

  /**
   * Render an 'extend' statement.
   * `extName` is the extension's artifact's name, most likely `ext.extend`.
   * This function is recursive, which is why you need to pass it explicitly.
   *
   * @param {string} extName
   * @param {object} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtendStatement(extName, ext, env) {
    extName = renderArtifactName(extName);
    // Element extensions have `kind` set.
    const isElementExtend = (ext.kind === 'extend');
    let result = renderAnnotationAssignmentsAndDocComment(ext, env);

    if (ext.includes && ext.includes.length > 0) {
      // Includes can't be combined with anything in braces {}.
      const affix = isElementExtend ? 'element ' : '';
      const includes = ext.includes.map(inc => quotePathIfRequired(inc)).join(', ');
      result += `${env.indent}extend ${affix}${extName} with ${includes};\n`;
      return result;
    }

    // We have the "old-style" prefix syntax and the "new-style" postfix "with <type>" syntax.
    // The former one can not only extend (sub-)elements but also actions in the same statement whereas
    // the latter cannot.
    // If there are actions, check if there are also elements/columns, and if so, use the prefix notation.
    const usePrefixNotation = isElementExtend || ext.actions && (ext.columns || ext.elements);
    if (usePrefixNotation)
      result += `${env.indent}extend ${getExtendPrefixVariant(ext)} ${extName} with {\n`;
    else
      result += `${env.indent}extend ${extName} with ${getExtendPostfixVariant(ext)} {\n`;

    if (ext.columns) {
      result += renderViewColumns(ext.columns, increaseIndent(env));
    }
    else if (ext.elements) {
      result += renderExtendStatementElements(ext, env);
    }
    else if (ext.enum) {
      const childEnv = increaseIndent(env);
      forEach(ext.enum, (name, value) => {
        result += renderEnumElement(name, value, childEnv);
      });
    }

    // Not part of if/else cascade, because it may be in postfix notation.
    if (ext.actions) {
      // TODO: Merge with renderActionsAndFunctions() -> requires removal of static `with actions`
      const childEnv = increaseIndent(env);
      let actions = '';
      forEach(ext.actions, (actionName, action) => {
        actions += renderActionOrFunction(actionName, action, childEnv);
      });
      if (!usePrefixNotation)
        result += actions;
      else if (actions !== '')
        result += `${env.indent}} actions {\n${actions}`;
    }

    result += `${env.indent}};\n`;
    return result;
  }

  /**
   * What <extend> prefix type to use.  Used to render `extend <type> <ref>` statements.
   *
   * @param {object} ext
   * @return {string}
   */
  function getExtendPrefixVariant(ext) {
    if (ext.kind === 'extend')
      return 'element'; // element extensions inside an `extend`
    if (ext.columns)
      return 'projection';
    if (ext.elements)
      return 'entity';
    return '';
  }

  /**
   * What <extend> postfix type to use.  Used to render `extend <ref> with <type>` statements.
   *
   * @param {CSN.Extension} ext
   * @return {string}
   */
  function getExtendPostfixVariant(ext) {
    if (ext.columns)
      return 'columns';
    if (ext.actions)
      return 'actions';
    if (ext.elements)
      return 'elements';
    if (ext.enum)
      return 'enum';
    return '';
  }

  /**
   * Render the elements inside an `extend` statement. They may themselves be `extend` statements.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderExtendStatementElements(ext, env) {
    let result = '';
    forEach(ext.elements || {}, (elemName, element) => {
      if (element.kind === 'extend')
        result += renderExtendStatement(elemName, element, increaseIndent(env));
      else
        // As soon as we are inside an element, nested `extend` are not possible,
        // since we can't extend an existing element of a new one.
        result += renderElement(elemName, element, increaseIndent(env), true);
    });
    return result;
  }

  /**
   * Render an 'annotate' statement.
   *
   * @param {CSN.Extension} ext
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateStatement(ext, env) {
    // Top-level annotations of the artifact
    let result = renderAnnotationAssignmentsAndDocComment(ext, env);
    result += `${env.indent}annotate ${renderArtifactName(ext.annotate)}`;

    if (ext.params)
      result += renderAnnotateParamsInParentheses(ext.params, env);

    // Element extensions and annotations (possibly nested)
    if (ext.elements)
      result += renderAnnotateStatementElements(ext.elements, env);

    // Returns annotations
    if (ext.returns) {
      const childEnv = increaseIndent(env);
      result += ` returns${renderAnnotateStatementElements(ext.returns.elements, childEnv)}`;
    }

    // Action annotations
    if (ext.actions) {
      result += ' actions {\n';
      const childEnv = increaseIndent(env);
      for (const name in ext.actions) {
        const action = ext.actions[name];
        result += renderAnnotationAssignmentsAndDocComment(action, childEnv) + childEnv.indent + quoteIdIfRequired(name);
        // Action parameter annotations
        if (action.params)
          result += renderAnnotateParamsInParentheses(action.params, childEnv);

        // Annotations on action returns
        if (action.returns && action.returns.elements) {
          const grandChildEnv = increaseIndent(childEnv);
          result += ` returns${renderAnnotateStatementElements(action.returns.elements, grandChildEnv)}`;
        }

        result += ';\n';
      }
      result += `${env.indent}}`;
    }

    result += ';\n';
    return result;
  }

  /**
   * Render the elements-specific part of an 'annotate' statement for an element dictionary
   * 'elements' (assuming that the surrounding parent has just been rendered, without trailing newline).
   * Returns the resulting source string, ending without a trailing newline.
   *
   * @param {CSN.Elements} elements
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateStatementElements(elements, env) {
    let result = ' {\n';
    const childEnv = increaseIndent(env);
    for (const name in elements) {
      const elem = elements[name];
      result += renderAnnotationAssignmentsAndDocComment(elem, childEnv) + childEnv.indent + quoteIdIfRequired(name);
      if (elem.elements)
        result += renderAnnotateStatementElements(elem.elements, childEnv);

      result += ';\n';
    }
    result += `${env.indent}}`;
    return result;
  }

  /**
   * Render a parameter list for `annotate` statements, in parentheses `()`.
   *
   * @param {object} params
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAnnotateParamsInParentheses(params, env) {
    const childEnv = increaseIndent(env);
    let result = '(\n';
    const paramAnnotations = [];
    forEach(params, (paramName, param) => {
      paramAnnotations.push( renderAnnotationAssignmentsAndDocComment(param, childEnv) + childEnv.indent + quoteIdIfRequired(paramName) );
    });
    result += `${paramAnnotations.join(',\n')}\n${env.indent})`;
    return result;
  }

  /**
   * Render an artifact. Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderArtifact(artifactName, art, env) {
    env = envNewPath(env, [ 'definitions', artifactName ]);
    env.artifactName = artifactName;

    switch (art.kind) {
      case 'entity':
        if (art.query || art.projection)
          return renderView(artifactName, art, env);
        return renderEntity(artifactName, art, env);
      case 'aspect':
        return renderAspect(artifactName, art, env);

      case 'context':
      case 'service':
        return renderContextOrService(artifactName, art, env);

      case 'type':
      case 'annotation': // annotation in 'csn.definitions' for compiler v1 compatibility
        return renderTypeOrAnnotation(artifactName, art, env);

      case 'action':
      case 'function':
        return renderActionOrFunction(artifactName, art, env);

      case 'event':
        return renderEvent(artifactName, art, env);

      default:
        throw new ModelError(`to.cdl: Unknown artifact kind: ${art.kind}`);
    }
  }

  /**
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderEvent(artifactName, art, env) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    const normalizedArtifactName = renderArtifactName(artifactName);
    result += `${env.indent}event ${normalizedArtifactName}`;
    if (art.includes)
      result += renderIncludes(art.includes);
    if (art.query || art.projection) {
      result += ' : ';
      result += renderQuery(getNormalizedQuery(art).query, true, 'projection', env,
                            [ 'definitions', artifactName, 'query' ]);
      result += ';\n';
    }
    else if (art.type) {
      // Derived type or annotation with non-anonymous type
      result += ` : ${renderTypeReferenceAndProps(art, env)};\n`;
    }
    else if (art.elements) {
      result += ` ${renderElements(art, env)};\n`;
    }
    return result;
  }

  /**
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderContextOrService(artifactName, art, env) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent}${art.kind} ${renderArtifactName(artifactName)}`;
    return `${result} {};\n`;
  }

  /**
   * Render a (non-projection, non-view) entity. Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderEntity(artifactName, art, env) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += env.indent + (art.abstract ? 'abstract ' : '');
    result += `entity ${renderArtifactName(artifactName)}`;

    if (art.params)
      result += renderParameters(art, env);
    if (art.includes)
      result += renderIncludes(art.includes);
    result += ` ${renderElements(art, env)}`;
    result += `${renderActionsAndFunctions(art, env)};\n`;
    return result;
  }

  /**
   * Render an aspect. Return the resulting source string.
   * Behaves very similar to renderEntity, _except_ that aspects are
   * allowed to _not_ have elements, e.g. `aspect A;`.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAspect(artifactName, art, env) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent}aspect ${renderArtifactName(artifactName)}`;
    if (art.includes)
      result += renderIncludes(art.includes);

    if (art.elements)
      result += ` ${renderElements(art, env)}`;
    else if (art.actions)
      // if there are no elements, but actions, CDL syntax requires braces.
      result += ' { }';

    result += `${renderActionsAndFunctions(art, env)};\n`;
    return result;
  }

  /**
   * Render a list of elements enclosed in braces.  If the list is empty, returns `{ }`.
   *
   * @param {object} artifact Artifact with `elements` property.
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderElements(artifact, env) {
    let elements = '';
    const childEnv = increaseIndent(env);
    for (const name in artifact.elements)
      elements += renderElement(name, artifact.elements[name], childEnv, null);

    if (elements === '')
      return '{ }';
    return `{\n${elements}${env.indent}}`;
  }

  /**
   * Render an element (of an entity, type or annotation, not a projection or view).
   * Return the resulting source string.
   *
   * @param {string} elementName
   * @param {CSN.Element} elm
   * @param {CdlRenderEnvironment} env
   * @param {Boolean} [isSubElement]
   */
  function renderElement(elementName, elm, env, isSubElement) {
    env = envAddPath(env, [ 'elements', elementName ]);
    let result = renderAnnotationAssignmentsAndDocComment(elm, env);
    result += env.indent;
    result += elm.virtual ? 'virtual ' : '';
    result += elm.key && !isSubElement ? 'key ' : '';
    // TODO(v4): Remove once deprecated flag for `masked` is removed.
    result += elm.masked ? 'masked ' : '';
    result += `${quoteIdIfRequired(elementName)} : ${renderTypeReferenceAndProps(elm, env)}`;

    return `${result};\n`;
  }

  /**
   * Render annotations that were extended to a query element of a view or projection (they only
   * appear in the view's 'elements', not in their 'columns' for client CSN, because the element
   * itself may not even be in 'columns', e.g. if it was expanded from a '*').  Return the
   * resulting rendered 'annotate' statement or an empty string if none required.
   *
   * Note: In the past, we checked if the annotation also exists in the respective column,
   *       however, in client CSN, annotations are not part of the column and in parseCdl CSN,
   *       no `elements` exist.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderQueryElementAndEnumAnnotations(artifactName, art, env) {
    const annotate = collectAnnotationsOfElementsAndEnum(art, { artifactName, path: env.path });
    if (annotate)
      return renderExtensions([ annotate ], env);
    return '';
  }

  /**
   * Create an "annotate" statement as a CSN extension for all annotations of (sub-)elements.
   * If no annotation was found, we return `null`.
   *
   * @param {CSN.Artifact} artifact
   * @param {CdlRenderEnvironment} env
   * @return {CSN.Extension|null}
   */
  function collectAnnotationsOfElementsAndEnum(artifact, env) {
    // Array, which may be annotated as well.
    if (artifact.items) {
      env = envAddPath(env, [ 'items' ]);
      artifact = artifact.items;
    }

    if (!artifact.elements && !artifact.enum)
      return null;

    const annotate = { annotate: env.path[1] };

    // Based on the current path, create a correctly nested structure
    // of elements for which we collect annotations.
    // TODO: More properties?
    let obj = annotate;
    for (let i = 2; i < env.path.length; ++i) {
      const key = env.path[i];
      if (key === 'elements' || key === 'actions') {
        obj[key] = Object.create(null);
        const elem = env.path[i + 1];
        obj[key][elem] = {};
        obj = obj[key][elem];
      }
      else if (key === 'returns') {
        obj.returns = {};
        obj = obj.returns;
      }
      else {
        // ignore others, e.g. 'items'
      }
    }
    return collectAnnos(obj, artifact) ? annotate : null;

    /**
     * Recursive function to collect annotations. `annotateObj` will get an `elements`
     * object with annotations only if there are annotations on `art`'s (sub-)elements or
     * enums.  Returned object will use "elements" even for enums, since that is
     * expected in extensions.
     *
     * @return {boolean} True, if there were annotations, false otherwise.
     */
    function collectAnnos(annotateObj, art) {
      if (!art.elements && !art.enum)
        return false;

      const dictKey = art.elements ? 'elements' : 'enum';
      // Use "elements" for both enums and elements. This is allowed in extensions.
      const collected = { elements: Object.create(null) };
      let hasAnnotation = false;

      forEach(art[dictKey], (elemName, element) => {
        if (!collected.elements[elemName])
          collected.elements[elemName] = { };

        let hasElementAnnotations = false;
        for (const name in element) {
          if (name.startsWith('@')) {
            collected.elements[elemName][name] = element[name];
            hasElementAnnotations = true;
            hasAnnotation = true;
          }
        }

        const hasSubAnnotations = collectAnnos(collected.elements[elemName], element);
        if (!hasElementAnnotations && !hasSubAnnotations)
          delete collected.elements[elemName]; // delete if no annotations exist
        hasAnnotation = hasAnnotation || hasSubAnnotations;
      });

      if (hasAnnotation)
        annotateObj.elements = collected.elements;

      return hasAnnotation;
    }
  }

  /**
   * Render the source of a query, which may be a path reference, possibly with an alias,
   * or a subselect, or a join operation, as seen from artifact 'art'.
   * Returns the source as a string.
   *
   * @param {object} source
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderViewSource(source, env) {
    // Sub-SELECT
    if (source.SELECT || source.SET) {
      let result = `(${renderQuery(source, false, 'view', increaseIndent(env))})`;
      if (source.as)
        result += ` as ${quoteIdIfRequired(source.as)}`;

      return result;
    }
    // JOIN
    else if (source.join) {
      // One join operation, possibly with ON-condition
      let result = `(${renderViewSource(source.args[0], env)}`;
      for (let i = 1; i < source.args.length; i++) {
        result += ` ${source.join} `;
        result += renderJoinCardinality(source.cardinality);
        result += `join ${renderViewSource(source.args[i], env)}`;
        if (source.on)
          result += ` on ${exprRenderer.renderExpr(source.on, env)}`;
      }
      result += ')';
      return result;
    }
    // Ordinary path, possibly with an alias

    return renderAbsolutePathWithAlias(source, env);
  }

  function renderJoinCardinality(card) {
    let result = '';
    if (card) {
      if (card.srcmin && card.srcmin === 1)
        result += 'exact ';
      result += card.src && card.src === 1 ? 'one ' : 'many ';
      result += 'to ';
      if (card.min && card.min === 1)
        result += 'exact ';
      if (card.max)
        result += (card.max === 1) ? 'one ' : 'many ';
    }
    return result;
  }

  /**
   * Render a path that starts with an absolute name (as used e.g. for the source of a query),
   * with plain or quoted names, depending on options. Expects an object 'path' that has a 'ref'.
   * Returns the name as a string.
   *
   * @param {object} path
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAbsolutePath(path, env) {
    // Sanity checks
    if (!path.ref)
      throw new ModelError(`Expecting ref in path: ${JSON.stringify(path)}`);


    // Determine the absolute name of the first artifact on the path (before any associations or element traversals)
    const firstArtifactName = path.ref[0].id || path.ref[0];

    // Render the first path step (absolute name, with different quoting/naming ..)
    let result = renderArtifactName(firstArtifactName);

    // Even the first step might have parameters and/or a filter
    if (path.ref[0].args)
      result += `(${renderArguments(path.ref[0], ':', env)})`;

    if (path.ref[0].where) {
      const cardinality = path.ref[0].cardinality ? (`${path.ref[0].cardinality.max}: `) : '';
      const expr = exprRenderer.renderExpr(path.ref[0].where, env);
      result += `[${cardinality}${expr}]`;
    }

    // Add any path steps (possibly with parameters and filters) that may follow after that
    if (path.ref.length > 1)
      result += `:${exprRenderer.renderExpr({ ref: path.ref.slice(1) }, env)}`;

    return result;
  }

  /**
   * Render a path that starts with an absolute name (as used for the source of a query),
   * possibly with an alias, with plain or quoted names, depending on options. Expects an object 'path' that has a
   * 'ref' and (in case of an alias) an 'as'. If necessary, an artificial alias
   * is created to the original implicit name.
   * Returns the name and alias as a string.
   *
   * @param {object} path
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderAbsolutePathWithAlias(path, env) {
    let result = renderAbsolutePath(path, env);
    if (path.as) {
      // Source had an alias - render it
      result += ` as ${quoteIdIfRequired(path.as)}`;
    }
    return result;
  }

  /**
   * Render the given columns.
   *
   * @param {any[]} columns
   * @param {object} elements
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderViewColumns(columns, env, elements = Object.create(null)) {
    const result = columns.map(col => renderViewColumn(col, env, findElement(elements, col)))
      .filter(s => s !== '')
      .join(',\n');
    return `${result}\n`;
  }

  /**
   * Render a single view or projection column 'col', as it occurs in a select list or
   * projection list within 'art', possibly with annotations.
   * Return the resulting source string (no trailing LF).
   *
   * @param {object} col
   * @param {CdlRenderEnvironment} env
   * @param {CSN.Element} element Element corresponding to the column. Generated by the compiler.
   */
  function renderViewColumn(col, env, element) {
    // Annotations and column
    let result = '';
    if (!col.doc) {
      // TODO: In contrast to annotations, we do not render the doc comment as part
      //       of an `annotate` statement.  That may change in the future.
      result += renderDocComment(element, env);
    }
    // Note: parentheses are a workaround for #9015
    result += renderAnnotationAssignmentsAndDocComment(col, env, { parens: true });
    result += env.indent;

    // only if column is virtual, keyword virtual was present in the source text
    result += col.virtual ? 'virtual ' : '';
    result += col.key ? 'key ' : '';

    // Use special rendering for .expand/.inline - renderExpr cannot easily handle some cases
    if (col.expand || col.inline)
      result += renderInlineExpand(col, env);
    else
      result += exprRenderer.renderExpr(withoutCast(col), env);

    // Alias for inline/expand is already handled by renderInlineExpand
    // A new association (cast with `type` and `target`) uses `as` as its primary name, not alias.
    const isNewAssociation = col.cast?.type && col.cast.target;
    if (!isNewAssociation && col.as && !col.inline && !col.expand)
      result += ` as ${quoteIdIfRequired(col.as)}`;

    // Explicit type provided for the view element?
    if (col.cast) {
      // Special case: Explicit association type is actually a redirect
      if (col.cast.target && !col.cast.type)
        result += ` : ${renderRedirectedTo(col.cast, env)}`;
      else
        result += ` : ${renderTypeReferenceAndProps(col.cast, env, { typeRefOnly: true, noAnnoCollect: true })}`;
    }
    return result;
  }

  /**
   * For the current column, render a (nested) inline/expand. If the current column
   * does not have an .expand/.inline, '' is returned
   *
   * @param {object} obj Thing with .expand or .inline
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderInlineExpand(obj, env) {
    // No expression to render for { * } as alias
    let result = (obj.as && obj.expand && !obj.ref) ? '' : exprRenderer.renderExpr(withoutCast(obj), env);

    // s as alias { * }
    if (obj.as && (obj.ref || obj.xpr || obj.val !== undefined || obj.func !== undefined))
      result += ` as ${obj.as}`;

    // We found a leaf - no further drilling
    if (!obj.inline && !obj.expand) {
      if (obj.cast && obj.cast.type)
        result += ` : ${renderTypeReferenceAndProps(obj.cast, createEnv(), { noAnnoCollect: true })}`;
      else if (obj.cast && obj.cast.target) // test tbd
        result += ` : ${renderRedirectedTo(obj.cast, env)}`;
      return result;
    }

    if (obj.inline)
      result += '.{\n';
    else
      result += result !== '' ? ' {\n' : '{\n';

    // Drill down and render children of the expand/inline
    const childEnv = increaseIndent(env);
    const expandInline = obj.expand || obj.inline;
    expandInline.forEach((elm, i) => {
      result += `${childEnv.indent}${renderInlineExpand(elm, childEnv)}`;
      if (i < expandInline.length - 1)
        result += ',\n';
    });
    result += `\n${env.indent}}`;

    // Don't forget about the .excluding
    if (obj.excluding)
      result += ` excluding { ${obj.excluding.join(',')} }`;

    // { * } as expand
    if (!obj.ref && obj.as)
      result += ` as ${obj.as}`;

    return result;
  }

  /**
   * Render .doc properties as comments in CDL
   *
   * @param {object} obj Object to render for
   * @param {CdlRenderEnvironment} env
   * @returns {String}
   */
  function renderDocComment(obj, env) {
    if (!obj || obj && obj.doc === undefined)
      return '';
    else if (obj && obj.doc === null) // empty doc comment needs to be rendered
      return `\n${env.indent}/** */\n`;

    // Smaller comment for single-line comments.  If the comments starts or ends with whitespace
    // we must use a block comment, or it will be lost when compiling the source again.
    if (!obj.doc.includes('\n') && !/^\s|\s$/.test(obj.doc))
      return `${env.indent}/** ${obj.doc} */\n`;

    const comment = obj.doc.split('\n').map(line => `${env.indent} * ${line}`).join('\n');
    return `${env.indent}/**\n${comment}\n${env.indent} */\n`;
  }

  /**
   * Render a view. If '$syntax' is set (to 'projection', 'view', 'entity'),
   * the view query is rendered in the requested syntax style, otherwise it
   * is rendered as a view.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   */
  function renderView(artifactName, art, env) {
    const syntax = (art.projection) ? 'projection' : 'entity';
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent}entity ${renderArtifactName(artifactName)}`;
    if (art.params)
      result += renderParameters(art, env);
    result += ' as ';
    result += renderQuery(getNormalizedQuery(art).query, true, syntax, env, [ 'definitions', artifactName, 'query' ], art.elements);
    if (art.actions) // Views/Projections also allow actions. Just the VIEW keyword variant did not.
      result += renderActionsAndFunctions(art, env);
    result += ';\n';
    result += renderQueryElementAndEnumAnnotations(artifactName, art, env);
    if (art.includes)
      result += renderExtension({ extend: artifactName, includes: art.includes }, env);
    return result;
  }

  /**
   * Render a query 'query', i.e. a select statement with where-condition etc.
   * If 'isLeadingQuery' is true, mixins, actions and functions of 'art' are
   * also rendered into the query. Use 'syntax' style ('projection', 'view',
   * or 'entity')
   *
   * @param {CSN.Query} query
   * @param {boolean} isLeadingQuery
   * @param {string} syntax The query syntax, either "projection", "entity" or "view"
   * @param {CdlRenderEnvironment} env
   * @param {CSN.Path} [path=[]]
   * @param {object} [elements]
   */
  function renderQuery(query, isLeadingQuery, syntax, env, path = [], elements = query.elements || Object.create(null)) {
    if (query.SET) {
      // Set operator, such as UNION, INTERSECT, or EXCEPT...
      return renderQuerySet();
    }
    else if (!query.SELECT) {
      // ...otherwise must have a SELECT
      throw new ModelError(`Unexpected query operation ${JSON.stringify(query)}`);
    }

    let result = '';
    const select = query.SELECT;
    const childEnv = increaseIndent(env);

    // If not a projection, must be view/entity.
    result += (syntax === 'projection') ? 'projection on ' : 'select from ';
    result += renderViewSource(select.from, env);

    if (select.mixin) {
      let elems = '';
      forEach(select.mixin, (name, mixin) => {
        elems += renderElement(name, mixin, childEnv);
      });
      if (elems) {
        result += ' mixin {\n';
        result += elems;
        result += `${env.indent}} into`;
      }
    }
    result += select.distinct ? ' distinct' : '';
    if (select.columns) {
      result += ' {\n';
      result += renderViewColumns(select.columns, increaseIndent(env), elements);
      result += `${env.indent}}`;
    }

    if (select.excluding) {
      result += ` excluding {\n${select.excluding.map(id => `${childEnv.indent}${quoteIdIfRequired(id)}`).join(',\n')}\n`;
      result += `${env.indent}}`;
    }
    // FIXME: Currently, only projections can have actions and functions, but we cannot distinguish
    // a projection from a view any more
    if (isLeadingQuery)
      result += renderActionsAndFunctions(query, env);

    if (select.where)
      result += `${continueIndent(result, env)}where ${exprRenderer.renderExpr(select.where, env)}`;

    if (select.groupBy)
      result += `${continueIndent(result, env)}group by ${select.groupBy.map(expr => exprRenderer.renderExpr(expr, env)).join(', ')}`;

    if (select.having)
      result += `${continueIndent(result, env)}having ${exprRenderer.renderExpr(select.having, env)}`;

    if (select.orderBy)
      result += `${continueIndent(result, env)}order by ${select.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;

    if (select.limit)
      result += `${continueIndent(result, env)}${renderLimit(select.limit, env)}`;

    return result;

    /**
     * Utility function to make sure that we continue with the same indentation in WHERE, GROUP BY, ... after a closing curly brace and beyond
     *
     * @param {string} str
     * @param {CdlRenderEnvironment} indentEnv
     * @return {string}
     */
    function continueIndent(str, indentEnv) {
      if (str.endsWith('}') || str.endsWith('})')) {
        // The preceding clause ended with '}', just append after that
        return ' ';
      }
      // Otherwise, start new line and indent normally
      return `\n${increaseIndent(indentEnv).indent}`;
    }

    /**
     * Render a query's LIMIT clause, which may also have OFFSET.
     *
     * @param {CSN.QueryLimit} limit
     * @param {CdlRenderEnvironment} limitEnv
     * @return {string}
     */
    function renderLimit(limit, limitEnv) {
      let limitStr = '';
      if (limit.rows !== undefined)
        limitStr += `limit ${exprRenderer.renderExpr(limit.rows, limitEnv)}`;

      if (limit.offset !== undefined) {
        const offsetIndent = (limitStr === '') ? '' : `\n${increaseIndent(limitEnv).indent}`;
        limitStr += `${offsetIndent}offset ${exprRenderer.renderExpr(limit.offset, limitEnv)}`;
      }
      return limitStr;
    }

    /**
     * Render UNION, INTERSECT, and EXCEPT, i.e. sets.
     *
     * @return {string}
     */
    function renderQuerySet() {
      const subQueries = query.SET.args.map((arg, i) => {
        // First arg may be leading query
        const subQuery = renderQuery(arg, isLeadingQuery && (i === 0), 'view', env, path.concat([ 'SET', 'args', i ]), elements);
        return `(${subQuery})`;
      });

      let setResult = subQueries.join(`\n${env.indent}${query.SET.op}${query.SET.all ? ' all' : ''} `);
      // Set operation may also have an ORDER BY and LIMIT/OFFSET (in contrast to the ones belonging to
      // each SELECT)
      if (query.SET.orderBy)
        setResult += `${continueIndent(setResult, env)}order by ${query.SET.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;

      if (query.SET.limit)
        setResult += `${continueIndent(setResult, env)}${renderLimit(query.SET.limit, env)}`;
      return setResult;
    }
  }

  /**
   * Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
   * have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
   *
   * @param {object} entry
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderOrderByEntry(entry, env) {
    let result = renderAnnotationAssignmentsAndDocComment(entry, env) + exprRenderer.renderExpr(entry, env);
    if (entry.sort)
      result += ` ${entry.sort}`;

    if (entry.nulls)
      result += ` nulls ${entry.nulls}`;

    return result;
  }

  /**
   * Render an entity's actions and functions (if any)
   * (expect an entity with trailing '}' or an 'extend' statement ending with 'with'
   * to have just been rendered).
   * Return the resulting source string.
   *
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderActionsAndFunctions(art, env) {
    let result = '';
    const childEnv = increaseIndent(env);
    for (const name in art.actions)
      result += renderActionOrFunction(name, art.actions[name], envAddPath(childEnv, [ 'actions', name ]));

    // Even if we have seen actions/functions, they might all have been ignored
    if (result !== '')
      result = ` actions {\n${result}${env.indent}}`;

    return result;
  }

  /**
   * Render an action or function 'act' with name 'actName'. Return the resulting source string.
   *
   * @param {string} actionName
   * @param {CSN.Action} act
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderActionOrFunction(actionName, act, env) {
    let result = renderAnnotationAssignmentsAndDocComment(act, env) + env.indent + act.kind;
    result += ` ${renderArtifactName(actionName)}`;
    result += renderParameters(act, env);
    if (act.returns) {
      const actEnv = envAddPath(env, [ 'returns' ]);
      result += ` returns ${renderTypeReferenceAndProps(act.returns, actEnv)}`;
    }

    result += ';\n';
    return result;
  }

  /**
   * Render art.params, i.e. list of parameter in parentheses.  If there is only one
   * parameter, a single line is used, otherwise an indented list is used.
   * If there are no params, an empty list `()` is returned.
   *
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderParameters(art, env) {
    const childEnv = increaseIndent(env);
    const parameters = Object.keys(art.params || {}).map(name => renderParameter(name, art.params[name], childEnv));
    if (parameters.length === 0)
      return '()';
    return `(\n${parameters.join(',\n')}\n${env.indent})`;
  }

  /**
   * Render an action or function parameter 'par' with name 'parName'. Return the resulting source string (no trailing LF).
   *
   * @param {string} parName
   * @param {object} par
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderParameter(parName, par, env) {
    env = envAddPath(env, [ 'params', parName ]);
    let result = `${renderAnnotationAssignmentsAndDocComment(par, env)}${env.indent}`;
    result += `${quoteIdIfRequired(parName)} : ${renderTypeReferenceAndProps(par, env)}`;
    return result;
  }

  /**
   * Render a type (derived or structured) or an annotation decl with name 'artifactName'.
   * Return the resulting source string.
   *
   * @param {string} artifactName
   * @param {CSN.Artifact} art
   * @param {CdlRenderEnvironment} env
   * @param {String} [artType] - used for rendering csn.vocabularies, as the annotations there do not have a kind.
   * @return {string}
   */
  function renderTypeOrAnnotation(artifactName, art, env, artType) {
    let result = renderAnnotationAssignmentsAndDocComment(art, env);
    result += `${env.indent + (artType || art.$syntax || art.kind )} ${renderArtifactName(artifactName)}`;
    if (art.includes)
      result += renderIncludes(art.includes);

    if (!art.type && art.elements) // For nicer output, no colon if unnamed structure is used.
      result += ` ${renderTypeReferenceAndProps(art, env)}`;
    else
      result += ` : ${renderTypeReferenceAndProps(art, env)}`;
    result += ';\n';
    return result;
  }

  /**
   * Render a reference to a type used by 'artifact' (named or inline) and (element) properties
   * such as `not null` and `default <xpr>`.
   * Allow suppressing rendering of structs such as enums - used in columns for example.
   *
   * @param {object} artifact
   * @param {CdlRenderEnvironment} env
   * @param {object} [config={}] - `typeRefOnly`   Whether to only render type defs, no arrayed/structured/enum.
   *                             - `noAnnoCollect` Do not collect annotations of sub-elements.
   * @return {string}
   */
  function renderTypeReferenceAndProps(artifact, env, config = {}) {
    let result = '';
    const { typeRefOnly, noAnnoCollect } = config;
    let isTypeDef = env.path?.length === 2; // e.g [ 'definitions', typeDef ];

    if (typeRefOnly && !artifact.type)
      throw new ModelError(`Expected artifact to have a type; in: ${env.artifactName}`);

    if (artifact.localized) // works even for type definitions
      result += 'localized ';

    if (!artifact.type && artifact.items) {
      result += 'many '; // alternative: 'array of'; but not used
      artifact = artifact.items;
      env = envAddPath(env, 'items');
      // element keywords allowed in MANY case; was an oversight when arrays were introduced.
      isTypeDef = false;
      // "many many" does not work in CDL, so we don't check for it.
    }

    if (!artifact.type && artifact.elements) {
      result += renderElements(artifact, env);
      if (!isTypeDef)
        result += renderNullability(artifact);
      // structured default not possible at the moment
      return result;
    }

    // Association type
    if (artifact.type === 'cds.Association' || artifact.type === 'cds.Composition') {
      const isComp = artifact.type === 'cds.Composition';
      // Type, cardinality and target; CAPire uses CamelCase
      result += isComp ? 'Composition' : 'Association';
      result += renderCardinality(artifact);

      // `targetAspect` may be set by the core compiler and refers to the original named or unnamed aspect.
      // In parseCdl, `target` may still be an object containing elements.  This would be replaced
      // by targetAspect in client CSN, but we can't rely on that.
      // If a name exists (either in target or targetAspect), prefer it over rendering elements.
      const elements = artifact.target && artifact.target.elements || artifact.targetAspect && artifact.targetAspect.elements;
      if (typeof artifact.target === 'string' || typeof artifact.targetAspect === 'string') {
        result += renderAbsolutePath({ ref: [ artifact.target || artifact.targetAspect ] }, env);
      }
      else if (elements) {
        // anonymous aspect, either parseCdl or client CSN.
        result += renderElements({ elements }, env);
      }
      else {
        throw new ModelError('Association/Composition is missing its target! Throwing exception to trigger recompilation.');
      }

      // ON-condition (if any)
      if (artifact.on)
        result += ` on ${exprRenderer.renderExpr(artifact.on, env)}`;

      // Foreign keys (if any, unless we also have an ON_condition (which means we have been transformed from managed to unmanaged)
      if (artifact.keys && !artifact.on)
        result += ` { ${Object.keys(artifact.keys).map(name => renderForeignKey(artifact.keys[name], env)).join(', ')} }`;

      if (!isTypeDef && !artifact.on) // unmanaged associations can't be followed by "not null"
        result += renderNullability(artifact);
      // DEFAULT not possible here.

      return result;
    }

    // At this point, we will render a named type.

    // If we have a type and elements, we may have sub-structure annotates that would
    // get lost if we only render the type name.
    // We only extract annotations of enums, if "typeRefOnly" is true.  Otherwise, since
    // the full enum is rendered below, we would have unnecessary annotations.
    // TODO: Can we annotate elements of targetAspect?
    //       If so, move this block before the composition rendering.
    if (!noAnnoCollect && (!artifact.enum || typeRefOnly)) {
      const annotate = collectAnnotationsOfElementsAndEnum(artifact, env);
      if (annotate)
        subelementAnnotates.push(annotate);
    }

    // Reference to another artifact
    if (typeof artifact.type === 'string') {
      // If we get here, it must be a named type
      result += renderNamedTypeWithParameters(artifact);
    }
    else if (artifact.type?.ref) {
      result += renderAbsolutePath(artifact.type, env);
    }

    if (artifact.enum && !typeRefOnly)
      result += renderEnum(artifact.enum, env);
    if (!isTypeDef) // NOT NULL not possible for not-arrayed type definitions
      result += renderNullability(artifact);
    if (artifact.default)
      result += ` default ${exprRenderer.renderExpr(artifact.default, env)}`;

    return result;
  }

  /**
   * Render REDIRECTED TO with its keys/on condition for the given artifact.
   *
   * @param {object} art
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderRedirectedTo(art, env) {
    let result = `redirected to ${quotePathIfRequired(art.target)}`;
    if (art.on)
      result += ` on ${exprRenderer.renderExpr(art.on, env)}`;
    else if (art.keys)
      result += ` { ${Object.keys(art.keys).map(name => renderForeignKey(art.keys[name], env)).join(', ')} }`;
    return result;
  }

  /**
   * Render the named type with optional parameters, e.g. `MyString(length: 10)`.
   * @param {CSN.Artifact} artWithType
   * @return {string}
   */
  function renderNamedTypeWithParameters(artWithType) {
    let result = '';

    if (isBuiltinType(artWithType.type)) {
      // If there is a user-defined type with the same short name (cds.Integer -> Integer),
      // we render the full name, including the leading "cds."
      if (csn.definitions[artWithType.type.slice(4)])
        result += artWithType.type;
      else
        result += artWithType.type.slice(4);
    }
    else {
      result += renderArtifactName(artWithType.type);
    }

    result += renderTypeParameters(artWithType);
    return result;
  }


  /**
   * Render the 'enum { ... } part of a type declaration
   *
   * @param {CSN.EnumElements} enumPart
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderEnum(enumPart, env) {
    let result = ' enum {\n';
    const childEnv = increaseIndent(env);
    for (const name in enumPart)
      result += renderEnumElement(name, enumPart[name], childEnv);
    result += `${env.indent}}`;
    return result;
  }

  /**
   * Render the element of a `<type> enum {}` structure.
   *
   * @param {string} name
   * @param {CSN.EnumValue} enumValue
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderEnumElement(name, enumValue, env) {
    let result = '';
    result += renderAnnotationAssignmentsAndDocComment(enumValue, env);
    result += env.indent + quoteIdIfRequired(name);
    if (enumValue.val !== undefined)
      result += ` = ${exprRenderer.renderExpr(enumValue, env)}`;
    else if (enumValue['#'] !== undefined)
      result += ` = #${enumValue['#']}`;
    result += ';\n';
    return result;
  }

  /**
   * Render an annotation value (somewhat like a simplified expression, with slightly different
   * representation)
   *
   * @param {any} x
   * @param {CdlRenderEnvironment} env
   */
  function renderAnnotationValue(x, env) {
    if (Array.isArray(x)) {
      // Render array parts as values. Spaces required if last array value is
      // a delimited identifier.
      return `[ ${x.map(item => renderAnnotationValue(item, env)).join(', ')} ]`;
    }
    else if (typeof x === 'object' && x !== null) {
      // Enum symbol
      if (x['#']) {
        return `#${x['#']}`;
      }
      // Shorthand for absolute path (as string)
      else if (x['=']) {
        return quotePathIfRequired(x['=']);
      }
      // Shorthand for ellipsis: `... up to <val>`
      else if (x['...']) {
        if (x['...'] === true)
          return '...';
        return `... up to ${renderAnnotationValue(x['...'], env)}`;
      }

      // Struct value (can currently only occur within an array)
      // Render as one-liner if there is at most one key.  Render as multi-line
      // struct if there are more and use nicer indentation.
      const keys = Object.keys(x);
      const childEnv = keys.length <= 1 ? env : increaseIndent(env);
      const values = keys.map(key => `${quoteAnnotationPathIfRequired(key)}: ${renderAnnotationValue(x[key], childEnv)}`);
      if (values.length <= 1)
        return `{ ${values.join(', ')} }`;
      return `{\n${childEnv.indent}${values.join(`,\n${childEnv.indent}`)}\n${env.indent}}`;
    }
    // Null
    else if (x === null) {
      return 'null';
    }
    // Primitive: string, number, boolean

    // Quote strings, leave all others as they are
    return (typeof x === 'string') ? renderString(x, env) : x;
  }

  /**
   * Render a single path step 's' at path position 'idx', which can have filters or parameters or be a function
   *
   * @param {string|object} s
   * @param {number} idx
   * @param {object} env
   * @returns {string}
   */
  function renderPathStep(s, idx, env) {
    // Simple id or absolute name
    if (typeof s === 'string') {
      // In first path position, do not quote $projection and magic $-variables like CURRENT_DATE, $now etc.
      // FIXME: We should rather explicitly recognize quoting somehow
      if (idx === 0 && s.startsWith('$'))
        return s;
      return quoteIdIfRequired(s, env.additionalKeywords);
    }
    // ID with filters or parameters
    else if (typeof s === 'object') {
      // Sanity check
      if (!s.func && !s.id)
        throw new ModelError(`Unknown path step object: ${JSON.stringify(s)}`);

      // Not really a path step but an object-like function call
      if (s.func)
        return `${s.func}(${renderArguments(s, '=>', env)})`;

      // Path step, possibly with view parameters and/or filters
      let result = `${quoteIdIfRequired(s.id, env.additionalKeywords)}`;
      if (s.args) {
        // View parameters
        result += `(${renderArguments(s, ':', env)})`;
      }
      if (s.where) {
        // Filter, possibly with cardinality
        const cardinality = s.cardinality ? (`${s.cardinality.max}: `) : '';
        const expr = exprRenderer.renderExpr(s.where, env);
        result += `[${cardinality}${expr}]`;
      }

      return result;
    }

    throw new ModelError(`Unknown path step: ${JSON.stringify(s)}`);
  }

  /**
   * Render function arguments or view parameters (positional if array, named if object/dict),
   * using 'sep' as separator for named parameters
   *
   * @param {object} node with `args` to render
   * @param {string} sep
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderArguments(node, sep, env) {
    if (!node.args)
      return '';
    else if (Array.isArray(node.args))
      return renderPositionalArguments(node, env);
    else if (typeof node.args === 'object')
      return renderNamedArguments(node, sep, env);
    throw new ModelError(`Unknown args: ${JSON.stringify(node.args)}; expected array/object`);
  }

  /**
   * Render named function arguments or view parameters,
   * using 'sep' as separator.
   *
   * @param {object} node with `args` to render
   * @param {string} separator
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderNamedArguments(node, separator, env) {
    return Object.keys(node.args).map(function renderNamedArgument(key) {
      return `${quoteIdIfRequired(key, env.additionalKeywords)} ${separator} ${renderArgument(node.args[key], env)}`;
    }).join(', ');
  }

  /**
   * Render a comma separated list of positional function arguments.
   *
   * @param {object} node with `args` to render
   * @param {CdlRenderEnvironment} env
   * @returns {string}
   */
  function renderPositionalArguments(node, env) {
    if (!node.args)
      return '';
    const func = node.func?.toUpperCase();
    if (func) {
      return node.args.map(function renderFunctionArg(arg, i) {
        return renderArgument(arg, env, getKeywordsForSpecialFunctionArgument(func, i));
      }).join(', ');
    }
    return node.args.map(arg => renderArgument(arg, env)).join(', ');
  }

  /**
   * Render a function argument, e.g. for generic functions or CAST().
   * Ensures that parentheses are used if necessary, e.g. for `someFct( (1=1), (1=1) )`.
   *
   * @param {any} arg
   * @param {CdlRenderEnvironment} env
   * @param {string[]} additionalKeywords
   * @return {string}
   */
  function renderArgument(arg, env, additionalKeywords = []) {
    // If the argument is a xpr with e.g. `=`, it may require parentheses.
    // For nested xpr, `exprRenderer.renderExpr()` will already add parentheses.
    env = { ...env, additionalKeywords };
    if (isSimpleFunctionExpression(arg && arg.xpr, additionalKeywords))
      return exprRenderer.renderExpr(arg, env);
    return exprRenderer.renderSubExpr(arg, env);
  }

  /**
   * Render an artifact's cardinality.
   *
   * @param artifact
   * @returns {string}
   */
  function renderCardinality(artifact) {
    if (isSimpleCardinality(artifact.cardinality))
      return renderSimpleCardinality(artifact);
    return renderBracketCardinality(artifact);
  }

  /**
   * Render a cardinality (only those parts that were actually provided)
   *
   * @param {CSN.Artifact} art
   * @return {string}
   */
  function renderBracketCardinality(art) {
    const isComp = art.type === 'cds.Composition';
    const suffix = (isComp ? ' of ' : ' to ');
    const card = art.cardinality;

    if (!card)
      return suffix;

    let result = '[';
    if (card.src !== undefined)
      result += `${card.src}, `;

    if (card.min !== undefined)
      result += `${card.min}..`;

    if (card.max !== undefined)
      result += card.max;

    return `${result}]${suffix}`;
  }

  /**
   * A "simple" cardinality is one that only has a "max" cardinality property
   * which is either '*' or 1.
   *
   * @param {CSN.Cardinality} cardinality
   * @return {boolean}
   */
  function isSimpleCardinality(cardinality) {
    return !cardinality || (
      cardinality.min === undefined &&
      cardinality.src === undefined &&
      cardinality.srcmin === undefined &&
      (cardinality.max === '*' || cardinality.max === 1)
    );
  }

  /**
   * Renders the simple cardinality of an association/composition, i.e. "many"/"one",
   * including the "of"/"to" part.
   *
   * @param {CSN.Element} elem
   * @return {string}
   */
  function renderSimpleCardinality(elem) {
    let result = (elem.type === 'cds.Association' ? ' to ' : ' of ');
    if (!elem.cardinality)
      return result;
    if (elem.cardinality.max === '*')
      result += 'many ';
    else if (elem.cardinality.max === 1)
      result += 'one ';
    return result;
  }

  // Render the nullability of an element or parameter (can be unset, true, or false)
  function renderNullability(obj /* , env */) {
    if (obj.notNull === undefined) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull ? ' not null' : ' null';
  }

  /**
   * Render a foreign key (no trailing LF)
   *
   * @param {object} fKey
   * @param {CdlRenderEnvironment} env
   * @return {string}
   */
  function renderForeignKey(fKey, env) {
    const alias = fKey.as ? (` as ${fKey.as}`) : '';
    return exprRenderer.renderExpr(fKey, env) + alias;
  }

  /**
   * Render (primitive) type parameters of artifact 'artWithType', i.e.
   * length, precision and scale (even if incomplete), plus any other unknown ones.
   *
   * @param {CSN.Artifact} artWithType
   * @returns {string}
   */
  function renderTypeParameters(artWithType) {
    const params = typeParameters.list.filter(param => artWithType[param] !== undefined);
    if (params.length === 0)
      return '';

    // Special cases for 1 or 2 arguments.
    if (params.length === 1 && artWithType.length !== undefined)
      return `(${artWithType.length})`;
    if (params.length === 2 && artWithType.precision !== undefined && artWithType.scale !== undefined)
      return `(${artWithType.precision}, ${artWithType.scale})`;

    // Render named params
    const renderedParams = [];
    for (const param of params)
      renderedParams.push(`${param}: ${artWithType[param]}`);

    return `(${renderedParams.join(', ')})`;
  }

  /**
   * Render all annotation assignments of annotatable object 'obj'.
   *
   * @param {object} obj Object that has annotations
   * @param {CdlRenderEnvironment} env
   * @param {{parens: boolean}} [config] Config for renderAnnotationAssignment()
   * @return {string}
   */
  function renderAnnotationAssignmentsAndDocComment(obj, env, config) {
    let result = renderDocComment(obj, env);
    for (const name in obj) {
      if (name.startsWith('@'))
        result += renderAnnotationAssignment(obj[name], name, env, config);
    }
    return result;
  }

  /**
   * Render a single annotation assignment 'anno' with fully qualified name 'name' (no trailing LF).
   * We might see variants like 'A.B.C#foo' or even 'A.B#foo.C'. The latter needs to be quoted as
   * dots in the variant are not recognized by the compiler.
   *
   * @param {any} anno Annotation value
   * @param {string} name Annotation name, e.g. `@A.B.C#foo.C`
   * @param {CdlRenderEnvironment} env
   * @param {object} [config] parens: Whether the annotation assignment must be surrounded by parentheses.
   * @return {string} Rendered annotation, possibly quoted: `@![A.B.C#foo.C]: value`
   */
  function renderAnnotationAssignment(anno, name, env, config = { parens: false }) {
    name = name.substring(1);
    // Take the annotation assignment apart into <nameBeforeVariant>#<variantAndRest>
    const parts = name.split('#');
    const nameBeforeVariant = parts[0];
    const variant = parts[1];
    const { parens } = config;

    // Identifier according to our grammar: /[$_a-zA-Z][$_a-zA-Z0-9]*/
    // We expand this pattern to also include dots after the first character.
    // If the annotation does not follow this pattern `ident(.@ident)*`, it must be quoted:
    // `@identifier@identifier` must be quoted but `@identifier.@identifier` should not.
    // TODO: Use quoteAnnotationPathIfRequired()
    const annoRequiresQuoting = !/^[$_a-zA-Z][$_a-zA-Z0-9.]*(?:\.@[$_a-zA-Z][$_a-zA-Z0-9.]*)*$/.test(nameBeforeVariant);
    // Unfortunately, the compiler does not allow `.` after the first variant identifier,
    // even though that is the result after flattening.
    const variantRequiresQuoting = variant && !/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(variant);

    let result = `${env.indent}@`;
    if (parens)
      result += '(';

    if (annoRequiresQuoting || variantRequiresQuoting)
      result += quote(name);
    else
      result += name;

    result += ` : ${renderAnnotationValue(anno, env)}`;
    if (parens)
      result += ')';
    return `${result}\n`;
  }

  /**
   * Render the name of an artifact, quote path steps if necessary.
   *
   * @param {string} artifactName Artifact name to render
   * @return {string} Artifact name ready for rendering
   */
  function renderArtifactName(artifactName) {
    return quotePathIfRequired(artifactName);
  }

  function createCdlExpressionRenderer() {
    return createExpressionRenderer({
      finalize: x => x,
      typeCast(x) {
        const typeRef = renderTypeReferenceAndProps(x.cast, this.env, { typeRefOnly: true, noAnnoCollect: true });
        const arg = { ...x, cast: null }; // "arg" without cast to avoid recursion.
        return `cast(${renderArgument(arg, this.env)} as ${typeRef})`;
      },
      val(x) {
        // Literal value, possibly with explicit 'literal' property
        switch (x.literal || typeof x.val) {
          case 'number':
          case 'boolean':
          case 'null':
            return x.val;
          case 'x':
          case 'date':
          case 'time':
          case 'timestamp':
            return `${x.literal}'${x.val}'`;
          case 'string':
            return renderString(x.val, this.env);
          case 'object':
            if (x.val === null)
              return 'null';
            // otherwise fall through to
          default:
            throw new ModelError(`Unknown literal or type: ${JSON.stringify(x)}`);
        }
      },
      aliasOnly: x => x.as,
      enum: x => `#${x['#']}`,
      ref(x) {
        return `${(x.param || x.global) ? ':' : ''}${x.ref.map((step, index) => renderPathStep(step, index, this.env)).join('.')}`;
      },
      windowFunction(x) {
        const funcDef = this.func(x);
        return `${funcDef} ${this.renderExpr(x.xpr)}`; // xpr[0] is 'over'
      },
      func(x) {
        if (keywords.cdl_functions.includes(x.func.toUpperCase()))
          return x.func;
        const name = identifierRegex.test(x.func) ? x.func : quote(x.func);
        return `${name}(${renderArguments( x, '=>', this.env )})`;
      },
      xpr(x) {
        if (this.isNestedXpr && !x.cast || x.xpr.some(s => s === 'exists'))
          return `(${this.renderExpr(x.xpr)})`;
        return this.renderExpr(x.xpr);
      },
      // Sub-queries in expressions need to be in parentheses, otherwise
      // left-associativity of UNIONS may result in different results.
      // For example: `select from E where id in (select from E union select from E);`:
      // Without parentheses, it would be different query.
      SET(x) {
        return `(${renderQuery(x, false, 'view', increaseIndent(this.env))})`;
      },
      SELECT(x) {
        return `(${renderQuery(x, false, 'view', increaseIndent(this.env))})`;
      },
    });
  }
}

/**
 * Returns a newly created default environment (which keeps track of indentation, required USING
 * declarations and name prefixes.
 *
 * @return {CdlRenderEnvironment}
 */
function createEnv() {
  return {
    // Current indentation string
    indent: '',
    path: null,
    artifactName: '',
    elementName: '',
  };
}

function envAddPath(env, path) {
  return Object.assign({}, env, { path: [ ...env.path, ...path ] } );
}
function envNewPath(env, path) {
  return Object.assign({}, env, { path: [ ...path ] } );
}

/**
 * Returns a copy of 'env' with increased indentation (and reset name prefix)
 *
 * @param {CdlRenderEnvironment} env
 * @returns {CdlRenderEnvironment}
 */
function increaseIndent(env) {
  return Object.assign({}, env, { indent: `${env.indent}  ` });
}

/**
 * Quote the path steps with `![]` if necessary. For simple ids such as
 * `elem` use `quoteIdIfRequired` instead.
 *
 * In contrast to quoteIdIfRequired, does not handle additional keywords,
 * because it was not required, yet.
 *
 * @param {string} path
 * @returns {string}
 *
 * @todo For paths such as `E.key`, `key` does not have to be in quotes.
 */
function quotePathIfRequired(path) {
  return path.split('.').map(step => quoteIdIfRequired(step)).join('.');
}

/**
 * Quote the id with `![]` if necessary. For paths such as `E.key` use
 * `quotePathIfRequired` instead.
 *
 * Set additionalKeywords to an array of UPPERCASE keywords
 * that also need quoting, e.g. in special functions.
 *
 * @param {string} id
 * @param {string[]} [additionalKeywords]
 * @return {string}
 */
function quoteIdIfRequired(id, additionalKeywords) {
  // Quote if required for CDL
  if (requiresQuotingForCdl(id, additionalKeywords || []))
    return quote(id);
  return id;
}

/**
 * Quote an annotation path, e.g. `@My.@Anno.Description` if necessary.
 * `anno` can start with `@` but is not required to be.
 * Example of an annotation path that needs to be quoted:
 * `@![ spaces in path ].@!["double quotes"]`.
 *
 * @param {string} anno
 * @returns {string}
 */
function quoteAnnotationPathIfRequired(anno) {
  return anno.split('.').map((segment) => {
    if (segment.startsWith('@'))
      return `@${quoteIdIfRequired(segment.slice(1))}`;
    return quoteIdIfRequired(segment);
  }).join('.');
}

/**
 * Quotes the identifier using CDL-style ![]-quotes.
 *
 * @param id
 * @returns {string}
 */
function quote(id) {
  return `![${id.replace(/]/g, ']]')}]`;
}

/**
 * Returns true if 'id' requires quotes for CDL, i.e. if 'id'
 * does not match the first part of the `Identifier` rule of `language.g4`
 * or if 'id' is a reserved keyword.
 *
 * Set additionalKeywords to an array of UPPERCASE keywords
 * that also need quoting, e.g. in special functions.
 *
 * @param {string} id
 * @param {string[]} [additionalKeywords]
 * @return {boolean}
 */
function requiresQuotingForCdl(id, additionalKeywords) {
  return !identifierRegex.test(id) ||
    keywords.cdl.includes(id.toUpperCase()) ||
    keywords.cdl_functions.includes(id.toUpperCase()) ||
    additionalKeywords.includes(id.toUpperCase());
}

const functionExpressionOperatorsRequireParentheses = [
  // Antlr rule 'condition', 'conditionAnd'
  'AND', 'OR',

  // Antlr rule 'conditionTerm'
  '=', '<>', '>', '>=', '<', '<=', '!=',
  // These are not forbidden, since they must be preceded by one of the comparators above.
  // 'any', 'some', 'all',

  'IS', 'IN', 'NOT', 'NULL', 'EXISTS',
  // Antlr rule 'predicate'
  'BETWEEN', 'LIKE', 'ESCAPE',
];

/**
 * Returns true if the given xpr-array can be rendered without parentheses
 * in a `fct(<xpr>)` expression such as `cast(<xpr> as Type)`.  We only need to
 * look at the first nesting level.  Otherwise, `renderExpr()` will already add parentheses.
 *
 * The list of `functionExpressionOperatorsRequireParentheses` was created by looking at
 * the `expression` Antlr rule.
 * Because of token-rewrites, there are functions that allow operators/tokens that would
 * require parentheses in other functions.  For example *regex functions allow `IN` but
 * if `IN` is used in other functions, it requires parentheses.  To allow for that case,
 * you can set `additionalAllowedKeywords` to list of tokens that are allowed.
 *
 * Note that this is more of a heuristic for "nicer" CDL output.  For example the
 * following snippet is parsable without parentheses:
 *   `cast( case when int > 1 then int else 0 end as Integer ),`
 * However, because it is a flat xpr-array, we see `>` and assume that it is not
 * a simple expression.
 *
 * @param {any[]} xpr
 * @param {string[]} additionalAllowedKeywords
 * @return {boolean}
 */
function isSimpleFunctionExpression(xpr, additionalAllowedKeywords = []) {
  return !xpr || xpr.every(val => typeof val !== 'string' ||
      (additionalAllowedKeywords.includes(val.toUpperCase()) ||
        !functionExpressionOperatorsRequireParentheses.includes(val.toUpperCase())));
}

/**
 * Special functions may have special parser rules, such as SAP HANA RegEx functions.
 * They allow certain keywords in their arguments.
 *
 * This function is used to determine if arguments need to be put in parentheses or not.
 * See {@link isSimpleFunctionExpression}.
 *
 * @param {string} funcName
 * @param {number} argumentIndex
 * @returns {string[]}
 */
function getKeywordsForSpecialFunctionArgument(funcName, argumentIndex) {
  const f = specialFunctions[funcName] && specialFunctions[funcName][argumentIndex];
  if (!f)
    return [];
  const additionalKeywords = [];
  if (f.intro)
    additionalKeywords.push(...f.intro);
  if (f.expr)
    additionalKeywords.push(...f.expr);
  if (f.separator)
    additionalKeywords.push(...f.separator);
  return additionalKeywords;
}

/**
 * @param {string[]} includes
 * @return {string}
 */
function renderIncludes(includes) {
  return ` : ${includes.map(name => quotePathIfRequired(name)).join(', ')}`;
}

/**
 * Render the given string.  Uses back-tick strings.
 * env is used for indentation of three-back-tick strings.
 *
 * @param str
 * @param env
 * @returns {string}
 */
function renderString(str, env) {
  if (isSimpleString(str))
    return `'${str.replace(/'/g, '\'\'')}'`;

  // We try to work similar to how JavaScript implements JSON.stringify.
  // JSON.stringify() also checks for unpaired unicode surrogates (see 25.5.2.2,
  // <https://tc39.es/ecma262/#sec-quotejsonstring>).
  str = escapeString(str, {
    $: '\\$',
    '`': '\\`',
    '\\': '\\\\',
    // Replace commonly known escape sequences for control characters
    // See lib/language/multiLineStringParser.js
    '\f': '\\f',
    '\v': '\\v',
    '\t': '\\t',
    '\b': '\\b',
    // If CR, LS, or PS appear, they have been encoded explicitly.  If we don't escape
    // them, a recompilation may yield different results because of newline normalization.
    '\r': '\\r',
    '\u{2028}': '\\u{2028}',
    '\u{2029}': '\\u{2029}',
    // Don't encode LF
    '\n': '\n',
    // JSON.stringify() is not required to escape all control characters, but if used, files may
    // be interpreted as binary.  Therefore, we replace them.
    // We exclude LF from this list (\n). Characters with "nice" escapes have been replaced above.
    control: hexEscape,
    unpairedSurrogate: hexEscape,
  });

  // Note: String is normalized, only \n is the line separator.
  const lines = str.split('\n');
  // We don't know whether a text block was used or not.  But if there
  // are more than three lines, text blocks with indentation "look nicer".
  // This value was chosen by personal taste.
  if (lines.length > 3) {
    str = lines.join(`\n${env.indent}`);
    return `\`\`\`\n${env.indent}${str}\n${env.indent}\`\`\``;
  }

  return `\`${str}\``;
}

/** @param {number} codePoint */
function hexEscape(codePoint) {
  const hex = codePoint.toString(16);
  return `\\u{${hex}}`;
}

/**
 * Returns true if the given string can be represented by using single quotes.
 * @param {string} str
 */
function isSimpleString(str) {
  // A single-line string allows everything except certain line separators/breaks.
  // See ANTLR grammar for specifics.
  // Furthermore, if control characters are used, we escape them,
  // as these are explicitly mentioned in the JSON spec (9):
  // <https://www.ecma-international.org/wp-content/uploads/ECMA-404_2nd_edition_december_2017.pdf>
  // On top, because (invalid) surrogate pairs need to be handled, we check for them as well.
  // v3: Not a simple string if ' (\u0027) is in string.
  return str === '' || (/^[^\u{0000}-\u{001F}\u2028\u2029]+$/u.test(str) &&
    !hasUnpairedUnicodeSurrogate(str));
}

/**
 * @typedef CdlRenderEnvironment Rendering environment used throughout the render process.
 *
 * @property {string}   indent Current indentation as a string, e.g. '  ' for two spaces.
 * @property {string[]} [path] CSN path to the current artifact
 * @property {string}   [artifactName] Name of the artifact - set in renderArtifact
 * @property {string}   [elementName] Name of the element being rendered - set in renderElement
 */

module.exports = { csnToCdl };
