// ANTLR4 grammar to generate Parser and Lexer for CDS-Language

// To be built the parser by hand, install Java, download the ANTLR4 tool, then
//   antlr4 -no-listener -o ../gen language.g4
// Alternatively, install Java, and use
//   npm run download && npm run gen
//
// To test the parser in the REPL, see file './lib/language/antlrParser.js'.

// This grammar is built according to the following guidelines:
//
//  * Do not express every syntactical restriction by grammar rules, and do
//    not define a grammar which allows every nonsense.  We might specify
//    syntactical restrictions in a certain form inside actions or semantic
//    predicates to have them directly available for IDE code completion.
//
//  * Keep the number of token types small.  Thus, do not define different
//    token types for things which are not distinguished in the parser.
//    Examples: one token type for numbers (have a check if you just want to
//    allow integers at certain places), one token type for non-quoted and
//    quoted identifiers.
//
//  * Keep the number of keywords as small as possible.  Thus, built-ins is a
//    topic for the semantic analysis, not the grammar.  Examples: no keywords
//    for built-in types or built-in SQL functions.  This also avoids noise in
//    the grammar and a huge/slow generated parser.
//  ┌─────────────────────────────────────────────────────────────────────────┐
//    For our adapted ANTLR error strategy concerning (non-reserved) keywords,
//    make sure to define non-reserved keywords between the lexer rule `Number`
//    and `Identifier`.  The latter must be the second last rule, the last is
//    `IllegalToken`.  Do not rename these three rules.  Add each new
//    non-reserved keyword to rule `ident`, but check for ambiguities!
//  └─────────────────────────────────────────────────────────────────────────┘
//
//  * Left-factor the parser grammar if the same initial part covers more than
//    one or two tokens.  ANTLRs adaptive predication allows to write "natural"
//    rules, but slows down parsing, especially if a long lookahead is needed
//    to solve an LLk ambiguity.  Therefore, try to avoid it in rules which are
//    called often.  Unfortunately, we cannot use ANTLR3's grammar and subrule
//    option 'k' (lookahead depth) anymore...  Therefore...
//  ┌─────────────────────────────────────────────────────────────────────────┐
//    Before each alternative with LL1 ambiguities (looking at the next token
//    is not enough for a decision), write a comment starting with `#ATN:`
//    which describes the ambiguity.  Additionally, put a comment `/* #ATN n
//    */` INSIDE an (`@after`) action of a rule if the corresponding function
//    in '../gen/languageParser.js' contains `n` occurrences of
//    `adaptivePredict` calls.  This is checked in 'test/testCompiler.js',
//    which also counts the total number of `adaptivePredict` occurrences.
//  └─────────────────────────────────────────────────────────────────────────┘
//
//  * For fast parsing and lower memory consumption, we use ANTLR4 with SLL
//    prediction-mode only.  That means that ANTLR does not use the actual call
//    stack when deciding which alternative to choose in a rule.  You might
//    need to copy a rule manually to get less ambiguities - this might be a
//    good idea anyway to avoid calls to `adaptivePredict`, see the rules
//    starting with `annotationAssignment_`.
//
//  * Factoring out a sub rule into a named rule influences the error recovery:
//    the parser tries to consume all tokens which are neither in the follow
//    set of loops and named rules.  So be careful.
//
//  * Do not use actions in the lexer.  Examples: de-quote string literals not
//    in the lexer, but in the parser; do not throw errors, but produce error
//    tokens if necessary.
//
//  * Use actions in the parser to produce a Augmented CSN model.  To have it
//    also in the case of syntax errors, produce it by adding sub-nodes to a
//    parent node, not by returning the nodes (the latter is fine for secondary
//    attachments).
//
//  * Action code should be a one-liner (<100 chars); usually, just one action
//    is called per alternative (plus the @after action which sets the AST
//    location).  For more complicated code, define a method in file
//    './genericAntlrParser.js'.
//
//  * Do not write lexer rules for tokens like ';', use ';' directly in the
//    parser rule.  Advantage: better error messages; taste: more or less
//    readable grammar; disadvantage: debugging in generated code.
//
//  * Use all-upper token names for keywords (e.g. CONTEXT), capitalized ones
//    (e.g. Number) for others - EOF is the exception (is ANTLR-builtin).
//    Remember: parser rule names in ANTLR start with a lower-case letter.
//
//  * No useless parentheses in the grammar.  There are just two binary grammar
//    operators: alternative (`|`) and sequence.  It should not be too hard to
//    remember that sequence binds stronger than alternative.
//
//  * Use the following indentation rules:
//     - rule header: indentation 0 + 2* parentheses/braces depth
//     - rule colon (':' separating header & body): 2
//     - rule body: 4 + 2* parentheses/braces depth, -2 for certain chars at
//       beginning of line: '|', ')', ']' or '}'
//     - inside action: as for the action language, e.g. function argument
//       alignment
//     - rule semicolon (';' ending body, before exceptions): 2
//     - rule exceptions (not used): 2 + 2* parentheses/braces depth

// Some practical info:
//
//  * The end location for the match of a rule is just available in the @after
//    action.  Use method `attachLocation` there on the produced AST.
//
//  * Be careful with the rule names: the methods in antlr4.Parser, the methods
//    in `./antlrParser' and the parser rule names share the same namespace.
//    Any shadowing lead to an exception when running 'test/testCompiler.js'.
//
//  * Be careful with names for rule arguments, returns, locals and rule
//    reference labels: the names `parser`, `parent` and `invokingState` cannot
//    be used (these are added by the generator).
//
//  * The ANTLR error "missing attribute access on rule reference c in $c" can
//    be solved with using $ctx.c instead of $c
//
//  * If you want to set a property starting with '$' like $syntax, use
//    obj['$'+'syntax'] as the ANTLR tool would replace $syntax by $ctx.syntax

grammar language;
options {
  language = JavaScript;
  superClass = genericAntlrParser;
}
tokens {
  VIRTUAL,                      // used with setLocalToken()
  OVER,                         // used with setLocalTokenIfBefore()
  HelperToken1,                 // used with setLocalToken(), does not appear in messages
  HelperToken2,                 // used with setLocalToken(), does not appear in messages
  HideAlternatives,             // hide alternative tokens (no token seq!)
  GenericExpr,                  // via token rewriting according to specialFunctions
  GenericSeparator,             // via token rewriting according to specialFunctions
  GenericIntro,                 // via token rewriting according to specialFunctions
  DOTbeforeBRACE,               // via token rewrite
  COMPOSITIONofBRACE            // via token rewrite in rule typeAssociationBase
}

// Top-Level -----------------------------------------------------------------

start returns [ source ] locals [ _sync = 'recover' ]
@init{ $source = this.createSource(); }
  :
    usingDeclaration[$source]*
    (
      namespaceDeclaration[$source]
      ( usingDeclaration[$source] | artifactDef[$source] )*
    |
      artifactDef[$source]
      ( usingDeclaration[$source] | artifactDef[$source] )*
    )?
    EOF
  ;

queryEOF returns [ query ]
  :
    q=queryExpression { $query = $q.query; } EOF
  ;

conditionEOF returns [ cond ]
  :
    c=condition { $cond = $c.cond; } EOF
  ;

namespaceDeclaration[ source ] locals[ decl = {} ]
@after { $source.namespace = this.attachLocation($decl); }
  :
    NAMESPACE simplePath[ $decl, 'Namespace' ] ';'
  ;

usingDeclaration[ source ] locals[ decl = {} ]
@after { this.attachLocation($decl); }
  :
    { $decl.location = this.startLocation(); }
    USING
    (
      FROM str=String
       { $source.dependencies.push( this.quotedLiteral( $str, 'string' ) ); }
    |
      path=externalPath
      { this.addItem( $decl, $source, 'usings', 'using' );; $decl.extern = $path.extern; }
      ( AS name=ident['Using'] { $decl.name = $name.id; }
      | { this.classifyImplicitName( 'Using' ); }
      )
      ( FROM str=String
        { $source.dependencies.push( $decl.fileDep = this.quotedLiteral( $str, 'string' ) );         }
      )?
    |
      { this.addItem( $decl, $source, 'usings', 'using' ); }
      // We could just create "independent" USING declaration, but if we want
      // to have some check in the future whether the external artifacts are
      // really in the FROM source...
      '{' { $decl.usings = this.createArray(); }
      innerUsing[ $decl ]
      ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
        innerUsing[ $decl ] )*
      '}' { this.finalizeDictOrArray( $decl.usings ); }
      ( FROM str=String
        { $source.dependencies.push( $decl.fileDep = this.quotedLiteral( $str, 'string' ) ); }
      )?
    )
    ';'
  ;

innerUsing[ using ] locals[ decl = {} ]
@after { this.attachLocation($decl); }
  :
    { $decl.location = this.startLocation(); }
    path=externalPath
    { this.addItem( $decl, $using, 'usings', 'using' );; $decl.extern = $path.extern; }
    ( AS name=ident['Using'] { $decl.name = $name.id; }
    | { this.classifyImplicitName( 'Using' ); }
    )
  ;

externalPath returns [ extern = {} ]
  :
    simplePath[ $extern, 'global' ]
  ;

// We have two versions of the annotation assignment rule, because we do not
// want to let the ambiguity in select items (solution: "either" possibility)
// creep into all annotation assignments:
//   view V(p) as select from E {    // either: anno value "ref p", select item -x
//     @anno :p - x as x;            // or: anno value true, select item :p-x
//   }

annotationAssignment_1[ art ] locals[ assignment = { name: {} } ]
@after { this.assignAnnotation( $art, $assignment ); }
  :
    annotationPath[ $assignment.name, 'anno' ]
    annotationPathVariant[ $assignment.name ]?
    (
      ':' { this.meltKeywordToIdentifier(true); } // allow path as anno value start with reserved
      val=annoValue[ $assignment ]
    )?
  ;

annotationAssignment_paren[ art ]
  :
    '('
    // allow completely useless `@()` with a warning, do not offer it for completion
    {
      this.meltKeywordToIdentifier();
      if (this.isStraightBefore(')')) {
        // TODO: or should we simple accept this without warning? (but still no CC)
        this.warning( 'syntax-unexpected-right-paren',
                      this.tokenLocation( this.getCurrentToken() ),
                      { offending: "')'", expecting: ['Identifier'], code: '@()' },
                      'Unexpected $(OFFENDING), expecting $(EXPECTING); ignoring $(CODE)' );
        this.matchWildcard();   // we know it is the ')' - we do not reach the final match
        return $ctx;
      }
    }
    annotationAssignment_1[ $art ]
    ( ','
      {
        this.meltKeywordToIdentifier();
        if (this.isStraightBefore(')')) break; // allow ',' before ')'
      }
      annotationAssignment_1[ $art ]
    )*
    ')'
  ;

annotationAssignment_fix[ art ] locals[ assignment ]
// value outside @(...)
@after {
  if ($assignment) {
    this.assignAnnotation( $art, $assignment );
    this.docComment( $art );
  }
} :
    '@'
    (
      annotationAssignment_paren[ $art ]
    |
      { $assignment = { name: {} }; }
      annotationPath[ $assignment.name, 'anno' ]
      annotationPathVariant[ $assignment.name ]?
      { this.warnIfColonFollows( $assignment ); }
    )
  ;

annotationAssignment_ll1[ art ] locals[ assignment ]
@after {
  if ($assignment) {
    this.assignAnnotation( $art, $assignment );
    this.docComment( $art );
  }
} :
    '@'
    (
      annotationAssignment_paren[ $art ]
    |
      { $assignment = { name: {} }; }
      annotationPath[ $assignment.name, 'anno' ]
      annotationPathVariant[ $assignment.name ]?
      (
        ':' { this.meltKeywordToIdentifier(true); } // allow path as anno value start with reserved
        val=annoValue[ $assignment ]
      )?
    )
  ;

// Has previously used ATN, now via local token rewrite
annotationAssignment_atn[ art ] locals[ assignment ]
@after {
  if ($assignment) {
    this.assignAnnotation( $art, $assignment );
    this.docComment( $art );
  }
} :
    '@'
    (
      annotationAssignment_paren[ $art ]
    |
      { $assignment = { name: {} }; }
      annotationPath[ $assignment.name, 'anno' ]
      // '#' is in the follow set of this rule, as it is used in rule "selectItemDef"
      // before an "expression" which can start with a '#' for an enum value
      // -> used to introduce variant name if and only if in same line as previous token
      { this.setLocalToken( '#', 'HelperToken1', null, true ); }
      (
        HelperToken1 { this.meltKeywordToIdentifier(); }
        variant=ident['variant'] { $assignment.name.variant = $variant.id; }
      )?
      // ':' is in the follow set of this rule, as it is used in rule "selectItemDef"
      // before an "expression" which can start with a ':' for a parameter reference
      // -> used to introduce assignment value if and only if in same line as previous token
      { this.setLocalToken( ':', 'HelperToken2', null, true ); }
      ( HelperToken2                        // ':'
        { this.meltKeywordToIdentifier(true); } // allow path as anno value start with reserved
        (
          val=annoValueBase[ $assignment ]
        |
          at='@'? annotationPath[ $assignment, 'ref', $at ]
          { this.setLocalToken( '#', 'HelperToken1', null, true ); } // see above
          (
            HelperToken1 { this.meltKeywordToIdentifier(); }
            variant=ident['variant'] { $assignment.variant = $variant.id; }
          )?
        )
      )?
    )
  ;

// Main artifact definitions -------------------------------------------------

requiredSemi
  : ';'
  | { return $ctx; }            // do not actually parse the closing brace
    '}'
  ;

optionalSemi
  : { this.noAssignmentInSameLine(); } // issue warning for } @Anno \n? NextDef
    ';'?
  ;

artifactDef[ outer, defOnly = false ] locals[ art = {} ] // cannot use `parent` as parameter name!
@after{ /* #ATN 1 */ }
  :
    { $art.location = this.startLocation(); this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      DEFINE?
      ( contextDef[ $art, $outer, defOnly ]
      | entityDef[ $art, $outer ]
      | typeDef[ $art, $outer ]
      | aspectDef[ $art, $outer ]
      | annotationDef[ $art, $outer ]
      | viewDef[ $art, $outer ]
      | eventDef[ $art, $outer ]
      | actionFunctionMainDef[ $art, $outer ]
      )
    |
      extend=EXTEND
      { if (defOnly)
          this.error( 'syntax-extend-context', $extend,
                      { code: 'EXTEND artifact', kind: defOnly },
                      'No $(CODE) within $(KIND) extensions' );
        if (!$outer.extensions) $outer.extensions = [];
      }
      // #ATN: EXTEND elem, while CONTEXT, ENTITY etc are not reserved
      ( extendContext[ $art, $outer ]
      | extendEntity[ $art, $outer ] // or aspect
      | extendProjection[ $art, $outer ]
      | extendType[ $art, $outer ]
      // Streamlined Syntax
      | extendArtifact[ $art, $outer ]
      )
    |
      annotate=ANNOTATE
      { if (defOnly)
          this.error( 'syntax-extend-context', $annotate,
                      { code: 'ANNOTATE artifact', kind: defOnly },
                      'No $(CODE) within $(KIND) extensions' );
        if (!$outer.extensions) $outer.extensions = [];
        this.meltKeywordToIdentifier();
      }
      annotateArtifact[ $art, $outer ] // not kind-specific
    )
  ;

contextDef[ art, outer, defOnly = false ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    ( CONTEXT | service=SERVICE ) simplePath[ $name, $service ? 'Service' : 'Context' ]
    { this.addDef( $art, $outer, 'artifacts', $service ? 'service' : 'context', $name );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    (
      '{' { $art.artifacts = this.createDict(); $art.extensions = []; }
      artifactDef[ $art, defOnly ]*
      '}' { this.finalizeDictOrArray( $art.artifacts ); }
      optionalSemi
    |
      requiredSemi
    )
  ;

extendContext[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    ( CONTEXT { $art.expectedKind = 'context'; } | service=SERVICE { $art.expectedKind = 'service'; })
    simplePath[ $name, $service ? 'Service' : 'Context' ] // not 'Extend' here
    { $art.name = $name; this.addItem( $art, $outer, 'extensions', 'extend' ); }
    ( WITH { this.noSemicolonHere(); } )?
    { this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      '{' { $art.artifacts = this.createDict(); }
      artifactDef[ $art, $service ? 'SERVICE' : 'CONTEXT' ]*
      '}' { this.finalizeDictOrArray( $art.artifacts ); }
      optionalSemi
    |
      requiredSemi
    )
  ;

entityDef[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    ENTITY simplePath[ $name, 'Entity' ]
    { this.addDef( $art, $outer, 'artifacts', 'entity', $name );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    parameterListDef[ $art ]?
    (
      ( ':'
        includeRef[ $art ]
        ( ',' { if (this.isStraightBefore('{')) break; } // allow ',' before '{' // }}
          includeRef[ $art ]
        )*
      )?
      '{' { $art.elements = this.createDict(); }
      elementDef[ $art ]*
      '}' { this.finalizeDictOrArray( $art.elements ); }
      // TODO: action definitions in a specific section?
      (
        ACTIONS '{' { $art.actions = this.createDict(); }
        actionFunctionDef[ $art ]*
        '}' { this.finalizeDictOrArray( $art.actions ); }
      )?
      optionalSemi
    |
      AS
      ( qe=queryExpression
        { $art.query = $qe.query; $art['$'+'syntax'] = 'entity' }
        (
          ACTIONS '{' { $art.actions = this.createDict(); }
          actionFunctionDef[ $art ]*
          '}' { this.finalizeDictOrArray( $art.actions ); }
          optionalSemi
        | requiredSemi
        )
      | qp=projectionSpec
        { $art.query = $qp.query; $art['$'+'syntax'] = 'projection'; }
        projectionClauses[ $qp.query ]
        (
          ACTIONS '{' { $art.actions = this.createDict(); }
          actionFunctionDef[ $art ]*
          '}' { this.finalizeDictOrArray( $art.actions ); }
        )?
        optionalSemi            // TODO: not fully correct without columns or excluding
      )
    )
  ;

projectionSpec returns[ query ] locals[ src ]
@after { this.attachLocation($query); }
  :
    proj=PROJECTION ON               // FIXME: First draft only, details unclear/unspecified
    // now a simplified `tableTerm`:
    {
      $src = { path: [], scope: 0 };
      $query = { op: this.valueWithTokenLocation( 'SELECT', $proj ), from: $src, location: this.startLocation() };
    }
    fromPath[ $src, 'artref']
    ( ':'
      { $src.scope = $src.path.length; }
      fromPath[ $src, 'ref']
    )?
    ( AS aliasName=ident['FromAlias'] { $src.name = $aliasName.id } )?
    // ANTLR errors are better if we use ( A )? instead of ( A | ):
    { if (!$src.name) this.classifyImplicitName( $src.scope ? 'FromAlias' : 'Without' ); }
    bracedSelectItemListDef[ $query, 'columns' ]?
    excludingClause[ $query ]?
  ;

projectionClauses[ query ]
@after { this.attachLocation($query); }
  :
    ( WHERE cond=condition { $query.where = $cond.cond; } )?
    (
      GROUP BY
      e1=expression { $query.groupBy = [ $e1.expr ]; }
      ( ',' en=expression { $query.groupBy.push( $en.expr ); } )*
    )?
    ( HAVING having=condition { $query.having = $having.cond; } )?
    ( ob=orderByClause[ $query ] { $query = $ob.query; } ) ?
    ( lc=limitClause[ $query ]   { $query = $lc.query; } ) ?
  ;

excludingClause[ query ]
  :
    // syntax is less than ideal - EXCLUDING is only useful for `*` - with
    // this syntax, people wonder what happens with explicit select items
    EXCLUDING '{' { $query.excludingDict = this.createDict(); }
    projectionExclusion[ $query ]
    ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
      projectionExclusion[ $query ]
    )*
    '}' { this.finalizeDictOrArray( $query.excludingDict ); }
  ;

projectionExclusion[ outer ] locals[ art = {} ]
@after { this.attachLocation($art); }
  :
    name=ident['ref']
    { this.addDef( $art, $outer, 'excludingDict', '', $name.id ); }
  ;

// also used for aspect
extendEntity[ art, outer ] locals[ name = {} ]
@after { /* #ATN 1 */ this.attachLocation( $art ); }
  :
    kind=(ASPECT | ENTITY) simplePath[ $name, 'Extend' ]
    { $art.expectedKind = $kind.text.toLowerCase(); $art.name = $name;
      this.addItem( $art, $outer, 'extensions', 'extend' );
    }
    (
      WITH { this.noSemicolonHere(); this.docComment( $art ); }
      annotationAssignment_ll1[ $art ]*
      // ATN: the ref can start with ACTIONS
      (
        includeRef[ $art ] ( ',' includeRef[ $art ] )*
        requiredSemi
      |
        extendForEntity[ $art ]
      )
    |
      { this.docComment( $art ); }
      annotationAssignment_ll1[ $art ]*
      extendForEntity[ $art ]
    )
  ;

extendForEntity[ art ]
  :
    '{' { $art.elements = this.createDict(); }
    elementDefOrExtend[ $art ]*
    '}' { this.finalizeDictOrArray( $art.elements ); }
    (
      ACTIONS '{' { $art.actions = this.createDict(); }
      actionFunctionDef[ $art ]*
      '}' { this.finalizeDictOrArray( $art.actions ); }
    )?
    optionalSemi
  |
    ACTIONS '{' { $art.actions = this.createDict(); }
    actionFunctionDef[ $art ]*
    '}' { this.finalizeDictOrArray( $art.actions ); }
    optionalSemi
  |
    requiredSemi
  ;

extendProjection[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    expected=PROJECTION simplePath[ $name, 'Extend' ]
    { $art.expectedKind = 'entity'; $art.name = $name;
      this.addItem( $art, $outer, 'extensions', 'extend' );
    }
    ( WITH { this.noSemicolonHere(); } )?
    { this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      '{' { $art.columns = []; }
      (
        selectItemDef[ $art.columns ]
        ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
          selectItemDef[ $art.columns ]
        )*
      )?
      '}'
      (
        ACTIONS '{' { $art.actions = this.createDict(); }
        actionFunctionDef[ $art ]*
        '}' { this.finalizeDictOrArray( $art.actions ); }
      )?
      optionalSemi
    |
      ACTIONS '{' { $art.actions = this.createDict(); }
      actionFunctionDef[ $art ]*
      '}' { this.finalizeDictOrArray( $art.actions ); }
      optionalSemi
    |
      requiredSemi
    )
  ;

// TODO: no action extension?
actionFunctionDef[ outer ] locals[ art = {} ]
@after { this.attachLocation( $art ); }
  :
    { $art.location = this.startLocation();; this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      ACTION name=ident['BoundAction']
      { this.addDef( $art, $outer, 'actions', 'action', $name.id );
        this.docComment( $art ); }
      annotationAssignment_fix[ $art ]*
      parameterListDef[ $art ]
      ( returnTypeSpec[ $art ] | requiredSemi )
    |
      FUNCTION name=ident['BoundAction']
      { this.addDef( $art, $outer, 'actions', 'function', $name.id );
        this.docComment( $art ); }
      annotationAssignment_fix[ $art ]*
      parameterListDef[ $art ]
      returnTypeSpec[ $art ]
    )
  ;

actionFunctionMainDef[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    ACTION simplePath[ $name, 'Action' ]
    { this.addDef( $art, $outer, 'artifacts', 'action', $name );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    parameterListDef[ $art ]
    ( returnTypeSpec[ $art ] | requiredSemi )
  |
    FUNCTION simplePath[ $name, 'Action' ]
    { this.addDef( $art, $outer, 'artifacts', 'function', $name );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    parameterListDef[ $art ]
    returnTypeSpec[ $art ]
  ;

eventDef[ art, outer ] locals[ name = {} ]
@after { /* #ATN 1 */ this.attachLocation( $art ); }
  :
    EVENT simplePath[ $name, 'Event' ]
    { this.addDef( $art, $outer, 'artifacts', 'event', $name );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    (
      typeStruct[ $art ] optionalSemi
    |
      ':'
      // #ATN: includeRef can be / start with PROJECTION
      (
        { $art.type = {}; }
        simplePath[ $art.type, 'artref' ]
        (
          { $art.includes = [ $art.type ]; delete $art.type; }
          ( ',' { if (this.isStraightBefore('{')) break; } // allow ',' before '{' // }}
            includeRef[ $art ]
          )*
          typeStruct[ $art ] optionalSemi
        |
          { this.docComment( $art ); }
          annotationAssignment_ll1[ $art ]*
          requiredSemi
        )
      |
        typeStruct[ $art ] optionalSemi
      |
        qp=projectionSpec
        { $art.query = $qp.query; $art['$'+'syntax'] = 'projection'; }
        optionalSemi // TODO: not fully correct without columns or excluding

      )
    )
  ;

aspectDef[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    ( ASPECT | ( abs=ABSTRACT | HideAlternatives ) ent=ENTITY )
    simplePath[ $name, 'Type' ]
    { this.addDef( $art, $outer, 'artifacts', 'aspect', $name );
      // backends do not like ['$'+'syntax']: ($ent ? 'entity' : 'aspect')
      if ($ent)
        this.warning( 'syntax-deprecated-abstract', this.tokenLocation( $abs, $ent ) );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    ( ':'
      (
        includeRef[ $art ]
        ( ',' { if (this.isStraightBefore('{')) break; } // allow ',' before '{' // }}
          includeRef[ $art ]
        )*
      )?
    )?
    ( // `aspect MyAspect {};`
      '{' { $art.elements = this.createDict(); }
      ( elementDef[ $art ]* )
      '}' { this.finalizeDictOrArray( $art.elements ); }
      // TODO: action definitions in a specific section?
      (
        ACTIONS '{' { $art.actions = this.createDict(); }
        actionFunctionDef[ $art ]*
        '}' { this.finalizeDictOrArray( $art.actions ); }
      )?
      optionalSemi
    | // `aspect MyAspect;`, e.g. for annotation aspects.
      { this.aspectWithoutElements( $art ); }
      requiredSemi
    )
  ;

typeDef[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    TYPE simplePath[ $name, 'Type' ]
    { this.addDef( $art, $outer, 'artifacts', 'type', $name );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    typeSpecSemi[ $art ]
  ;

extendType[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    TYPE simplePath[ $name, 'Extend' ]
    { $art.expectedKind = 'type'; $art.name = $name;
      this.addItem( $art, $outer, 'extensions', 'extend' );
    }
    // extendWithOptElementsOrType + includeRef:
    (
      extendWithOptElementsNoWith[ art ]
    |
      WITH { this.noSemicolonHere(); this.docComment( $art ); }
      annotationAssignment_ll1[ $art ]*
      (
        '{' { $art.elements = this.createDict(); }
        elementDefOrExtend[ $art ]*
        '}' { this.finalizeDictOrArray( $art.elements ); }
        { this.checkExtensionDict( $art.elements ); }
        optionalSemi
      |
        // extend type|element Art with (length: 10);
        typeNamedArgList[ $art ]
        requiredSemi
      |
        requiredSemi
      |
        includeRef[ $art ] ( ',' includeRef[ $art ] )*
        requiredSemi
      )
    )
  ;

annotationDef[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    annotation=ANNOTATION simplePath[ $name, 'AnnoDef' ]
    { if ($outer.kind !== 'source') { // this is a syntax restriction to avoid confusion
        this.error( 'syntax-unexpected-vocabulary', $annotation, { '#': $outer.kind } );
        $art = {}; }
      else {
        if (!$outer.vocabularies) $outer.vocabularies = Object.create(null);
        this.addDef( $art, $outer, 'vocabularies', 'annotation', $name );
      }
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    typeSpecSemi[ $art ] // also 'includes'...
  ;

extendArtifact[ art, outer ] locals[ name = {}, elemName = {} ]
@after{ /* #ATN 1 */ this.attachLocation( $art ); }
  :
    simplePath[ $name, 'Extend' ]
    (
      ':' simplePath[ $elemName, 'Element']
      { this.addExtension( $art, $outer, 'extend', $name, $elemName.path ); }
      extendWithOptElementsOrType[ art ]
    |
      { this.addExtension( $art, $outer, 'extend', $name ); }
      extendWithOptElementsNoWith[ art ]
    |
      { this.addExtension( $art, $outer, 'extend', $name ); }
      WITH { this.noSemicolonHere(); this.docComment( $art ); }
      annotationAssignment_ll1[ $art ]*
      // #ATN: ELEMENTS, ENUM, DEFINITIONS, COLUMNS, ACTIONS are not reserved and
      // could be includeRef
      (
        // all the alternatives from `extendWithOptElementsOrType` --------------
        '{' { $art.elements = this.createDict(); }
        elementDefOrExtend[ $art ]*
        '}' { this.finalizeDictOrArray( $art.elements ); }
        { this.checkExtensionDict( $art.elements ); }
        optionalSemi
      |
        requiredSemi
      |
        ELEMENTS '{' { $art.elements = this.createDict(); }
        elementDefOrExtend[ $art ]*
        '}' { this.finalizeDictOrArray( $art.elements ); }
        { this.checkExtensionDict( $art.elements ); }
        optionalSemi
      |
        ENUM '{' { $art.enum = this.createDict(); }
        enumSymbolDef[ $art ]*  // TODO: no EXTEND in enum? (ok, would just allow annos)
        '}' { this.finalizeDictOrArray( $art.enum ); }
        optionalSemi
      |
        // extend Art with (length: 10);
        // `with` is required, or we could have `extend String(length:10);`.
        typeNamedArgList[ $art ]
        requiredSemi
      |
        // extension alternatives for main definitions --------------------------
        includeRef[ $art ] ( ',' includeRef[ $art ] )*
        requiredSemi
      |
        DEFINITIONS
        '{' { $art.artifacts = this.createDict(); }
        artifactDef[ $art, true ]*
        '}' { this.finalizeDictOrArray( $art.artifacts ); }
        optionalSemi
      |
        COLUMNS
        '{' { $art.columns = []; }
        (
          selectItemDef[ $art.columns ]
          ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
            selectItemDef[ $art.columns ]
          )*
        )?
        '}'
        optionalSemi
      |
        ACTIONS '{' { $art.actions = this.createDict(); }
        actionFunctionDef[ $art ]* // TODO: no EXTEND in actions? (ok, would just allow annos)
        '}' { this.finalizeDictOrArray( $art.actions ); }
        optionalSemi
      )
    )
  ;

extendWithOptElementsOrType[ art ]
  :
    extendWithOptElementsNoWith[ art ]
  |
    WITH { this.noSemicolonHere(); this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      '{' { $art.elements = this.createDict(); }
      elementDefOrExtend[ $art ]*
      '}' { this.finalizeDictOrArray( $art.elements ); }
      { this.checkExtensionDict( $art.elements ); }
      optionalSemi
    |
      ELEMENTS '{' { $art.elements = this.createDict(); }
      elementDefOrExtend[ $art ]*
      '}' { this.finalizeDictOrArray( $art.elements ); }
      { this.checkExtensionDict( $art.elements ); }
      optionalSemi
    |
      ENUM '{' { $art.enum = this.createDict(); }
      enumSymbolDef[ $art ]*  // TODO: no EXTEND in enum? (ok, would just allow annos)
      '}' { this.finalizeDictOrArray( $art.enum ); }
      optionalSemi
    |
      // extend type|element Art with (length: 10);
      typeNamedArgList[ $art ]
      requiredSemi
    |
      requiredSemi
    )
  ;

extendWithOptElementsNoWith[ art ]
  :
    { this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      '{' { $art.elements = this.createDict(); }
      elementDefOrExtend[ $art ]*
      '}' { this.finalizeDictOrArray( $art.elements ); }
      { this.checkExtensionDict( $art.elements ); }
      optionalSemi
    |
      requiredSemi
    )
  ;

annotateArtifact[ art, outer ] locals[ name = {}, elemName = {} ]
@after { this.attachLocation( $art ); }
  :
    simplePath[ $name, 'Annotate' ]
    ( ':' simplePath[ $elemName, 'Element'] )?
    { this.addExtension( $art, $outer, 'annotate', $name, $elemName.path ); }
    ( WITH { this.noSemicolonHere(); } )?
    { this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      '{' { $art.elements = this.createDict(); }
      annotateElement[ $art ]*
      '}' { this.finalizeDictOrArray( $art.elements ); }
      { this.checkExtensionDict( $art.elements ); }
      (
        ACTIONS
        '{' { $art.actions = this.createDict(); }
        annotateAction[ $art ]*
        '}' { this.finalizeDictOrArray( $art.actions ); }
      { this.checkExtensionDict( $art.actions ); }
      )?
      optionalSemi
    |
      ACTIONS
      '{' { $art.actions = this.createDict(); }
      annotateAction[ $art ]*
      '}' { this.finalizeDictOrArray( $art.actions ); }
      { this.checkExtensionDict( $art.actions ); }
      optionalSemi
    |
      '(' { $art.params = this.createDict(); }
      annotateParam[ $art ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        annotateParam[ $art ]
      )*
      ')' { this.finalizeDictOrArray( $art.params ); }
      { this.checkExtensionDict( $art.params ); }
      (
        RETURNS { $art['$'+'syntax'] = 'returns'; }
        '{' { $art.elements = this.createDict(); }
        annotateElement[ $art ]*
        '}' { this.finalizeDictOrArray( $art.elements ); }
      { this.checkExtensionDict( $art.elements ); }
        optionalSemi
      |
        requiredSemi
      )
    |
      RETURNS { $art['$'+'syntax'] = 'returns'; }
      '{' { $art.elements = this.createDict(); }
      annotateElement[ $art ]*
      '}' { this.finalizeDictOrArray( $art.elements ); }
      { this.checkExtensionDict( $art.elements ); }
      optionalSemi

    |
      requiredSemi
    )
  ;

annotateElement[ outer ] locals[ art = {} ]
@after{ this.attachLocation( $art ); }
  :
    { $art.location = this.startLocation();; this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    name=ident['Element']
    { this.addDef( $art, $outer, 'elements', 'annotate', $name.id );
      this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      '{' { $art.elements = this.createDict(); }
      annotateElement[ $art ]*
      '}' { this.finalizeDictOrArray( $art.elements ); }
      { this.checkExtensionDict( $art.elements ); }
      optionalSemi
    |
      requiredSemi
    )
  ;

annotateAction [ outer ] locals [ art = {} ]
@after{ this.attachLocation( $art ); }
  :
    { $art.location = this.startLocation();; this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    name=ident['BoundAction']
    { this.addDef( $art, $outer, 'actions', 'annotate', $name.id );
      this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    (
      '(' { $art.params = this.createDict(); }
      annotateParam[ $art ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        annotateParam[ $art ]
      )*
      ')' { this.finalizeDictOrArray( $art.params ); }
      { this.checkExtensionDict( $art.params ); }
    )?
    (
      RETURNS '{' { $art.elements = this.createDict(); }
      annotateElement[ $art ]*
      '}' { this.finalizeDictOrArray( $art.elements ); }
      { this.checkExtensionDict( $art.elements ); }
      optionalSemi
    |
      requiredSemi
    )
  ;

annotateParam [ outer ] locals [ art = {} ]
@after{ this.attachLocation( $art ); }
  :
    { $art.location = this.startLocation();; this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    param=ident['Param']
    { this.addDef( $art, $outer, 'params', 'annotate', $param.id );
      this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
  ;

// Element definition and its helpers ----------------------------------------

enumSymbolDef[ outer ] locals[ art = {} ]
@after { this.attachLocation( $art ); }
  :
    { $art.location = this.startLocation();; this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    name=ident['Enum']
    { this.addDef( $art, $outer, 'enum', 'enum', $name.id );
      this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    ( '='
      { this.excludeExpected( ['Boolean', 'QuotedLiteral', "'#'", 'NULL'] ); }
      (
        val=literalValue
        { $art.value = $val.val; }
      |
        ( plus='+' | min='-' ) num=Number
        { $art.value = this.numberLiteral( $num, $plus||$min ); }
      )
      { this.docComment( $art ); }
      annotationAssignment_ll1[ $art ]*
    )?
    requiredSemi
  ;

defaultValue[ art ] locals[ elem, elements = {} ]
  :
  // TODO: We may support structured default values here.
  DEFAULT expr=expression { $art.default = $expr.expr; }
  ;

elementDefOrExtend[ outer ] locals[ art = {} ]
@after { /* #ATN 1 */ }  // if ($art) this.attachLocation( $art ); }
  :
    { $art.location = this.startLocation();; this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    // #ATN: element name for definition can be EXTEND
    (
      EXTEND
      extendElement[ $art, $outer ]
    |
      elementDefInner[ $art, $outer, true ]
    )
  ;

elementDef[ outer ] locals[ $art = {} ]
  :
    { $art.location = this.startLocation();; this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    elementDefInner[ $art, $outer, false ]
  ;

// Actually, this is a subset if elementDefInner...
// TODO: the corresponding restrictions must also be checked in the core
// compiler, as the mixin element could come via CSN
mixinElementDef[ outer ] locals[ art = {} ]
@after { /* #ATN 2 */ this.attachLocation($art); }
  :
    name=ident['Mixin']
    { this.addDef( $art, $outer, 'mixin', 'mixin', $name.id ); }
    (
      ':'
      // #ATN: referenced type name can be ASSOCIATION or COMPOSITION
      (
        typeAssociationBase[ $art, false ]
        // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
        ( typeToMany[ $art ] | typeToOne[ $art ] | simplePath[ $art.target, 'artref' ] )
        typeAssociationCont[ $art ]?
      |
        typeRefOptArgs[ $art ]
        ( as='=' expression
          { this.error( 'syntax-unsupported-calc-field', $as ); }
        )?
      )
    |
      as='=' expression
      { this.error( 'syntax-unsupported-calc-field', $as ); }
    )
    requiredSemi
  ;

elementDefInner[ art, outer, allowEq ]
@after{ /* #ATN 5 */ this.attachLocation( $art ); }
  :
    // TODO: it would be excellent to remove ELEMENT...
    // or have a special ident rule without the ELEMENT
    // Reason: it would be good for error recovery to start a major block without LL1 ambiguity
    // VIRTUAL is keyword, except if before the following tokens texts:
    { this.setLocalToken( 'VIRTUAL', 'VIRTUAL', /^[:{@=}]$/ ); }
    ( virtual=VIRTUAL { $art.virtual = this.valueWithTokenLocation( true, $virtual ); } )?
    ( key=KEY { $art.key = this.valueWithTokenLocation( true, $key ); } )?
    // #ATN: element name can be MASKED or ELEMENT (2x)
    ( masked=MASKED
      {
        $art.masked = this.valueWithTokenLocation( true, $masked ) ;
        this.message( 'syntax-unsupported-masked', $masked, { keyword: 'masked' } );
      }
    )?
    // TODO: order?
    ELEMENT?
    name=ident['Element']
    { this.addDef( $art, $outer, 'elements', 'element', $name.id );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    // TODO: we can think of making the typeSpec optional and do checks instead:
    // type optional with '=', type required otherwise
    (
      typeStruct[ $art ]
      ( nullability[ $art ]
        requiredSemi
      | optionalSemi            // NOT and NULL are reserved...
      )
    |
      ':'
      // #ATN: referenced type name can be ASSOCIATION or ARRAY or TYPE or LOCALIZED
      (
        typeStruct[ $art ]
        nullability[ $art ]?
        requiredSemi
      |
        typeAssociationBase[ $art, true ]
        // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
        (
          typeStruct[ $art.target, true ] optionalSemi
        |
          one=ONE
          { this.setMaxCardinality( $art, $one, this.numberLiteral( $one, null, '1' ) ); }
          typeCompoStruct[ $art.target ] optionalSemi
        |
          many=MANY
          { this.setMaxCardinality( $art, $many, { literal: 'string', val: '*' } ); }
          typeCompoStruct[ $art.target ] optionalSemi
        |
          // we do not support `Composition of many { e }` - ambiguity ad-hoc target versus foreign keys!
          typeToMany[ $art ] typeAssociationElementCont[ $art ]
        |
          typeToOne[ $art ] typeAssociationElementCont[ $art ]
        |
          simplePath[ $art.target, 'artref' ] typeAssociationElementCont[ $art ]
        )
      |
        (
          array=ARRAY of=OF
          { $art.items = { location: this.tokenLocation( $array, $of ) }; }
        | many=MANY
          { $art.items = { location: this.tokenLocation( $many ) };}
        )
        // #ATN: typeRefOptArgs can start with TYPE
        ( typeStruct[ $art.items ]
          nullability[ $art.items ]?
        | typeTypeOf[ $art.items ]
          nullability[ $art.items ]?
          { this.docComment( $art ); }
          annotationAssignment_ll1[ $art ]*
        | typeRefOptArgs[ $art.items ]
          nullability[ $art.items ]? // only if not followed by `enum`
          { this.docComment( $art ); }
          annotationAssignment_ll1[ $art ]*
          (
            { if ($art.items.notNull) {
                this.message( 'syntax-unexpected-null', $art.items.notNull.location,
                  { keyword: $art.items.notNull.val ? 'not null' : 'null' } );
              }
            }
            ENUM '{' { $art.items.enum = this.createDict(); }
            enumSymbolDef[ $art.items ]*
            '}' { this.finalizeDictOrArray( $art.items.enum ); }
            nullability[ $art.items ]?
          )?
        )
        requiredSemi                     // also req after struct/enum
      |
        typeTypeOf[ $art ] elementProperties[ $art ]?
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
        requiredSemi                     // also req after foreign key spec
      |
        l=LOCALIZED { $art.localized = this.valueWithTokenLocation( true, $l ); }
        typeRefOptArgs[ $art ]
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
        ( elementProperties[ $art ]
          { this.docComment( $art ); }
          annotationAssignment_ll1[ $art ]*
        )?
        requiredSemi
      |
        typeRefOptArgs[ $art ]
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
        (
          ENUM '{' { $art.enum = this.createDict(); }
          enumSymbolDef[ $art ]*
          '}' { this.finalizeDictOrArray( $art.enum ); }
          elementProperties[ $art ]?
        |
          elementProperties[ $art ]
          { this.docComment( $art ); }
          annotationAssignment_ll1[ $art ]*
        )?
        requiredSemi                     // also req after enum spec
      )
    |
      // this is also called for enum symbols (in EXTEND)
      eq='=' e=expression       // never introduce AS as syntax variant of '='
      {
        if (!$allowEq || $e.expr && !$e.expr.literal )
          this.error( 'syntax-unsupported-calc-field', $eq );
        else if ($e.expr)
          $art.value = $e.expr;
      }
      { this.docComment( $art ); }
      annotationAssignment_ll1[ $art ]* // for enum symbol def via EXTEND
      requiredSemi
    )
  ;

extendElement[ art, outer ]
@after{ /* #ATN 1 */ this.attachLocation( $art ); }
  :
    // #ATN: element name can be ELEMENT
    ( expected=ELEMENT { $art.expectedKind = 'element'; } )?
    name=ident['Element']
    { this.addDef( $art, $outer, 'elements', 'extend', $name.id ); }
    extendWithOptElementsOrType[ $art, $art ]
  ;

selectItemDef[ outer ] locals[ art ]
@after{ if ($art) this.attachLocation( $art ); }
  :
    star='*'
    { $outer.push( this.valueWithTokenLocation( '*', $star ) ); }
  |
    { $art = {};; this.docComment( $art ); }
    annotationAssignment_atn[ $art ]*
    // VIRTUAL is keyword, except if before the following tokens texts:
    { this.setLocalToken( 'VIRTUAL', 'VIRTUAL', /^([,.:\[@]|as)$/i ) ; } // not '{'
    ( virtual=VIRTUAL { $art.virtual = this.valueWithTokenLocation( true, $virtual ); } )?
    ( key=KEY { $art.key = this.valueWithTokenLocation( true, $key ); } )?
    selectItemDefBody[ $art, $outer ]
  ;

selectItemDefBody[ art, outer ] locals[ assoc ]
@after{ /* #ATN 2 */ }
  :
    { $outer.push( $art ); }
    (
      e=expression { $art.value = $e.expr; }
      // we cannot use 'condition' instead, as long as we allow aliases without
      // AS (using rule 'ident' instead of 'identNoKeyword') -> ambiguities
      ( as=AS n1=ident['Item'] { $art.name = $n1.id }
      | n2=ident['Item'] { $art.name = this.fragileAlias( $n2.id, true ); }
      | { this.classifyImplicitName( 'Item', $e.expr ); }
      )
      { if ($art.value && !$art.value.path) this.excludeExpected( ["'.'", "'{'"] );
        else if ($art.name) this.excludeExpected( ["'.'"] );
      }
      (
        { this.reportExpandInline( $art, false ); }
        selectItemInlineList[ $art, 'expand' ]
        excludingClause[ $art ]?
        // TODO: we might alternatively allow AS here
      |
        { this.reportExpandInline( $art, $as || this._input.LT(-1) ); }
        DOTbeforeBRACE          // ...orASTERISK
        (
          selectItemInlineList[ $art, 'inline' ]
          excludingClause[ $art ]?
        |
          star='*'
          { $art.inline = [ this.valueWithTokenLocation( '*', $star ) ]; }
        )
      )?
    |
      selectItemInlineList[ $art, 'expand' ]
      excludingClause[ $art ]?
      AS n1=ident['Item'] { $art.name = $n1.id }
    )
    { this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    ( ':'
      // #ATN: typeRefOptArgs can start with TYPE, REDIRECTED, ASSOCIATION
      ( re=REDIRECTED to=TO
        { $art.target = {}; }
        simplePath[ $art.target, 'artref' ]
        (
          typeAssociationCont[ $art ]
        |
          { this.docComment( $art ); }
          annotationAssignment_ll1[ $art ]*
        )
      | typeTypeOf[ $art ]
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
      | l=LOCALIZED { $art.localized = this.valueWithTokenLocation( true, $l ); }
        typeRefOptArgs[ $art ]
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
      | typeRefOptArgs[ $art ]
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
      |
        { $assoc = this.associationInSelectItem( $art ); }
        typeAssociationBase[ $assoc, false ]
        // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
        ( typeToMany[ $assoc ] | typeToOne[ $assoc ] | simplePath[ $assoc.target, 'artref' ] )
        ON cond=condition
        { $assoc.on=$cond.cond; }
      )
    )?
  ;

bracedSelectItemListDef[ query ]
  :
    '{' { $query.columns = this.createArray(); }
    (
      selectItemDef[ $query.columns ]
      ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
        selectItemDef[ $query.columns ]
      )*
    )?
    '}' { this.finalizeDictOrArray( $query.columns ); }
  ;

selectItemInlineList[ art, clause ]
  :
    '{' { $art[$clause] = this.createArray(); }
    (
      selectItemInlineDef[ $art[$clause] ]
      ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
        selectItemInlineDef[ $art[$clause] ]
      )*
    )?
    '}' { this.finalizeDictOrArray( $art[$clause] ); }
  ;

selectItemInlineDef[ outer ] locals[ art ]
@after{ if ($art) this.attachLocation( $art ); }
  :
    star='*'
    { $outer.push( this.valueWithTokenLocation( '*', $star ) ); }
  |
    { $art = {};; this.docComment( $art ); }
    annotationAssignment_atn[ $art ]*
    selectItemDefBody[ $art, $outer ]
  ;

parameterListDef[ art ]
  :
    '(' { $art.params = this.createDict(); }
    // also empty param list (we might do some hacking later to allow reserved words)
    // see annotationAssignment_paren
    (
      parameterDef[ $art ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        parameterDef[ $art ]
      )*
    )?
    ')' { this.finalizeDictOrArray( $art.params ); }
  ;

parameterDef[ outer ] locals[ art = {} ]
@after { this.attachLocation( $art ); }
  :
    { this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    name=ident['Param']
    { this.addDef( $art, $outer, 'params', 'param', $name.id );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    typeSpec[ $art ]
    defaultValue[ $art ]?
    { this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
  ;

nullability[ art ]
  :
    not=NOT n1=NULL
    { $art.notNull = this.valueWithTokenLocation( true, $not, $n1 ); }
  |
    n2=NULL
    { $art.notNull = this.valueWithTokenLocation( false, $n2 ); }
  ;

elementProperties[ elem ]
  :
    nullability[ $elem ]
    defaultValue[ $elem ]?
  |
    defaultValue[ $elem ]
    nullability[ $elem ]?
  |
    eq='='
    { this.error( 'syntax-unsupported-calc-field', $eq ); }
    expression
  ;

// View definitions ----------------------------------------------------------

viewDef[ art, outer ] locals[ name = {} ]
@after { this.attachLocation( $art ); }
  :
    v=VIEW simplePath[ $name, 'Entity' ]
    { $art['$'+'syntax'] = 'view';
      this.addDef( $art, $outer, 'artifacts', 'entity', $name );
      this.docComment( $art ); }
    annotationAssignment_fix[ $art ]*
    (
      parameterListDef[ $art ]
    |
      // TODO: warning deprecated?
      ( HideAlternatives | WITH ) { $art.params = this.createDict(); }
      PARAMETERS
      parameterDef[ $art ]
      ( ',' parameterDef[ $art ] )* // no optional final ',' here
      { this.finalizeDictOrArray( $art.params ); }
    )?
    AS qe=queryExpression { $art.query = $qe.query; }
    // TODO check ANTLR: bad msg with 'view V as'<eof> but 'view V as FOO' is fine
    requiredSemi
  ;

// Type references -----------------------------------------------------------

includeRef[ art ] locals[ incl = {} ]
  :
    simplePath[ $incl, 'artref' ]
    { if ($art.includes) $art.includes.push($incl); else $art.includes = [$incl]; }
  ;

typeSpec[ art ]                 // for params
@after{ /* #ATN 1 */ }
  :
    typeStruct[ $art ]
  |
    ':'
    // #ATN: typeSimple can start with ARRAY or TYPE
    ( typeStruct[ $art ]
      nullability[ $art ]?
    | typeArray[ $art ] // nullability is set in typeArray
    | typeTypeOf[ $art ]
      nullability[ $art ]?
      // TODO: no LOCALIZED ?
    | typeRefOptArgs[ $art ]
      nullability[ $art ]?
      (
        ENUM '{' { $art.enum = this.createDict(); }
        enumSymbolDef[ $art ]*
        '}' { this.finalizeDictOrArray( $art.enum ); }
      )?
    )
  ;

returnTypeSpec[ art ]
@after{ /* #ATN 1 */ }
  :
    ret=RETURNS { $art.returns = { location: this.tokenLocation( $ret ), kind: 'param' }; }
    // #ATN: typeSimple can start with ARRAY or TYPE
    ( typeStruct[ $art.returns ]
      nullability[ $art.returns ]?
    | typeArray[ $art.returns ] // nullability is set in typeArray
    | typeTypeOf[ $art.returns ]
      nullability[ $art.returns ]?
      // TODO: no LOCALIZED ?
    | typeRefOptArgs[ $art.returns ]
      nullability[ $art.returns ]?
      (
        ENUM '{' { $art.returns.enum = this.createDict(); }
        enumSymbolDef[ $art.returns ]*
        '}' { this.finalizeDictOrArray( $art.returns.enum ); }
      )?
    )

    requiredSemi // currently for all - might change if we get rid of the misplaced annos (TODO: Now removed)
  ;


typeSpecSemi[ art ]      // with 'includes', for type and annotation defs
@after{ /* #ATN 3 */ }
  :
    typeStruct[ $art ]
    optionalSemi
  |
    ':'
    // #ATN: typeRefOptArgs can start with ARRAY or MANY or ASSOCIATION or TYPE or LOCALIZED
    // Nevertheless, MANY '{' is handled by local token rewrite:
    { this.setLocalToken( 'MANY', 'HelperToken1', /^[^\{]/ ); }
    (
      typeStruct[ $art ]
      optionalSemi
    |
      typeAssociationBase[ $art, false ]
      // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
      ( typeToMany[ $art ] | typeToOne[ $art ] | simplePath[ $art.target, 'artref' ] )
      typeAssociationCont[ $art ]?
      requiredSemi                       // and if its the ';'...
    |
      many=HelperToken1         // rewritten MANY before '{'
      { $art.items = { location: this.tokenLocation( $many ) };}
      typeStruct[ $art.items ]
      nullability[ $art.items ]?
      optionalSemi
    |
      (
        array=ARRAY of=OF
        { $art.items = { location: this.tokenLocation( $array, $of ) }; }
      | many=MANY
        { $art.items = { location: this.tokenLocation( $many ) };}
      )
      // #ATN: typeRefOptArgs can start with TYPE
      ( typeStruct[ $art.items ]
        nullability[ $art.items ]?
        optionalSemi
      | typeTypeOf[ $art.items ]
        nullability[ $art.items ]?
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
        requiredSemi
      | typeRefOptArgs[ $art.items ]
        nullability[ $art.items ]? // only if not followed by `enum`
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
        (
          { if ($art.items.notNull) {
              this.message( 'syntax-unexpected-null', $art.items.notNull.location,
                { keyword: $art.items.notNull.val ? 'not null' : 'null' } );
            }
          }
          ENUM '{' { $art.items.enum = this.createDict(); }
          enumSymbolDef[ $art.items ]*
          '}' { this.finalizeDictOrArray( $art.items.enum ); }
          (
            nullability[ $art.items ]
            requiredSemi
          |
            optionalSemi
          )
        |
          requiredSemi
        )
      )
    |
      typeTypeOf[ $art ]
      defaultValue[ $art ]?
      { this.docComment( $art ); }
      annotationAssignment_ll1[ $art ]* requiredSemi
    |
      l=LOCALIZED { $art.localized = this.valueWithTokenLocation( true, $l ); }
      typeRefOptArgs[ $art ]
      defaultValue[ $art ]?
      { this.docComment( $art ); }
      annotationAssignment_ll1[ $art ]*
      requiredSemi
    |
      // alt lookahead includes MANY '{'
      { $art.type = {}; }
      // Can't use typeRefOptArgs because of clash with include rule below (ATN would change)
      simplePath[ $art.type, 'artref' ]
      (
        ( typeRefArgs[ $art ]
        | ':' // with element, e.g. `type T : E:elem enum { ... }`
          { $art.type.scope = $art.type.path.length; }
          simplePath[ $art.type, 'ref']
        )?
        { this.docComment( $art ); }
        annotationAssignment_ll1[ $art ]*
        (
          ENUM '{' { $art.enum = this.createDict(); }
          enumSymbolDef[ $art ]*
          '}' { this.finalizeDictOrArray( $art.enum ); }
          (
            optionalSemi
          |
            defaultValue[ $art ]
            requiredSemi
          )
        |
          defaultValue[ $art ]?
          requiredSemi
        )
      |
        // TODO: complain if used in anno def?
        { $art.includes = [ $art.type ]; delete $art.type; }
        ( ',' { if (this.isStraightBefore('{')) break; } // allow ',' before '{' // }}
          includeRef[ $art ]
        )*
        typeStruct[ $art ]
        optionalSemi
      )
    )
  ;

typeStruct[ art, attachLoc = false ]
@after { if ($attachLoc) this.attachLocation($art); }
  :
    '{' { $art.elements = this.createDict(); }
    elementDef[ $art ]*
    '}' { this.finalizeDictOrArray( $art.elements ); }
  ;

typeCompoStruct[ art ]
@after { this.attachLocation($art); }
  :
    COMPOSITIONofBRACE { $art.elements = this.createDict(); }
    elementDef[ $art ]*
    '}' { this.finalizeDictOrArray( $art.elements ); }
  ;

typeArray[ art ]
@after { /* #ATN 1 */ }
  :
    (
      array=ARRAY of=OF
      { $art.items = { location: this.tokenLocation( $array, $of ) }; }
    | many=MANY
      { $art.items = { location: this.tokenLocation( $many ) };}
    )
    // #ATN: typeRefOptArgs can start with TYPE
    ( typeStruct[ $art.items ]
      nullability[ $art.items ]?
    | typeTypeOf[ $art.items ]
      nullability[ $art.items ]?
    | typeRefOptArgs[ $art.items ]
      nullability[ $art.items ]?
      (
        ENUM '{' { $art.items.enum = this.createDict(); }
        enumSymbolDef[ $art.items ]*
        '}' { this.finalizeDictOrArray( $art.items.enum ); }
      )?
    )
  ;

typeAssociationBase[ art, handleTypeCompo ] // including Composition
  :
    (
      assoc=ASSOCIATION cardinality[$art]? TO
      {{
        let location = this.tokenLocation($assoc);
        $art.type = { path: [{ id: 'cds.Association', location }], scope: 'global', location };
        this.handleComposition( $art.cardinality, false );
      }}
    |
      compo=COMPOSITION cardinality[$art]? OF
      {{
        let location = this.tokenLocation($compo);
        $art.type = { path: [{ id: 'cds.Composition', location }], scope: 'global', location };
        this.handleComposition( $art.cardinality, handleTypeCompo );
      }}
    )
    { $art.target = {}; }
  ;

typeAssociationCont[ art ]
  :
    (
      '{' { $art.foreignKeys = this.createDict(); }
      (
        foreignKey[ $art ]
        ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
          foreignKey[ $art ]
        )*
      )?
      '}' { this.finalizeDictOrArray( $art.foreignKeys ); }
    |
      ON cond=condition
      { $art.on=$cond.cond; }
    )
  ;

typeAssociationElementCont[ art ] // including Composition
// optional NULL / NOT NULL for managed association only
  :
    (
      '{' { $art.foreignKeys = this.createDict(); }
      (
        foreignKey[ $art ]
        ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
          foreignKey[ $art ]
        )*
      )?
      '}' { this.finalizeDictOrArray( $art.foreignKeys ); }
      nullability[ $art ]?
    |
      ON cond=condition
      { $art.on=$cond.cond; }
    |
      nullability[ $art ]
    )?
    { this.docComment( $art ); }
    annotationAssignment_ll1[ $art ]*
    requiredSemi                     // also req after foreign key spec
  ;

typeToOne[ art ]
  :
    one=ONE
    { this.setMaxCardinality( $art, $one, this.numberLiteral( $one, null, '1' ) ); }
    simplePath[ $art.target, 'artref' ]
  ;

typeToMany[ art ]
  :
    many=MANY
    { this.setMaxCardinality( $art, $many, { literal: 'string', val: '*' } ); }
    simplePath[ $art.target, 'artref' ]
  ;

cardinality[ art ] locals[ card = {} ]
@after { /* #ATN 2 */ $art.cardinality = this.attachLocation($card); }
  :
    lbrack='['
    { $card.targetMax = { literal: 'string', val: '*',
                          location: this.tokenLocation($lbrack) }; }
    (
      // #ATN: simple lookahead behind Number
      (
        srcMax=Number  ','
        { $card.sourceMax = this.numberLiteral( $srcMax ); }
      |
        srcMaxStar='*' ','
        { $card.sourceMax = { literal: 'string', val: '*',
                              location: this.tokenLocation($srcMaxStar) }; }
      )?
      // #ATN: simple lookahead behind Number
      (
        trgMin=Number '..'
        { $card.targetMin = this.numberLiteral( $trgMin ); }
      )?
      (
        trgMax=Number
        { $card.targetMax = this.numberLiteral( $trgMax ); }
      |
        trgMaxStar='*'
        { $card.targetMax = { literal: 'string', val: '*',
                              location: this.tokenLocation($trgMaxStar) }; }
      )
    )?
    ']'
  ;

foreignKey[ outer ] locals[ art = {}, elem = {} ]
@after { this.attachLocation($art); }
  :
    simplePath[ $elem, 'ref' ] { $art.targetElement = $elem; }
    ( AS name=ident['Key'] )?
    { this.addDef( $art, $outer, 'foreignKeys', 'key', ($ctx.name) ? $name.id : $elem.path ); }
  ;

typeTypeOf[ art ] locals[ _sync = 'nop' ]
@after { this.attachLocation($art.type); }
  :
    TYPE OF
    { $art.type = { scope: 'typeOf' }; }
    simplePath[ $art.type, 'ref' ]
    ( ':'
      // If we have too much time, we could set the category of the simple path
      // before to 'artref'
      { $art.type.scope = $art.type.path.length; }
      simplePath[ $art.type, 'ref']
    )?
  ;

typeRefOptArgs[ art ]
@init { $art.type = {}; }
  :
    simplePath[ $art.type, 'artref' ]
    (
      typeRefArgs[ $art ]
    |
      ':'
      { $art.type.scope = $art.type.path.length; }
      simplePath[ $art.type, 'ref']
    )?
  ;

typeRefArgs[ art ]
  :
    paren='(' { $art['$'+'typeArgs'] = this.createArray(); }
    (
      // unnamed arguments
      head=Number
      { $art['$'+'typeArgs'].push( this.numberLiteral( $head ) ); }
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        (
          v=VARIABLE
          { $art['$'+'typeArgs'].push(
            { literal: 'string', val: 'variable', location: this.tokenLocation($v) } );
          }
        |
          f=FLOATING
          { $art['$'+'typeArgs'].push(
            { literal: 'string', val: 'floating', location: this.tokenLocation($f) } );
          }
        |
          tail=Number
          { $art['$'+'typeArgs'].push( this.numberLiteral( $tail ) ); }
        )
      )*
    |
      // named arguments
      typeNamedArg[ $art ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        typeNamedArg[ $art ]
      )*
    )
    ')'{ this.finalizeDictOrArray( $art['$'+'typeArgs']); }
  ;

typeNamedArgList[ art ]
  :
    paren='('
    typeNamedArg[ $art ]
    ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
      typeNamedArg[ $art ]
    )*
    ')'
  ;

typeNamedArg[ art ] locals[ arg = '' ]
  :
    name=ident['paramname']
    ':'
    { if ($name.id && this.checkTypeFacet( $art, $name.id ))
        $arg = $name.id.id;
    }
    (
      val=Number
      { if ($arg && $art && $name.id) {
          $art[$arg] = this.numberLiteral( $val );
        }
      }
    |
      v=VARIABLE
      { if ($arg && $art && $name.id) {
          $art[$arg] = { literal: 'string', val: 'variable', location: this.tokenLocation($v) };
        }
      }
    |
      f=FLOATING
      { if ($arg && $art && $name.id) {
          $art[$arg] = { literal: 'string', val: 'floating', location: this.tokenLocation($f) };
        }
      }
    )
  ;


// Queries -------------------------------------------------------------------

queryExpression returns[ query ] // QLSubqueryComplex, SubqueryComplex
@after{ this.attachLocation($query); }
  :
    qt1=queryTerm { $query = $qt1.query; }
    (
      ( op=UNION  q=( DISTINCT | ALL )?
      | op=EXCEPT q=DISTINCT?
      | op=MINUS  q=DISTINCT?
      )
      qt=queryTerm
      { if ($qt.query) $query = this.leftAssocBinaryOp( $query, $op, $q, $qt.query );; $ctx.q = null; }
    )*
    ( ob=orderByClause[ $query ] { if ($ob.query) $query = $ob.query; } ) ?
    ( lc=limitClause[ $query ]   { if ($lc.query) $query = $lc.query; } ) ?
  ;

orderByClause[ inQuery ] returns [ query ]
  :
    ORDER BY { $query = this.unaryOpForParens( $inQuery, '$'+'query' ); }
    ob1=orderBySpec { $query.orderBy = [ $ob1.ob ]; }
    ( ',' obn=orderBySpec  { $query.orderBy.push( $obn.ob ); } )*
  ;

// Generic function ORDER BY clause, e.g. `first_value(id order by name)`
// lhsExpr is the left expression of the ORDER BY clause.
functionOrderByClause[ lhsExpr ] returns [ expr ]
@after { this.attachLocation( $expr ); }
  :
    o=ORDER b=BY { $expr = { op: this.valueWithTokenLocation( 'orderBy', $o, $b ) , args: [ $lhsExpr ] }}
    ob1=orderBySpec { $expr.args.push( $ob1.ob ); }
    ( ',' obn=orderBySpec { $expr.args.push( $obn.ob ); } )*
  ;

overOrderByClause returns [ expr ]
@after { this.attachLocation( $expr ); }
  :
    o=ORDER b=BY { $expr = { op: this.valueWithTokenLocation( 'overOrderBy', $o, $b ) , args: [] }}
    ob1=orderBySpec { $expr.args.push( $ob1.ob ); }
    ( ',' obn=orderBySpec { $expr.args.push( $obn.ob ); } )*
  ;

partitionByClause returns [ expr ]
@after { this.attachLocation( $expr ); }
  :
    p=PARTITION b=BY { $expr = { op: this.valueWithTokenLocation( 'partitionBy', $p, $b ) , args: [] }}
    e1=expression { $expr.args.push( $e1.expr ); }
    ( ',' en=expression { $expr.args.push( $en.expr ); } )*
  ;

windowFrameClause returns [ wf ]
@after { this.attachLocation( $wf ); }
  :
    r=ROWS { $wf = { op: this.valueWithTokenLocation( 'rows', $r ) , args: [] }}
    wfe=windowFrameExtentSpec { $wf.args.push( $wfe.wfe ); }
  ;

windowFrameExtentSpec returns[ wfe ]
@after { this.attachLocation( $wfe ); }
  :
    { $wfe = {} }
    windowFrameStartSpec [ $wfe ]
  |
    b=BETWEEN
    { $wfe = { op: this.valueWithTokenLocation( 'frameBetween', $b ), args: [] } }
    wfb1=windowFrameBoundSpec { $wfe.args.push( $wfb1.wfb ); }
    AND
    wfb2=windowFrameBoundSpec { $wfe.args.push( $wfb2.wfb ); }
  ;

windowFrameBoundSpec returns [ wfb ]
@after{ /* #ATN 1 */ }
  :
    // #ATN:  Not ll1 because `UNBOUNDED` could also be part of the windowFrameStartSpec
    //        `UNBOUNDED` would then be immediately followed by `PRECEDING`
    u=UNBOUNDED f=FOLLOWING
    { $wfb = { op: this.valueWithTokenLocation( 'unboundedFollowing', $u, $f ), args: []} }
  |
    // #ATN:  Not ll1 because `Number` could also be part of the windowFrameStartSpec
    //        `Number` would then be immediately followed by `PRECEDING`
    n=Number f=FOLLOWING
    { $wfb = { op: this.valueWithTokenLocation( 'following', $n, $f ), args: [ this.numberLiteral( $n ) ]} }
  |
    { $wfb = {} }
    windowFrameStartSpec [ $wfb ]
  ;

windowFrameStartSpec [ wf ]
@after { this.attachLocation( $wf ); }
  :
    u=UNBOUNDED p=PRECEDING
    {
      $wf.op = this.valueWithTokenLocation( 'unboundedPreceding', $u, $p );
      $wf.args = [];
    }
  |
    n=Number p=PRECEDING
    {
      $wf.op = this.valueWithTokenLocation( 'preceding', $p );
      $wf.args = [ this.numberLiteral( $n ) ];
    }
  |
    c=CURRENT r=ROW
    {
      $wf.op = this.valueWithTokenLocation( 'currentRow', $c, $r );
      $wf.args = [];
    }
  ;

overClause returns [ over ]
@after { this.attachLocation( $over ); }
  :
    o=OVER { $over = { op: this.valueWithTokenLocation( 'over', $o ) , args: []  } }
    '('                         // TODO: check whether an extra location could be useful
      ( pb=partitionByClause { $over.args.push( $pb.expr ); } )?
      ( ob=overOrderByClause { $over.args.push( $ob.expr ); } )?
      ( wf=windowFrameClause { $over.args.push( $wf.wf ); } )?
    ')'
  ;

limitClause[ inQuery ] returns [ query ]
  :
    limkw=LIMIT { $query = this.unaryOpForParens( $inQuery, '$'+'query' ); }
    ( lim=Number   { $query.limit = { rows: this.numberLiteral( $lim, '' ) }; }
    | limnull=NULL { $query.limit = { rows: {
        literal: 'null', val: null, location: this.tokenLocation($limnull) } }; }
    )
    ( OFFSET off=Number { $query.limit.offset = this.numberLiteral( $off ); } )? // unsigned integer
  ;

orderBySpec returns[ ob ]
  :
    e=expression { $ob = $e.expr; }
    ( asc=ASC   { $ob.sort = this.valueWithTokenLocation( 'asc', $asc ); }
    | desc=DESC { $ob.sort = this.valueWithTokenLocation( 'desc', $desc ); }
    )?
    ( nb=NULLS ne=( FIRST | LAST )
      { $ob.nulls = this.valueWithTokenLocation( $ne.text.toLowerCase(), $nb, $ne ); }
    )?
  ;

queryTerm returns[ query ]
@after{ this.attachLocation($query); }
  :
    qt1=queryPrimary { $query = $qt1.query; }
    (
      intersect=INTERSECT quantifier=DISTINCT?
      qt=queryPrimary
      { $query = this.leftAssocBinaryOp( $query, $intersect, $quantifier, $qt.query );
        $ctx.quantifier = null; }   // reset for loop
    )*
  ;

queryPrimary returns[ query = {} ]
@after { this.attachLocation($query); }
  :
    open='(' qe=queryExpression close=')'
    { $query = this.surroundByParens( $qe.query, $open, $close ); }
  |
    select=SELECT
    { $query = { op: this.valueWithTokenLocation( 'SELECT', $select ), location: this.startLocation() }; }
    (
      FROM querySource[ $query ]
      (
        mixin=MIXIN '{' { $query.mixin = this.createDict(); }
        mixinElementDef[ $query ]*
        '}' { this.finalizeDictOrArray( $query.mixin ); }
        INTO
      )?
      ( ad=( ALL | DISTINCT )     // TODO: or directly after SELECT ?
      { $query.quantifier = this.valueWithTokenLocation( $ad.text.toLowerCase(), $ad ); }
      )?
      bracedSelectItemListDef[ $query, 'columns' ]?
      excludingClause[ $query ]?
    |
      ( ad=( ALL | DISTINCT )     // TODO: or directly after SELECT ?
      { $query.quantifier = this.valueWithTokenLocation( $ad.text.toLowerCase(), $ad ); }
      )?
      { $query.columns = []; }  // set it early to avoid "wildcard" errors
      selectItemDef[ $query.columns ]
      ( ',' { if (this.isStraightBefore("}")) break; } // allow ',' before '}'
        selectItemDef[ $query.columns ]
      )*
      FROM querySource[ $query ]
    )
    ( WHERE cond=condition { $query.where = $cond.cond; } )?
    (
      GROUP BY
      e1=expression { $query.groupBy = [ $e1.expr ]; }
      ( ',' en=expression { $query.groupBy.push( $en.expr ); } )*
    )?
    ( HAVING having=condition { $query.having = $having.cond; } )?
  ;

querySource[ query ]
@after { this.attachLocation($query.from); }
  :
    t1=tableExpression { $query.from = $t1.table; }
    (
      { const location = this.tokenLocation( this.getCurrentToken() );
        $query.from = { op: { val: 'join', location },
                        join: { val: 'cross', location },
                        args: [$t1.table] }; }
      ( ',' tn=tableExpression { if ($tn.table) $query.from.args.push( $tn.table ); } )+
    )?
  ;

tableExpression returns[ table ] // TableOrJoin
@after { this.attachLocation($table); }
  :
    qt=tableTerm { $table = $qt.table; }
    (
      join=joinOp[ $table ] { $table = $join.table; }
      te=tableExpression
      { if (!$table) { $table = {}; } else if ($te.table) $table.args.push( $te.table ); }
      ON cond=condition { $table.on = $cond.cond; }
    |
      crj=CROSS jn=JOIN tt=tableTerm
      { if (!$table) { $table = {}; } $table = this.leftAssocBinaryOp( $table, $jn, $crj, $tt.table, 'join' ); }
    )*
  ;

joinOp[ left ] returns[ table ] locals [ join ]
  :
    ( op=JOIN { $join = 'inner'; }
    | t1=INNER c=joinCardinality? op=JOIN { $join = 'inner' }
    | t1=LEFT t2=OUTER? c=joinCardinality? op=JOIN { $join = 'left' }
    | t1=RIGHT t2=OUTER? c=joinCardinality? op=JOIN { $join = 'right' }
    | t1=FULL t2=OUTER? c=joinCardinality? op=JOIN { $join = 'full' }
    )
    { $table = { op: this.valueWithTokenLocation( 'join', $op ),
                 join: this.valueWithTokenLocation( $join, $t1 || $op, $t2 ),
                 args: ($left ? [$left] : []),
                 location: $left && $left.location };
      if ($ctx.c) $table.cardinality = $c.joinCard; }
  ;

joinCardinality returns [ joinCard ]
@init { $joinCard = {}; }
@after { this.attachLocation($joinCard); }
  :
    (
      srcExact=EXACT?
      srcMaxOne=ONE
      { if($srcExact)
          $joinCard.sourceMin = { literal: 'number', val: 1,
                                  location: this.tokenLocation($srcExact) };
        $joinCard.sourceMax = { literal: 'number', val: 1,
                                  location: this.tokenLocation($srcMaxOne) }; }
    |
      srcMaxMany=MANY
      { $joinCard.sourceMax = { literal: 'string', val: '*',
                                   location: this.tokenLocation($srcMaxMany) }; }
    )
    TO
    (
      tgtExact=EXACT? tgtMaxOne=ONE
      { if($tgtExact)
          $joinCard.targetMin = { literal: 'number', val: 1,
                                  location: this.tokenLocation($tgtExact) };
        $joinCard.targetMax = { literal: 'number', val: 1,
                              location: this.tokenLocation($tgtMaxOne) }; }
    |
      tgtMaxMany=MANY
      { $joinCard.targetMax = { literal: 'string', val: '*',
                                location: this.tokenLocation($tgtMaxMany) }; }
    )
  ;

tableTerm returns [ table ]
@after{ /* #ATN 1 */ this.attachLocation($table); }
  :
    { $table = { path: [], scope: 0 }; }
    fromPath[ $table, 'artref']
    ( ':'
      { $table.scope = $table.path.length; }
      fromPath[ $table, 'ref']
    )?
    ( AS n1=ident['FromAlias'] { $table.name = $n1.id }
    | n2=identNoKeyword['FromAlias'] { $table.name = this.fragileAlias( $n2.id ); }
      // if we would use rule `ident`, we would either had to make all JOIN
      // kinds reserved or introduce ATN
    )?
    // ANTLR errors are better if we use ( A | B )? instead of ( A | B | ):
    { if (!$table.name) this.classifyImplicitName( $table.scope ? 'FromAlias' : 'Without' ); }
  |
    open='('
    // #ATN: The following alternative is not LL1, because both can start with
    // left-paren, but queryExpression has SELECT after initial left-parens
    (
      qe=queryExpression close=')'
      { $table = this.surroundByParens( $qe.query, $open, $close, true ); }
      ( AS a1=ident['FromAlias'] { $table.name = $a1.id } // for defining table aliass
      | a2=identNoKeyword['FromAlias'] { $table.name = this.fragileAlias( $a2.id, true ); }
        // not using ident` to have a similar behavior to above
      )
    |
      te=tableExpression close=')'
      { $table = this.surroundByParens( $te.table, $open, $close ); }
    )
  ;

fromPath[ qp, idkind ]
@after{ this.attachLocation($qp); }
  :
    id=ident[$idkind] { this.pushIdent( $qp.path, $id.id ); }
    ( fromArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
    | cardinalityAndFilter[ $id.id ]
    )?
    (
      '.' id=ident[$idkind] { this.pushIdent( $qp.path, $id.id ); }
      ( fromArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
      | cardinalityAndFilter[ $id.id ]
      )?
    )*
  ;

// Conditions and expressions ------------------------------------------------

// With "separate" `condition` and `expression` rules, we have long LL
// ambiguities (not so with LALR used in Bison) with initial left parentheses:
//   ( ( ( a.b.c + d.e.f
//       )     // now we know: 3rd left-paren for expression
//       =     // now we know: 1st and 2nd left-paren for condition
//       3 ) ) )
//
// To avoid expensive parsing, we "combine" both rules, i.e. inside '('…')' of
// rule `expressionTerm`, we recursively refer to `condition`, not
// `expression`.  With that, the existence of relations/predicates in rule
// `conditionTerm` must be optional.  Correct conditions and expressions must
// be then ensured by code (either in actions of the grammar or in a check
// phase - to be discussed).
//
// ANTLR4s left-recursion feature cannot be used as we will have rule
// arguments.

condition returns [ cond ] locals [ args = [], orl = [] ]
@after{
  $cond = ($args.length === 1)
    ? this.attachLocation( $args[0] )
    : this.attachLocation({ op: $orl[0], args: $args });
}
  :
    c1=conditionAnd { $args.push($c1.cond); }
    ( or=OR c2=conditionAnd { $args.push($c2.cond); $orl.push(this.valueWithTokenLocation( 'or', $or ))} )*
  ;

conditionAnd returns [ cond ] locals [ args = [], andl = [] ]
@after{
  $cond = ($args.length === 1)
    ? $args[0]
    : this.attachLocation({ op: $andl[0], args: $args });
}
  :
    c1=conditionTerm { $args.push($c1.cond); }
    ( and=AND c2=conditionTerm { $args.push($c2.cond); $andl.push(this.valueWithTokenLocation( 'and', $and )) } )*
  ;

// Note: New operators need to be added to functionExpressionOperatorsRequireParentheses[] in toCdl.js.
conditionTerm returns [ cond ]
@after{
  if ($cond) { this.attachLocation($cond); } else { $cond = $expr.expr; }
}
  :
    nt=NOT ct=conditionTerm
    { $cond = { op: this.valueWithTokenLocation( 'not', $nt ), args: [ $ct.cond ] }; }
  |
    ex=EXISTS
    (
      open='(' qe=queryExpression close=')'
      { $cond = { op: this.valueWithTokenLocation( 'exists', $ex ),
                  args: [ this.surroundByParens( $qe.query, $open, $close, true ) ] }; }
    |
      qm=( HideAlternatives | '?' )
      { $cond = { op: this.valueWithTokenLocation( 'exists', $ex ), args: [
          { param: this.valueWithTokenLocation( '?', $qm ), scope: 'param' }
        ] };
        this.csnParseOnly( 'syntax-unsupported-param', [ $qm ], { '#': 'dynamic', code: '?' } );
      }
    |
      ep=valuePath[ 'ref' ]
      { $ep.qp['$'+'expected'] = 'exists';
        $cond = { op: this.valueWithTokenLocation( 'exists', $ex ), args: [ $ep.qp ] };
      }
    )
  |
    expr=expression             // see @after
    (
      rel=( '=' | '<>' | '>'  | '>=' | '<' | '<=' | '!=' )
      { $cond = { op: this.valueWithTokenLocation( $rel.text, $rel ), args: [ $expr.expr ] }; }
      ( asa=( ANY | SOME | ALL )
        { $cond.quantifier = this.valueWithTokenLocation( $asa.text.toLowerCase(), $asa ); }
      )?
      e2=expression { $cond.args.push($e2.expr); }
    |
      IS ( inn=NOT NULL | innu=NULL )
      { $cond = { op: $inn ? this.valueWithTokenLocation( 'isNotNull', $inn ) : this.valueWithTokenLocation( 'isNull', $innu ), args: [ $expr.expr ] }; }
    |
      { $cond = { args: [ $expr.expr ] }; }
      NOT predicate[ $cond, true ]
      { if (!$cond.op) $cond = null; } // predicate failed to parse, avoid subseqential errors
    |
      { $cond = { args: [ $expr.expr ] }; }
      predicate[ $cond, false ]
      { if (!$cond.op) $cond = null; } // predicate failed to parse, avoid subseqential errors
    )?                          // optional: for conditions in parentheses
  ;

// Note: New operators need to be added to functionExpressionOperatorsRequireParentheses[] in toCdl.js.
predicate[ cond, negated ]
// As an alternative, we could have a `negated` properties for the operations
// `isNull`(!), `in`, `between` and `like` (or produce the same AST as for
//    NOT (a BETWEEN b AND c)
  :
    ino=IN e1=expression        // including ExpressionList
    { $cond.op = this.valueWithTokenLocation( (negated) ? 'notIn' : 'in', $ino ); $cond.args.push( $e1.expr ); }
  |
    bw=BETWEEN e2=expression
    { $cond.op = this.valueWithTokenLocation( (negated) ? 'notBetween' : 'between', $bw ); $cond.args.push( $e2.expr ); }
    AND e3=expression { $cond.args.push( $e3.expr ); }
  |
    lk=LIKE e4=expression
    { $cond.op = this.valueWithTokenLocation( (negated) ? 'notLike' : 'like', $lk ); $cond.args.push( $e4.expr ); }
    ( ESCAPE e5=expression { $cond.args.push( $e5.expr ); } )?
  ;

expression returns [ expr ]
@after{ if ($expr) { this.attachLocation($expr); } else { $expr = this.attachLocation({});} }
  :
    e1=expressionSum { $expr = $e1.expr; }
    (
      or='||' e2=expressionSum
      {
        $expr = {
          op: this.valueWithTokenLocation( '||', $or ), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionSum returns [ expr ]
@after{ if ($expr) this.attachLocation($expr); }
  :
    e1=expressionFactor { $expr = $e1.expr; }
    (
      op=( '+' | '-' ) e2=expressionFactor
      {
        $expr = {
          op: this.valueWithTokenLocation( $op.text, $op ), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionFactor returns [ expr ]
@after{ if ($expr) this.attachLocation($expr); }
  :
    e1=expressionTerm { $expr = $e1.expr; }
    (
      op=( '*' | '/' ) e2=expressionTerm
      {
        $expr = {
          op: this.valueWithTokenLocation( $op.text, $op ), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionTerm returns [ expr ] locals [ op, args = [] ]
@after{ /* #ATN 1 */ this.attachLocation($expr); }
  :
    unary=( '+' | '-' ) e1=expressionTerm // prefix op or part of the number
    { $expr = this.signedExpression( $unary, $e1.expr ); }
  |
    (
      val=literalValue
      { $expr = $val.val; }
    |
      sf=specialFunction
      { $expr = $sf.ret; }
    |
      ca=CASE
      { $expr = { op : this.valueWithTokenLocation( 'case', $ca ), args: [] }; }
      (
        e2=expression { $expr.args.push($e2.expr); }
        ( ow=WHEN ew=expression THEN e3=expression
          { $expr.args.push( this.createPrefixOp( $ow, [ $ew.expr, $e3.expr ] ) ); }
        )+
      |
        ( ow=WHEN c=condition THEN e3=expression
          { $expr.args.push( this.createPrefixOp( $ow, [ $c.cond, $e3.expr ] ) ); }
        )+
      )
      ( el=ELSE e4=expression
        { $expr.args.push( this.createPrefixOp( $el, [ $e4.expr ] ) ); }
      )?
      END
    |
      ne=NEW nqp=valuePath[ 'ref', null] // token rewrite for NEW
      // please note: there will be no compiler-supported code completion after NEW
      { $expr = { op: this.valueWithTokenLocation( 'new', $ne ), args: [] };
        this.error( 'syntax-unsupported-new', $ne, { keyword: $ne.text }, '$(KEYWORD) is not supported' ); }
    |
      vp=valuePath[ 'ref', null ] { $expr = this.valuePathAst( $vp.qp ); }
      { this.setLocalTokenIfBefore( 'OVER', 'OVER', /^\($/i ); }
      (
        over=overClause { $expr.suffix = [ $over.over ] }
      )?
    |
      ':'
      ( vp=valuePath[ 'paramref', this.startLocation() ]
        { $expr = $vp.qp;; $expr.scope = 'param'; }
      | pp=Number
        { $expr = { param: this.numberLiteral( $pp ), scope: 'param' };
          this.csnParseOnly( 'syntax-unsupported-param', [ $pp ], { '#': 'positional', code: ':' + $pp.text } );
        }
      )
    |
      qm= '?'                   // is automatically not mentioned as CC candidate
      // if we have an HideAlternatives here, we would block it to use it in
      // parallel to an expression (would produce adaptivePredict() otherwise)
      { $expr = { param: this.valueWithTokenLocation( '?', $qm ), scope: 'param' };
        this.csnParseOnly( 'syntax-unsupported-param', [ $qm ], { '#': 'dynamic', code: '?' } );
      }
    |
      open='('
      // #ATN: The following alternative is not LL1, because both can start with
      // left-paren, but queryExpression has SELECT after initial left-parens
      (
        qe=queryExpression close=')'
        { $expr = this.surroundByParens( $qe.query, $open, $close, true ); }
      |
        c1=condition { $expr = [ $c1.cond ]; }
        ( ',' { if ($expr.length > 1 && this.isStraightBefore(')')) break; } // allow ',' before ')'
          cn=expression { if ($cn.expr) $expr.push($cn.expr); }
        )*
        close=')'
        {
          if ($expr.length > 1)
            $expr = { op: this.valueWithTokenLocation( ',', $open ), args: $expr };
          else if ($expr[0]) // can be `null` if condition failed to parse
            $expr = this.surroundByParens( $expr[0], $open, $close );
        }
      )
    )
  ;

specialFunction returns [ ret = { } ] locals[ art = {} ]
  :
    ca=CAST '('                 // see createArray() in action
    {
      $ret = {
        op: this.valueWithTokenLocation( 'cast', $ca ),
        args: this.createArray(),
        location: this.tokenLocation( $ca )
      };
    }
    e=expression AS typeRefOptArgs[ $ret ]
    {
      $ret.args.push( $e.expr );
    }
    ')' { this.finalizeDictOrArray( $ret.args ); }
  ;

// query path includes aggregation:
// ( COUNT | MIN | MAX | SUM | AVG | STDDEV | VAR )
// '(' ( '*' | expression | ALL expression | DISTINCT expression_list ) ')'

valuePath[ category, location = null ] returns[ qp = { path: [] } ] locals[ _sync = 'nop' ]
@init { $qp.location = location || this.startLocation(); }
@after{ this.attachLocation($qp); }
  :
    id=ident[ $category ]
    { this.pushIdent( $qp.path, $id.id ); }
    ( pathArguments[ $id.id, $id.id ] cardinalityAndFilter[ $id.id ]?
    | cardinalityAndFilter[ $id.id ]
    )?
    (
      '.' id=ident['ref']       // yes 'ref', not $category
      { this.pushIdent( $qp.path, $id.id ); }
      ( pathArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
      | cardinalityAndFilter[ $id.id ]
      )?
    )*
  ;

fromArguments[ pathStep ]
@init{ if (!$pathStep) $pathStep = {}; } // grammar robustness, see test/negative/parser/NamedExpression.cds
  :
    '(' { $pathStep.args = this.createDict(); $pathStep['$'+'syntax'] = ':'; } // necessary?
    name=ident['paramname'] ':'
    namedExpression[ $pathStep, $name.id ]
    ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
      name=ident['paramname'] ':'
      namedExpression[ $pathStep, $name.id ]
    )*
    ')' { this.finalizeDictOrArray( $pathStep.args ); }
  ;

pathArguments[ pathStep, considerSpecial ]
@init{
  if (!$pathStep) $pathStep = {}; // grammar robustness, see test/negative/parser/NamedExpression.cds
  this.genericFunctionsStack.push( this['$'+'genericKeywords'] );
}
  :
    { this.excludeExpected([ 'ORDER' ]); }
    '('                         // dict or array, see below
    // Make sure that we do not introduce A:B paths in expressions!
    // Need to avoid adaptPredict(), otherwise Generic keywords won't work in funcExpression
    //
    // For code completion, we need to handle generic tokens directly after the
    // '('.  To avoid invalidating an assoc `trim` to an entity with parameter
    // `leading` (ok, a bit constructed), we do not do it with named parameters.
    { if (!this.setLocalTokenForId( { ':': 'HelperToken1', '=>': 'HelperToken2' } ))
        this.prepareGenericKeywords( $considerSpecial ); }
    (
      { $pathStep.args = this.createDict(); $pathStep['$'+'syntax'] = ':'; }
      id=HelperToken1 ':'
      namedExpression[ $pathStep, this.identAst( $id, 'paramname', true ) ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        name=ident['paramname'] ':'
        namedExpression[ $pathStep, $name.id ]
      )*
    |
      { $pathStep.args = this.createDict(); }  // TODO: XSN func path cleanup
      id=HelperToken2 '=>'
      namedExpression[ $pathStep, this.identAst( $id, 'paramname', true ) ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        name=ident['paramname'] '=>'
        namedExpression[ $pathStep, $name.id ]
      )*
    |
      { $pathStep.args = this.createArray(); }
      funcExpression[ $pathStep, $considerSpecial ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        funcExpression[ $pathStep, $considerSpecial ]
      )*
      // Note: We can't move this into funcExpression, or we would increase the ATN count because of `,` amiguity.
      ( ob=functionOrderByClause[ $pathStep.args[$pathStep.args.length - 1] ]
        {
          // Remove the last entry which was copied to $ob.expr and push $ob.expr.
          $pathStep.args[$pathStep.args.length - 1] = $ob.expr;
        }
      )?
    |
      { $pathStep.args = this.createArray(); }
    )
    ')' { this.finalizeDictOrArray( $pathStep.args ); }
  ;
  finally {                     // see @init
    if (!$pathStep.args) $pathStep.args = [];
    this['$'+'genericKeywords'] = this.genericFunctionsStack.pop();
  }

namedExpression[ pathStep, id ]
  :
    elem=expression
    { if ($pathStep && $id) {
      this.addDef( ($ctx.elem) ? $elem.expr : { location: $id.location },
                   $pathStep, 'args', 0, $id );
      }
    }
  ;

funcExpression[ pathStep, considerSpecial ] locals[ args ]
@init { this.prepareGenericKeywords( $considerSpecial ); }
  :
    (
      expr=expression
      { $pathStep.args.push( $expr.expr ); }
    |
      GenericExpr       // keyword as replacement for expression, like '*'
      { $pathStep.args.push( this.xprToken() ); }
    |
      GenericIntro      // keyword as introduction of expression, like DISTINCT
      { $pathStep.args.push( this.xprToken() ); }
      expr=expression
      { $args = this.setLastAsXpr( $pathStep.args );
        $args.push( $expr.expr ); }
    |
      // Rule 'pathArguments' makes a decision based on the first two lookahead
      // tokens of this rule → we need to list tokens which would be changed to
      // GenericExpr or GenericIntro, and are not already covered by 'expression'
      { this.reportErrorForGenericKeyword(); }
      ( HideAlternatives | '*' | ALL | DISTINCT )
      // now continue parsing like GenericExpr:
      { $pathStep.args.push( this.xprToken() ); }
    )
    (
      { if (!$args) $args = this.setLastAsXpr( $pathStep.args ); }
      (
        { this.prepareGenericKeywords( $considerSpecial, 'separator' ); }
        (
           GenericSeparator
        |
          // For ANTLR's lookahead calculations, we need to list tokens here
          // which could be changed to GenericSeparator.  Do not invent a
          // keyword token which is just used here (Identifier does work
          // perfectly)!  If we want, we could add all non-reserved keywords
          // except ORDER, and most reserved.
          { this.reportErrorForGenericKeyword(); }
          ( HideAlternatives | Identifier | FROM | IN | WITH | GROUP )
        )
        { $args.push( this.xprToken() );
          this.prepareGenericKeywords( $considerSpecial, 'expr' );
        }
        (
          expr=expression
          { $args.push( $expr.expr ); }
        |
          GenericExpr
          { $args.push( this.xprToken() ); }
        |
          { this.reportErrorForGenericKeyword(); }
          // Again, we need to list tokens which could make it to GenericExpr
          // and which do not start an expression
          ( HideAlternatives | ALL )
          { $args.push( this.xprToken() ); }
        )
      )+
    )?
  ;

cardinalityAndFilter[ pathStep ] locals [ _sync = 'nop' ]
  :
    '['
    optionalCardinality[ pathStep ]?
    //{ $LeaveLoop = false; }
    optionalWhereForFilter
    co=condition { if ($pathStep) $pathStep.where = $co.cond; }
    ']'
  ;

optionalCardinality[ pathStep ]
@after { if ($pathStep && $pathStep.cardinality) this.attachLocation($pathStep.cardinality); }
  :
    // Make sure to test second token to allow expressions starting with Number
    // without introducing WHERE - that would be @options{k=2}.  The code
    // completion just produces `:`after having inserted a Number - TODO.
    { if (this._input.LT(2).text !== ':') return $ctx; }
    ( trgMax=Number ':'
      { if ($pathStep) $pathStep.cardinality = { targetMax: this.numberLiteral( $trgMax ), location: this.startLocation() }; }
    )
  ;

optionalWhereForFilter
  :
    // For ANTLR, WHERE is required, but we allow the generated parser skipping
    // the call of match(WHERE) except for the future (optional) clauses GROUP,
    // ORDER, LIMIT.  This hack requires that sync() at each state in the
    // calling rule does not throw an error if the current token does not match
    // one of the expected ones.
    {
      var text = this.getCurrentToken().text.toUpperCase();
      if (!['WHERE','GROUP','ORDER','LIMIT'].includes( text )) return;
      // TODO: should we somehow add those keywords to $(EXPECTED)?
    }
    WHERE
  ;

// Simple paths and values ---------------------------------------------------

annoValue[ assignment ]
  :
    base=annoValueBase[ $assignment ]
  |
    // no docComment() here
    // this alternative is done with token rewrite in rule "annotationAssignment_atn"
    at='@'? annotationPath[ $assignment, 'ref', $at ]
    annotationPathVariant[ $assignment ]?
  ;

annoValueBase[ assignment ] locals [ seenEllipsis = false ]
@after { this.attachLocation( $assignment ); }
  :
    '{'                         // no location here, we flatten
    { $assignment['$'+'flatten'] = []; this.meltKeywordToIdentifier(); }
    flattenedValue[ $assignment ]
    (
      ',' {
        this.meltKeywordToIdentifier();
        if (this.isStraightBefore("}")) break; // allow ',' before ')'
      }
      flattenedValue[ $assignment ]
    )*
    '}'
  |
    '['                 // no need for createArray() here, $assignment.location is set
    { $assignment.val = []; $assignment.literal = 'array'; }
    (
      (
        head=annoSubValue  { $assignment.val.push( $head.val ); }
      |
        e='...' ( UP TO upTo=annoSubValue )?
        {{
          const item = { literal: 'token', val: '...', location: this.tokenLocation($e) };
          $assignment.val.push( item );
          if ($ctx.upTo) item.upTo = $upTo.val;
          $seenEllipsis = !$ctx.upTo || 'upTo';
        }}
      )
      (
        ',' { if (this.isStraightBefore(']')) break; } // allow ',' before ']'
        (
          tail=annoSubValue { $assignment.val.push( $tail.val ); }
        |
          { $ctx.upTo = null; } // is not reset
          e='...' ( UP TO upTo=annoSubValue )?
          {{
            const item = { literal: 'token', val: '...', location: this.tokenLocation($e) };
            if ($ctx.upTo) item.upTo = $upTo.val;
            $assignment.val.push( item );
            if ($seenEllipsis === true)
              this.error( 'syntax-unexpected-ellipsis', $e,
                          { '#': 'duplicate', code: '...', keyword: 'up to' } );
            else
              $seenEllipsis = !$ctx.upTo || 'upTo';
          }}
        )
      )*
    )?
    cb=']'
    {
      if ($seenEllipsis === 'upTo')
        this.error( 'syntax-missing-ellipsis', $cb, // at closing bracket
                    { code: '... up to', newcode: '...' } );
    }
  |
    v1=literalValue { Object.assign( $assignment, $v1.val ); }
  |
    ( plus='+' | min='-' ) num=Number
    {  Object.assign( $assignment, this.numberLiteral( $num, $plus||$min ) ); }
  ;

flattenedValue[ assignment ] locals[ val = { name: {} } ]
  :
    at='@'? annotationPath[ $val.name, 'name', $at ]
    ( annotationPathVariant[ $val.name ] )?
    (
      ':' { this.meltKeywordToIdentifier(true); } // allow path as anno value start with reserved
      annoValue[ $val ]
    )?
    { $assignment['$'+'flatten'].push( $val ); }
  ;

namedValue[ struct ] locals[ val = { name: {} } ]
  :
    at='@'? annotationPath[ $val.name, 'name', $at ]
    ( ':' sub=annoSubValue { Object.assign( $val, $sub.val ); } )?
    {
      if (!$val.location) $val.location = $val.name.location;
      this.addDef( $val, $struct, 'struct', null, $val.name ); // TODO: re-check name
    }
  ;

annoSubValue returns[ val = {} ]
@after { this.attachLocation($val); }
  :
    '{'                         // no need for createDict() here, $val.location is set
    { $val.struct = Object.create(null); $val.literal = 'struct'; }
    { this.meltKeywordToIdentifier(); }
    namedValue[ $val ]
    ( ','
      {
        this.meltKeywordToIdentifier();
        if (this.isStraightBefore("}")) break; // allow ',' before '}'
      }
      namedValue[ $val ]
    )*
    '}'
  |
    '['                 // no need for createArray() here, $val.location is set
    { $val.val = []; $val.literal = 'array'; }
    ( head=annoSubValue { $val.val.push( $head.val ); }
      ( ',' { if (this.isStraightBefore(']')) break; } // allow ',' before ']'
        tail=annoSubValue { $val.val.push( $tail.val ); }
      )*
    )?
    ']'
  |
    v1=literalValue { Object.assign( $val, $v1.val ); }
  |
    ( plus='+' | min='-' ) num=Number
    { Object.assign( $val, this.numberLiteral( $num, $plus||$min ) ); }
  |
    at='@'? annotationPath[ $val, 'ref', $at ]
    ( annotationPathVariant[ $val ] )?
  ;

literalValue returns[ val ] locals[ tok ]
@init{ $tok = this.getCurrentToken(); }
@after { this.attachLocation($val); }
  :
    '#' name=ident['enumref']
    { $val = { literal: 'enum', sym: $name.id } }
  |
    NULL
    { $val = { literal: 'null', val: null }; }
  |
    Boolean
    { $val = { literal: 'boolean', val: $tok.text.toLowerCase() != 'false' }; }
  |
    Number
    { $val = this.numberLiteral( $tok, '' ); } // allow float and large number
  |
    String
    { $val = this.quotedLiteral( $tok, 'string' ); }
  |
    QuotedLiteral               // x'12', date'...', time'...', timestamp'...'
    { $val = this.quotedLiteral( $tok ); }
  ;

simplePath[ art, category ] locals[ _sync = 'nop' ]
@after { this.attachLocation($art); }
// Due to error recovery, rule `ident` can return with value `null`.  Set the
// path as broken in this case.
  :
    head=ident[ $category ]
    { if (!$art.path) $art.path = []; this.pushIdent( $art.path, $head.id );
      if ($category === 'artref') $art.scope = 0;
    }
    (
      '.' tail=ident[ $category ] { this.pushIdent( $art.path, $tail.id ); }
    )*
  ;

annotationPath[ art, category, headat = null ] locals[ _sync = 'nop' ]
@after { this.attachLocation($art); }
// Due to error recovery, rule `ident` can return with value `null`.  Set the
// path as broken in this case.
  :
    head=ident[ $category ]
    { $art.path = []; this.pushIdent( $art.path, $head.id, $headat );
      if ($category === 'artref') $art.scope = 0;
    }
    (
      '.' at='@'? tail=ident[ $category ]
      { this.pushIdent( $art.path, $tail.id, $at );
        // Otherwise, $at may continue to be set after one `.@anno` segment.
        $ctx.at = null;
      }
    )*
  ;

annotationPathVariant[ art ] locals[ variant = {} ]
@after { this.attachLocation($art); }
  :
    // TODO: warning for space after '#'
    '#' { this.meltKeywordToIdentifier(); }
    simplePath[ $variant, 'variant' ] { $art.variant = $variant; }
  ;

// Identifier and non-reserved keywords --------------------------------------

identNoKeyword[ category ] returns[ id ]    // for aliases without AS
@after{ $id = this.identAst( $stop, $category ); }
  :
    Identifier
  ;

// The `ident` rule matches `Identifier` and all non-reserved keywords.  List
// all non-reserved keywords directly, do not use an indirection via a rule
// like `nonReservedKeywords`.
ident[ category ] returns[ id ]
@after{ $id = this.identAst( $stop, $category ); }
  :
    Identifier
  | ABSTRACT
  | ACTION
  | ACTIONS
  | AND
  | ANNOTATE
  | ANNOTATION
  | ARRAY
  | ASC
  | ASPECT
  | ASSOCIATION
  | BETWEEN
  | COLUMNS
  | COMPOSITION
  | CONTEXT
  | CROSS
  | CURRENT
  | DEFAULT
  | DEFINE
  | DEFINITIONS
  | DESC
  | ELEMENT
  | ELEMENTS
  | ELSE
  | END
  | ENTITY
  | ENUM
  | ESCAPE
  | EVENT
  | EXACT
  | EXCEPT
  | EXCLUDING
  | EXTEND
  | FIRST
  | FLOATING
  | FOLLOWING
  | FULL
  | FUNCTION
  | GROUP
  | HAVING
  | INNER
  | INTERSECT
  | INTO
  | IS
  | JOIN
  | LAST
  | LEFT
  | LIKE
  | LIMIT
  | LOCALIZED
  | MANY
  | MASKED
  | MINUS
  | MIXIN
  | NAMESPACE
  | NULLS
  | OFFSET
  | ONE
  | OR
  | ORDER
  | OUTER
  | PARAMETERS
  | PARTITION
  | PRECEDING
  | PROJECTION
  | REDIRECTED
  | RETURNS
  | RIGHT
  | ROW
  | ROWS
  | SERVICE
  | THEN
  | UNION
  | UP
  | TO
  | TYPE
  | USING
  | UNBOUNDED
  | VARIABLE
  | VIEW
  ;

//----------------------------------------------------------------------------

WhiteSpace                      // like \s in JavaScript RegExp
  :                             // LineTerminator | [\t\f\v\u00A0\uFEFF] | Zs
    [\r\n\u2028\u2029 \t\f\u000B\u00A0\u1680\u180e\u2000-\u200A\u202F\u205F\u3000\uFEFF]+
    -> skip ;

DocComment : '/**' .*? '*/' -> channel(HIDDEN);

Comment : '/*' .*? '*/' -> channel(HIDDEN);

LineComment : '//' ~[\r\n\u2028\u2029]* -> channel(HIDDEN);

// Values --------------------------------------------------------------------

// for syntactic code-completion: Combine all three string styles
// Note: Use rule `string` instead as that also parses escape sequences!
String : SingleLineString
       | MultiLineString
       | MutlLineStringBlock;

fragment SingleLineString
  :
      // \u0027 = '\''
      // \u2028 = LS (Line Separator)
      // \u2029 = PS (Paragraph Separator)
      ( '\'' ~[\u0027\n\r\u2028\u2029]* '\'' )+ //
  ;

fragment MultiLineString
  :
    ('`' ( MultiLineStringContentChar | EscapeSequence )* '`' )
  ;

fragment MutlLineStringBlock
  :
    ('```' ( MultiLineStringContentChar | EscapeSequence )*  '```')
  ;

fragment EscapeSequence
  :
   // we could list each escape sequence explicitly, but we already
   // decode them in genericAntlrParser.js, so no need to do work twice.
   '\\' .
  ;

fragment MultiLineStringContentChar
  :
   (~[\u0060\\]) // \u0060 = '`'
  ;

QuotedLiteral
  :
    ( [xX] | [dD][aA][tT][eE] | [tT][iI][mM][eE] ( [sS][tT][aA][mM][pP] )? )
    ( '\'' ~[\u0027\n\r\u2028\u2029]* '\'' )+ // \u0027 = '\''
  ;

// This literal improves error messages for unterminated literals.
UnterminatedLiteral
  :
    ( [xX] | [dD][aA][tT][eE] | [tT][iI][mM][eE] ( [sS][tT][aA][mM][pP] )? )?
    '\'' ~[\u0027\n\r\u2028\u2029]* // \u0027 = '\''
    |
    ('`' ( MultiLineStringContentChar | EscapeSequence )* )
    |
    ('```' ( MultiLineStringContentChar | EscapeSequence )* )
  ;

UnterminatedDelimitedIdentifier
  :
    '"' ~[\u0022\n\r\u2028\u2029]* ( '""' ~[\u0022\n\r\u2028\u2029]* )* // \u0022 = '"'
  | '![' ~[\u005d\n\r\u2028\u2029]*  ( ']]' ~[\u005d\n\r\u2028\u2029]* )* // \u005d = ']'
// \u005d = ']'
  ;

Boolean                         // TMP?
  : [tT][rR][uU][eE] | [fF][aA][lL][sS][eE]
  ;

// Reserved keywords (are case-insensitive): ---------------------------------

ALL : [aA][lL][lL] ;
ANY : [aA][nN][yY] ;
AS : [aA][sS] ;
BY : [bB][yY] ;
CASE : [cC][aA][sS][eE] ;
CAST : [cC][aA][sS][tT] ;
DISTINCT : [dD][iI][sS][tT][iI][nN][cC][tT] ;
EXISTS : [eE][xX][iI][sS][tT][sS] ;
// FALSE: see Boolean
FROM : [fF][rR][oO][mM] ;
IN : [iI][nN] ;
KEY : [kK][eE][yY] ;
NEW : [nN][eE][wW] ;            // token rewrite for NEW -> not reserved (also not in SQL)
NOT : [nN][oO][tT] ;
NULL : [nN][uU][lL][lL] ;
OF : [oO][fF] ;
ON : [oO][nN] ;
SELECT : [sS][eE][lL][eE][cC][tT] ;
SOME : [sS][oO][mM][eE] ;
WHEN : [wW][hH][eE][nN] ;
// TRUE: see Boolean
WHERE : [wW][hH][eE][rR][eE] ;
WITH : [wW][iI][tT][hH] ;

// Fixed Token which is defined DIRECTLY BEFORE the unreserved keywords ------

Number                          // DO NOT RENAME OR MOVE THIS RULE !!!
  : [0-9]+                      // no initial sign
    ( '.' [0-9]+ )?
    ( [eE] ('+'|'-')? [0-9]+ )?
  ;

// Unreserved keywords (are case-insensitive): -------------------------------
// Do not add keywords just for specialFunctions!

ABSTRACT : [aA][bB][sS][tT][rR][aA][cC][tT] ;
ACTION : [aA][cC][tT][iI][oO][nN] ;
ACTIONS : [aA][cC][tT][iI][oO][nN][sS] ;
AND : [aA][nN][dD] ;
ANNOTATE : [aA][nN][nN][oO][tT][aA][tT][eE] ;
ANNOTATION : [aA][nN][nN][oO][tT][aA][tT][iI][oO][nN] ;
ARRAY : [aA][rR][rR][aA][yY] ;
ASC : [aA][sS][cC] ;
ASPECT : [aA][sS][pP][eE][cC][tT] ;
ASSOCIATION : [aA][sS][sS][oO][cC][iI][aA][tT][iI][oO][nN] ;
BETWEEN : [bB][eE][tT][wW][eE][eE][nN] ;
COLUMNS : [cC][oO][lL][uU][mM][nN][sS];
COMPOSITION : [cC][oO][mM][pP][oO][sS][iI][tT][iI][oO][nN] ;
CONTEXT : [cC][oO][nN][tT][eE][xX][tT] ;
CROSS : [cC][rR][oO][sS][sS] ;
CURRENT : [cC][uU][rR][rR][eE][nN][tT] ;
DEFAULT : [dD][eE][fF][aA][uU][lL][tT] ;
DEFINE : [dD][eE][fF][iI][nN][eE] ;
DEFINITIONS : [dD][eE][fF][iI][nN][iI][tT][iI][oO][nN][sS] ;
DESC : [dD][eE][sS][cC] ;
ELEMENT : [eE][lL][eE][mM][eE][nN][tT] ;
ELEMENTS : [eE][lL][eE][mM][eE][nN][tT][sS] ;
ELSE : [eE][lL][sS][eE] ;
END : [eE][nN][dD] ;
ENTITY : [eE][nN][tT][iI][tT][yY] ;
ENUM : [eE][nN][uU][mM] ;
EVENT : [eE][vV][eE][nN][tT] ;
ESCAPE : [eE][sS][cC][aA][pP][eE] ;
EXACT : [eE][xX][aA][cC][tT] ;
EXCEPT : [eE][xX][cC][eE][pP][tT] ;
EXCLUDING : [eE][xX][cC][lL][uU][dD][iI][nN][gG] ;
EXTEND : [eE][xX][tT][eE][nN][dD] ;
FIRST : [fF][iI][rR][sS][tT] ;
FLOATING : [fF][lL][oO][aA][tT][iI][nN][gG] ;
FOLLOWING : [fF][oO][lL][lL][oO][wW][iI][nN][gG] ;
FULL : [fF][uU][lL][lL] ;
FUNCTION : [fF][uU][nN][cC][tT][iI][oO][nN] ;
GROUP : [gG][rR][oO][uU][pP] ;
HAVING : [hH][aA][vV][iI][nN][gG] ;
INNER : [iI][nN][nN][eE][rR] ;
INTERSECT : [iI][nN][tT][eE][rR][sS][eE][cC][tT] ;
INTO : [iI][nN][tT][oO] ;
IS : [iI][sS] ;
JOIN : [jJ][oO][iI][nN] ;
LAST : [lL][aA][sS][tT] ;
LEFT : [lL][eE][fF][tT] ;
LIKE : [lL][iI][kK][eE] ;
LIMIT : [lL][iI][mM][iI][tT] ;
LOCALIZED: [lL][oO][cC][aA][lL][iI][zZ][eE][dD];
MANY : [mM][aA][nN][yY] ;
MASKED : [mM][aA][sS][kK][eE][dD] ;
MINUS : [mM][iI][nN][uU][sS] ;
MIXIN : [mM][iI][xX][iI][nN] ;
NAMESPACE : [nN][aA][mM][eE][sS][pP][aA][cC][eE] ;
NULLS : [nN][uU][lL][lL][sS] ;
OFFSET : [oO][fF][fF][sS][eE][tT] ;
ONE : [oO][nN][eE] ;
OR : [oO][rR] ;
ORDER : [oO][rR][dD][eE][rR] ;
OUTER : [oO][uU][tT][eE][rR] ;
// OVER : [oO][vV][eE][rR] ;
PARAMETERS : [pP][aA][rR][aA][mM][eE][tT][eE][rR][sS] ;
PARTITION: [pP][aA][rR][tT][iI][tT][iI][oO][nN] ;
PRECEDING: [pP][rR][eE][cC][eE][dD][iI][nN][gG] ;
PROJECTION : [pP][rR][oO][jJ][eE][cC][tT][iI][oO][nN] ;
REDIRECTED : [rR][eE][dD][iI][rR][eE][cC][tT][eE][dD] ;
RETURNS : [rR][eE][tT][uU][rR][nN][sS] ;
RIGHT : [rR][iI][gG][hH][tT] ;
ROW : [rR][oO][wW] ;
ROWS : [rR][oO][wW][sS] ;
SERVICE : [sS][eE][rR][vV][iI][cC][eE] ;
THEN : [tT][hH][eE][nN] ;
TO : [tT][oO] ;                 // or make reserved? (is in SQL-92)
TYPE : [tT][yY][pP][eE] ;
UNION : [uU][nN][iI][oO][nN] ;
UNBOUNDED : [uU][nN][bB][oO][uU][nN][dD][eE][dD] ;
UP : [uU][pP] ;
USING : [uU][sS][iI][nN][gG] ;
VARIABLE : [vV][aA][rR][iI][aA][bB][lL][eE] ;
VIEW : [vV][iI][eE][wW] ;
// VIRTUAL: [vV][iI][rR][tT][uU][aA][lL] ; see tokens {}

// Identifiers, must BE LAST, DIRECTLY AFTER the unreserved keywords ---------

Identifier                      // DO NOT RENAME OR MOVE THIS RULE !!!
  : [$_a-zA-Z][$_a-zA-Z0-9]*    // i.e. including $param
  | ( '"' ~[\u0022\n\r\u2028\u2029]* '"' )+ // \u0022 = '"'
  | '![' ~[\u005d\n\r\u2028\u2029]* ']' ( ']' ~[\u005d\n\r\u2028\u2029]* ']' )* // \u005d = ']'
  ;

IllegalToken : . ;

// Local Variables:
// c-basic-offset: 2
// End:
