'use strict'

/**
 * parseExpr accepts any JSON object and tries to convert a token stream expression
 * array into an AST like expression with CDL operator precedence.
 *
 * The following operators are supported:
 *
 * Multiplication/Division:    '*', '/'
 * Addition/Subtraction:       '+', '-'
 * Concatenation:              '||'
 * Relational:                 '=', '<>', '>', '>=', '<', '<=', '!=', 'like', 'in', 'exists', 'between and'
 * Unary:                      'is [not] null', 'not'
 * Conditional:                'case [when then]+ [else]? end', 'and', 'or'
 *
 * Not yet implmemented:       'new'
 *
 * This is not an optimized LL(1) parser but a token 'sniffer'. A stream is
 * cracked up in sub streams and passed down to the next higher function.
 *
 * Complex aggregates like case/when/else/end and between are parsed first to pass down the
 * resulting sub expressions and avoiding 'and' ambiguities.
 *
 * Sub expressions are grouped as arrays, the final AST is an array of nested arrays.
 * Alternatively, an object like AST can be produced by setting argument 'array' to false.
 *
 * This parser intentionally does no error handling. If a clause is malformed, it is accepted as is.
 *
 * @param {any} xpr A JSON object.
 * @param {Boolean} array Bias AST representation.
 */

function parseExpr(xpr, array=true) {
  return parseExprInt(xpr);

  function parseExprInt(xpr) {
    return conditionOR(...CaseWhen(xpr));
  }

  function CaseWhen(xpr) {
    if(Array.isArray(xpr))
      inner(xpr);
    return [xpr, 0, Array.isArray(xpr) ? xpr.length : 1];

    // replace case/end from inner to outer
    function inner(pxpr, lvl=0) {
      const s = pxpr.findIndex(t => t === 'case');
      if(s >= 0) {
        let e = findLastIndex(pxpr, 'end');
        pxpr = pxpr.slice(s+1, e);
        const dist = inner(pxpr, lvl+1);
        e -= dist;
        if(dist > 0)
          pxpr = xpr.slice(s+1, e+1);
        const caseTree = array ? [ 'case' ] : { 'case': [] };
        let i = pxpr.findIndex(t => t === 'else');
        let elseCond = undefined;
        if(i >= 0) {
          elseCond = pxpr.slice(i+1);
          pxpr = pxpr.slice(0, i);
        }
        i = pxpr.findIndex(t => t === 'when');
        while(i >= 0) {
          pxpr = pxpr.slice(i+1);
          const when = { 'when': [] };
          if(array)
            caseTree.push('when');
          else
            caseTree.case.push(when);
          i = pxpr.findIndex(t => t === 'then');
          if(i >= 0) {
            const arg = pxpr.slice(0, i);
            if(array)
              caseTree.push(arg);
            else
              when.when.push(arg.length === 1 ? arg[0] : arg);
          }
          pxpr = pxpr.slice(i+1);
          i = pxpr.findIndex(t => t === 'when');
          const arg = ((i >= 0) ? pxpr.slice(0, i) : pxpr);
          if(array)
            caseTree.push('then', arg);
          else
            when.when.push(arg.length === 1 ? arg[0] : arg);
        }
        if(elseCond) {
          if(array)
            caseTree.push('else', elseCond);
          else
            caseTree.case.push(elseCond.length === 1 ? elseCond[0] : elseCond);
        }
        if(array)
          caseTree.push('end');
        if(lvl > 0)
          xpr.splice(s+1, e-s+1, caseTree);
        else {
          xpr = caseTree;
        }
        return e-s+1;
      }
      else
        return 0;
    }

    function findLastIndex(expr, token, l=expr.length-1) {
      while(l >= 0 && expr[l] !== token) l--;
      return l;
    }
  }

  function conditionOR(xpr, s, e) {
    return binaryExpr(xpr, ['or'], conditionAnd, s, e);
  }
  function conditionAnd(xpr, s, e) {
    return binaryExpr(xpr, (xpr, s, e) => {
      let a = s-1;
      let b;
      // scan for 'and', skip 'between/and'
      do {
        b = false;
        for(a++; xpr[a] !== 'and' && a < e; a++) {
          if(xpr[a] === 'between')
            b = true;
        }
      } while(b && a < e)

      if(!b && a < e)
        return [1, a]
      else
        return [1, -1];
    }, conditionTerm, s, e);
  }

  function conditionTerm(xpr, s, e) {
    if(Array.isArray(xpr)) {
      if(xpr.length >= 3 && xpr[s+1] === 'is') {
        if(xpr[s+2] === 'null')
          return array ? [ conditionOR(xpr[s]), 'is', 'null' ] :  { 'isNull': conditionOR(xpr[s]) };
        else if(xpr[s+2] === 'not' && xpr[s+3] === 'null')
          return array ? [ conditionOR(xpr[s]), 'is', 'not', 'null' ] : { 'isNotNull': conditionOR(xpr[s]) };
      }
      if(xpr[s] === 'not')
        return array ? [ 'not', conditionTerm(xpr, s+1, e) ] : { 'not': conditionTerm(xpr, s+1, e) };
      if(xpr[s] === 'exists')
        return array ? [ 'exists', conditionOR(xpr[s+1]) ] : { 'exists': conditionOR(xpr[s+1]) };
    }
    return compareTerm(xpr, s, e);
  }

  function compareTerm(xpr, s, e) {
    if(Array.isArray(xpr)) {
      let i = s;
      while(i < e && xpr[i] !== 'between') i++;
      const b = i < e ? i : -1;
      while(i < e && xpr[i] !== 'and') i++;
      const a = i < e ? i : -1;
      if(b >= 0) {
        const expr = expression(xpr, s, b);
        const between = array ? [ expr, 'between' ] : { 'between': [ expr ] };
        if(a >= 0) {
          const lower = expression(xpr, b+1, a);
          const upper = expression(xpr, a+1, e);
          if(array)
            between.push(lower, 'and', upper);
          else {
            between.between.push(lower, upper);
          }
        }
        else {
          const unspec = expression(xpr, b+1, e);
          if(array)
            between.push(unspec);
          else
            between.between.push(unspec);
        }
        return between;
      }
    }
    return binaryExpr(xpr, ['=', '<>', '>', '>=', '<', '<=', '!=', 'like', 'in'], expression, s, e);
  }

  function expression(xpr, s, e) {
    return binaryExpr(xpr, ['||'], exprAddSub, s, e);
  }

  function exprAddSub(xpr, s, e) {
    return binaryExpr(xpr, ['+', '-'], exprMulDiv, s, e);
  }

  function exprMulDiv(xpr, s, e) {
    return binaryExpr(xpr, ['*', '/'], terminal, s, e);
  }

  function terminal(xpr, s, e) {
    if(Array.isArray(xpr) && xpr.length > 0) {
      if(e-s <= 1)
        return parseExprInt(xpr[e-1]);
      else
        return xpr.slice(s, e).map(parseExprInt);
    }
    if (typeof xpr === 'object') {
      for(let n in xpr) {
        xpr[n] = parseExprInt(xpr[n]);
      }
    }
    return xpr;
  }

  function binaryExpr(xpr, token, next, s, e) {
    if (Array.isArray(xpr)) {
      let [tl, p] = findToken(s, e);
      if (p >= 0) {
        let lhs = next(xpr, s, p);
        let op = xpr[p];
        s = p+tl;
        [tl, p] = findToken(s, e);
        while(p >= 0) {
          let rhs = next(xpr, s, p);
          lhs = array ? [ lhs, op, rhs ] : { [op]: [lhs, rhs] };
          op = xpr[p];
          s = p+tl;
          [tl, p] = findToken(s, e);
        }
        return array ? [ lhs, op, next(xpr, s, e) ] : { [op]: [lhs, next(xpr, s, e)] };
      }
    }
    return next(xpr, s, e);

    function findToken(s, e) {
      if(typeof token === 'function')
        return token(xpr, s, e);
      else {
        while(s < e && !token.includes(xpr[s])) s++;
        if(s < e)
          return [1, s];
      }
      return [1, -1];
    }
  }

}

module.exports = {
  parseExpr,
};
