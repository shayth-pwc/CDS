'use strict';

/**
 * In this module resides all the logic related to exposure of types as part of the OData backend
 * The exposure is run only for definitions which reside in a service.
 * @module typesExposure
 */

const { setProp } = require('../../base/model');
const { defNameWithoutServiceOrContextName, isArtifactInService } = require('./utils');
const { cloneCsnNonDict, isBuiltinType, forEachDefinition, forEachMember } = require('../../model/csnUtils');
const { copyAnnotations } = require('../../model/csnUtils');
const { isBetaEnabled } = require('../../base/model.js');

function typesExposure(csn, whatsMyServiceName, requestedServiceNames, fallBackSchemaName, options, csnUtils, message) {
  const { error } = message;
  // are we working with OData proxies or cross-service refs
  const isMultiSchema = options.odataVersion === 'v4' && (options.odataProxies || options.odataXServiceRefs);
  // collect in this variable all the newly exposed types
  const schemas = Object.create(null);
  const exposedTypes = Object.create(null);
  // walk through the definitions of the given CSN and expose types where needed
  forEachDefinition(csn, (def, defName, propertyName, path) => {
    // we do expose types only for definition from inside services
    const serviceName = whatsMyServiceName(defName, false);
    // run type exposure only on requested services if not in multi schema mode
    // multi schema mode requires a proper type exposure for all services as a prerequisite
    // for the proxy exposure
    if (serviceName && requestedServiceNames.includes(serviceName)) {
      if (def.kind === 'type' || def.kind === 'entity') {
        forEachMember(def, (element, elementName, propertyName, path) => {
          if (propertyName === 'elements' || propertyName === 'params') {
            const newTypeName = getNewTypeName(element, elementName, defName, serviceName);
            exposeTypeOf(element, element.key || propertyName === 'params', elementName, defName, serviceName, newTypeName, path);
          }
        }, path);
      }

      // For exposed actions and functions that use non-exposed or anonymous structured types, create
      // artificial exposing types.
      // unbound actions
      if (def.kind === 'action' || def.kind === 'function') {
        exposeTypesOfAction(def, defName, defName, serviceName, path);
      }
      // bound actions
      def.actions && Object.entries(def.actions).forEach(([actionName, action]) => {
        exposeTypesOfAction(action, `${defName}_${actionName}`, defName, serviceName, path.concat(['actions', actionName]));
      });
    }
  });

  return schemas;

/**
   * If an 'action' uses structured types as parameters or return values that are not exposed in 'service'
   * (because the types are anonymous or have a definition outside of 'service'),
   * create equivalent types in 'service' and make 'action' use them instead,
   * @param {Object} action
   * @param {String} actionName
   * @param {String} serviceName
   */
  function exposeTypesOfAction(action, actionName, defName, serviceName, path) {
    if (action.returns) {
      const artificialName = `return_${actionName.replace(/\./g, '_')}`;
      const newTypeName = getNewTypeName(action.returns, undefined, artificialName, serviceName);
      exposeTypeOf(action.returns, false, actionName, defName, serviceName, newTypeName, path.concat(['returns']));
    }

    action.params && Object.entries(action.params).forEach(([paramName, param]) => {
      const artificialName = `param_${actionName.replace(/\./g, '_')}`;//_${paramName}`;
      const newTypeName = getNewTypeName(param, paramName, artificialName, serviceName);
      exposeTypeOf(param, false, actionName, defName, serviceName, newTypeName, path.concat(['params', paramName]));
    });
  }

  /**
   * If 'node' exists and has a structured type that is not exposed in 'service', (because the type is anonymous or
   * has a definition outside of 'service'), create an equivalent type in 'service' and assign the new type
   * for a value of the 'node.type' property.
   * @param {Object} node
   * @param {String} memberName
   * @param {String} serviceName
   * @param {String} newTypeName
   */
  function exposeTypeOf(node, isKey, memberName, defName, serviceName, newTypeName, path, parentName) {
    const { isExposable, typeDef, typeName, elements, isAnonymous } = isTypeExposable(node);
    if (isExposable) {
      // this is the name used to register the new type in csn.definitions
      let fullQualifiedNewTypeName =
        isMultiSchema
          ? (node.type || (node.items && node.items.type)
              ? getTypeNameInMultiSchema(node.type|| (node.items && node.items.type), serviceName)
              : getAnonymousTypeNameInMultiSchema(newTypeName, parentName || defName))
          : `${serviceName}.${newTypeName}`;

      if (!isAnonymous) {
        // as soon as we leave of the anonymous world,
        // we're no longer in a key def => don't set notNull:true on named types
        if(isKey)
          isKey = false;
        // in case this was a named type and if the openess does not match the type definition
        // expose the type as a new one not changing the original definition.
        if((!!node['@open'] !== !!typeDef['@open']) && isBetaEnabled(options, 'odataOpenType'))
          fullQualifiedNewTypeName += node['@open'] ? '_open' : '_closed';
      }
      // check if that type is already defined
      let newType = csn.definitions[fullQualifiedNewTypeName];
      if (newType) {
        // error, if it was not exposed by us
        if (!exposedTypes[fullQualifiedNewTypeName]) {
          setProp(node, '$NameClashReported', true);
          error(null, path, { type: fullQualifiedNewTypeName, name: memberName },
            'Can\'t create artificial type $(TYPE) for $(NAME) because the name is already used');
          return { isExposable, typeDef, typeName, isAnonymous };
        }
      }
      else {
        /* Expose new structured type
         * Treat items.elements as ordinary elements for now.
         */
        newType = createNewStructType(elements);
        // if using node enforces open/closed, set it on type
        if(node['@open'] !== undefined)
          newType['@open'] = node['@open']
        if (node.$location)
          setProp(newType, '$location', node.$location);

        csn.definitions[fullQualifiedNewTypeName] = newType;
        exposedTypes[fullQualifiedNewTypeName] = 1;

        // Recurse into elements of 'type' (if any) and expose them as well (is needed)
        newType.elements && Object.entries(newType.elements).forEach(([elemName, newElem]) => {
          if (node.elements && node.elements[elemName].$location)
            setProp(newElem, '$location', node.elements[elemName].$location);
          defName = typeDef.kind === 'type' ? typeName : defName;
          {
            const { isExposable, typeDef, typeName } = exposeTypeOf(newElem, isKey, elemName, defName, serviceName,
                           getNewTypeName(newElem, elemName, newTypeName, serviceName), path, fullQualifiedNewTypeName);
            // if the type for the newElem was not exposed it may be a scalar type def from an external service that hasn't
            // been catched by expandToFinalBaseType() (forODataNew must not modify external imported services)
            if(!isExposable && isBuiltinType(typeName) && !isBuiltinType((newElem.items?.type || newElem.type))) {
              if(typeDef.items) {
                newElem.items = typeDef.items;
                delete newElem.type;
              }
              else if(newElem.items) {
                newElem.items.type = typeName;
                if(typeDef.enum)
                  newElem.items.enum = typeDef.enum;
              }
              else {
                newElem.type = typeName;
                if(typeDef.enum)
                  newElem.enum = typeDef.enum;
              }
            }
          }
        });
        copyAnnotations(typeDef, newType);
        // if the origin type had items, add items to exposed type
        if(typeDef.kind === 'type') {
          if(typeDef.items) {
            newType.items = { elements: newType.elements };
            delete newType.elements;
          }
        }
      }
      // adjust current node to new type
      if(node.items) {
        delete node.items.elements;
        delete node.type;
        node.items.type = fullQualifiedNewTypeName;
      }
      else {
        delete node.elements;
        node.type = fullQualifiedNewTypeName;
      }
    }
    return { isExposable, typeDef, typeName, isAnonymous };

     /**
     * Check if the node's type can be exposed:
     * 1) If it's an anonymous structured type (items.elements || elements)
     * 2) If it's a named type resolve to the final type definition and
     *    check if this is a structured type
     * Returns an object that indicates
     *  - wether or not the type needs exposure
     *  - the elements dictionary that needs to be cloned
     *  - the typeDef, either the resolved type def or the node itself
     *  - if structured type was anonymously defined
     * @param {object} node
     * @returns {object} { isExposable, typeDef, typeName, elements, isAnonymous }
     */
    function isTypeExposable(node) {
      let typeName = undefined;
      let typeDef = node;
      let elements = (node.items && node.items.elements || node.elements)
      // anonymous structured type
      if(elements)
        return { isExposable: true, typeDef, typeName, elements, isAnonymous: true };
      // named type, resolve the type to inspect it
      let type = node.items && node.items.type || node.type;
      if(type) {
        typeName = (type.ref && csnUtils.getFinalType(type)) || type;
        typeDef = csnUtils.getFinalTypeDef(typeName);
        const rc = { isExposable: true, typeDef, typeName, isAnonymous: false };
        if(!isBuiltinType(typeName) && !isArtifactInService(typeName, serviceName)) {
          while(!isBuiltinType(typeName)) {
            typeDef = csnUtils.getFinalTypeDef(typeName);
            if(typeDef) {
              if((rc.elements = (typeDef.items && typeDef.items.elements || typeDef.elements)) !== undefined)
                return rc;
              type = typeDef.items && typeDef.items.type || typeDef.type;
              typeName = (type.ref && csnUtils.getFinalType(type)) || type;
            }
            else {
              throw Error(`Please debug me: ${typeName} not found`);
            }
          }
        }
      }
      return { isExposable: false, typeDef, typeName, isAnonymous: false };
    }


    /**
     * Calculate the new type name that will be exposed in multi schema,
     * in case that the element has a named type.
     *
     * @param {string} typeName type of the element
     * @param {string} serviceName current service name
     */
    function getTypeNameInMultiSchema(typeName, serviceName) {
      const typeService = whatsMyServiceName(typeName);
      if (typeService) {
        // new type name without any prefixes
        const typePlainName = defNameWithoutServiceOrContextName(typeName, typeService);
        const newSchemaName = `${serviceName}.${typeService}`;
        createSchema(newSchemaName);
        // return the new type name
        return `${newSchemaName}.${typePlainName.replace(/\./g, '_')}`;
      } else {
        const typeContext = csnUtils.getContextOfArtifact(typeName);
        const typeNamespace = csnUtils.getNamespaceOfArtifact(typeName);
        const newSchemaName = `${serviceName}.${typeContext || typeNamespace || fallBackSchemaName}`;
        // new type name without any prefixes
        const typePlainName = typeContext ? defNameWithoutServiceOrContextName(typeName, typeContext)
          : typeName.replace(`${typeNamespace}.`, '');
        createSchema(newSchemaName);
        // return the new type name
        return `${newSchemaName}.${typePlainName.replace(/\./g, '_')}`;
      }
    }

    /**
     * Calculate the new type name that will be exposed in multi schema,
     * in case that the element has an anonymous type.
     *
     * @param {string} typeName type of the element
     * @param {string} parentName name of the parent def holding the element
     */
    function getAnonymousTypeNameInMultiSchema(typeName, parentName) {
      let currPrefix = parentName.substring(0, parentName.lastIndexOf('.'));
      const newSchemaName = currPrefix || fallBackSchemaName;
      // new type name without any prefixes
      const typePlainName = defNameWithoutServiceOrContextName(typeName, newSchemaName);

      createSchema(newSchemaName);
      return `${newSchemaName}.${typePlainName.replace(/\./g, '_')}`;
    }

    /**
     * Tf does not exists, create a context with the given name in the CSN
     * @param {string} name
     */
    function createSchema(name) {
      schemas[name] = { kind: 'schema', name };
    }

    /**
     * create a new structured type for 'elements'
     * @param {Object} elements
     */
    function createNewStructType(elements) {
      // Create a type with empty elements
      const type = {
        kind: 'type',
        elements: Object.create(null),
      };
      setProp(type, '$exposedBy', 'typeExposure');

      // Duplicate elements
      Object.entries(elements).forEach(([elemName, element]) => {
        let cloned = cloneCsnNonDict(element, options);
        // if this was an anonymous sub element of a key, mark it as not nullable
        if(isAnonymous && isKey && !cloned.key && cloned.notNull === undefined)
          cloned.notNull = true;
        type.elements[elemName] = cloned;
      });
      return type;
    }
  }

  /*
   * Calculate the name of the exposed type based on the information, the element can provide
   * If the element is typed, use the type name
   * else assume it's a de-anonymized type, concatenate the element name to the defName
  */
  function getNewTypeName(element, elementName, typeNamePrefix, serviceName) {
    // for the new type name node.type has precedence over node.items.type
    const typeName = (!element.elements && element.type || element.items && !element.items.elements && element.items.type);
    return typeName
        ? `${isMultiSchema
              ? typeName.split('.').pop() // use leaf element
              : typeName.replace(/\./g, '_')}` // concatenate path
        : ( elementName // returns has no elementName, return the precalculated prefix
            ? `${defNameWithoutServiceOrContextName(typeNamePrefix, serviceName).replace(/\./g, '_')}_${elementName}`
            : typeNamePrefix
          );
  }
}

module.exports = typesExposure;
